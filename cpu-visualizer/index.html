<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CPU Architecture Visualizer</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@300;400;500;600;700&family=Orbitron:wght@400;700;900&display=swap');

  :root {
    --bg: #050810;
    --bg2: #080d18;
    --bg3: #0d1525;
    --panel: #0a1020;
    --border: #1a2840;
    --border2: #243650;
    --accent: #00d4ff;
    --accent2: #0088ff;
    --green: #00ff88;
    --orange: #ff8800;
    --red: #ff3355;
    --purple: #aa44ff;
    --yellow: #ffdd00;
    --text: #c8d8f0;
    --text2: #7090b0;
    --text3: #405070;
    --glow: rgba(0,212,255,0.15);
    --glow2: rgba(0,136,255,0.1);
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Rajdhani', sans-serif;
    font-size: 14px;
    overflow: hidden;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }

  header {
    background: linear-gradient(90deg, #050810, #0a1428, #050810);
    border-bottom: 1px solid var(--border);
    padding: 8px 20px;
    display: flex;
    align-items: center;
    gap: 20px;
    flex-shrink: 0;
    position: relative;
    overflow: hidden;
  }
  header::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--accent), transparent);
  }
  .logo {
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    font-weight: 900;
    color: var(--accent);
    text-shadow: 0 0 20px var(--accent);
    letter-spacing: 3px;
    flex-shrink: 0;
  }
  .logo span { color: var(--text2); font-weight: 400; font-size: 11px; letter-spacing: 2px; display: block; }

  .clock-display {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-left: auto;
  }
  .clock-item {
    text-align: center;
    padding: 4px 12px;
    border: 1px solid var(--border);
    background: var(--bg3);
  }
  .clock-item .val {
    font-family: 'Share Tech Mono', monospace;
    font-size: 16px;
    color: var(--green);
    text-shadow: 0 0 10px var(--green);
  }
  .clock-item .lbl { font-size: 9px; color: var(--text3); letter-spacing: 1px; text-transform: uppercase; }

  .global-controls { display: flex; gap: 8px; align-items: center; }
  .btn {
    font-family: 'Rajdhani', sans-serif;
    font-size: 12px;
    font-weight: 600;
    letter-spacing: 1px;
    padding: 5px 14px;
    border: 1px solid var(--border2);
    background: var(--bg3);
    color: var(--text);
    cursor: pointer;
    text-transform: uppercase;
    transition: all 0.15s;
  }
  .btn:hover { border-color: var(--accent); color: var(--accent); background: var(--glow); }
  .btn.active { border-color: var(--accent); color: var(--accent); background: var(--glow2); box-shadow: 0 0 12px var(--glow); }
  .btn.green { border-color: var(--green); color: var(--green); }
  .btn.green:hover { background: rgba(0,255,136,0.1); box-shadow: 0 0 12px rgba(0,255,136,0.2); }
  .btn.orange { border-color: var(--orange); color: var(--orange); }

  .tabs {
    display: flex;
    background: var(--bg2);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
    overflow-x: auto;
  }
  .tab {
    padding: 8px 18px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 12px;
    font-weight: 600;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: var(--text3);
    cursor: pointer;
    border-right: 1px solid var(--border);
    white-space: nowrap;
    position: relative;
    transition: color 0.2s;
    flex-shrink: 0;
  }
  .tab:hover { color: var(--text2); }
  .tab.active { color: var(--accent); background: linear-gradient(180deg, var(--glow2) 0%, transparent 100%); }
  .tab.active::after {
    content: '';
    position: absolute;
    bottom: 0; left: 0; right: 0;
    height: 2px;
    background: var(--accent);
    box-shadow: 0 0 8px var(--accent);
  }
  .tab-num { font-size: 9px; color: var(--text3); margin-right: 5px; font-family: 'Share Tech Mono', monospace; }

  .content { flex: 1; overflow: hidden; display: flex; position: relative; }
  .tab-panel { display: none; width: 100%; height: 100%; overflow: hidden; }
  .tab-panel.active { display: flex; }

  #tab-overview { flex-direction: column; overflow: hidden; }

  .panel {
    border-right: 1px solid var(--border);
    border-bottom: 1px solid var(--border);
    background: var(--panel);
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  .panel-header {
    padding: 6px 12px;
    background: var(--bg3);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 8px;
    flex-shrink: 0;
  }
  .panel-title { font-family: 'Orbitron', sans-serif; font-size: 9px; letter-spacing: 2px; color: var(--accent); text-transform: uppercase; }
  .panel-badge { font-family: 'Share Tech Mono', monospace; font-size: 9px; padding: 1px 6px; border: 1px solid var(--border2); color: var(--text3); margin-left: auto; }
  .panel-body { flex: 1; overflow: auto; padding: 8px; scrollbar-width: thin; scrollbar-color: var(--border2) transparent; }

  .instr-input {
    flex: 1;
    background: var(--bg);
    border: 1px solid var(--border2);
    color: var(--accent);
    font-family: 'Share Tech Mono', monospace;
    font-size: 13px;
    padding: 5px 10px;
    outline: none;
    letter-spacing: 1px;
  }
  .instr-input:focus { border-color: var(--accent); box-shadow: 0 0 8px var(--glow); }

  .preset-btn {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    padding: 2px 8px;
    border: 1px solid var(--border);
    background: var(--bg3);
    color: var(--text2);
    cursor: pointer;
    transition: all 0.15s;
  }
  .preset-btn:hover { border-color: var(--green); color: var(--green); background: rgba(0,255,136,0.05); }

  .reg-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 3px; min-height: 0; }
  .reg-item {
    background: var(--bg2);
    border: 1px solid var(--border);
    padding: 4px 6px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: all 0.3s;
  }
  .reg-item.written {
    border-color: var(--green);
    background: rgba(0,255,136,0.08);
    animation: regFlash 0.5s ease;
  }
  @keyframes regFlash { 0% { background: rgba(0,255,136,0.4); } 100% { background: rgba(0,255,136,0.08); } }
  .reg-name { font-family: 'Share Tech Mono', monospace; font-size: 10px; color: var(--accent2); }
  .reg-val { font-family: 'Share Tech Mono', monospace; font-size: 10px; color: var(--green); }

  .pipeline-container { padding: 12px; display: flex; flex-direction: column; gap: 8px; overflow: auto; height: 100%; }
  .pipeline-stages { display: flex; gap: 4px; align-items: stretch; min-height: 70px; }
  .stage {
    flex: 1;
    border: 1px solid var(--border);
    background: var(--bg2);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 8px 4px;
    position: relative;
    transition: all 0.3s;
    min-width: 55px;
  }
  .stage.occupied { border-color: var(--accent); background: var(--glow2); box-shadow: 0 0 15px var(--glow); }
  .stage.stall { border-color: var(--red); background: rgba(255,51,85,0.08); animation: stall-pulse 0.5s infinite; }
  @keyframes stall-pulse { 0%,100% { box-shadow: 0 0 5px rgba(255,51,85,0.3); } 50% { box-shadow: 0 0 20px rgba(255,51,85,0.6); } }
  .stage.done { border-color: var(--green); background: rgba(0,255,136,0.05); }
  .stage-name { font-family: 'Orbitron', sans-serif; font-size: 8px; letter-spacing: 1px; color: var(--text3); text-transform: uppercase; }
  .stage.occupied .stage-name { color: var(--accent); }
  .stage-instr { font-family: 'Share Tech Mono', monospace; font-size: 10px; color: var(--yellow); margin-top: 4px; text-align: center; }
  .stage-arrow { width: 16px; display: flex; align-items: center; justify-content: center; color: var(--border2); font-size: 18px; flex-shrink: 0; }

  .bus-visual { height: 4px; background: var(--border); border-radius: 2px; position: relative; overflow: hidden; margin: 4px 0; }
  .bus-packet { position: absolute; height: 100%; width: 30px; background: linear-gradient(90deg, transparent, var(--accent), transparent); animation: busFlow 1.5s linear infinite; border-radius: 2px; }
  @keyframes busFlow { from { left: -30px; } to { left: 100%; } }
  .bus-label { font-size: 9px; color: var(--text3); letter-spacing: 1px; text-transform: uppercase; margin-bottom: 2px; display: flex; justify-content: space-between; }

  .log-list { display: flex; flex-direction: column; gap: 2px; }
  .log-entry {
    display: flex;
    gap: 8px;
    align-items: flex-start;
    padding: 4px 6px;
    border-left: 2px solid var(--border);
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    background: var(--bg2);
    animation: slideIn 0.3s ease;
  }
  @keyframes slideIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }
  .log-entry.fetch { border-color: var(--accent2); }
  .log-entry.decode { border-color: var(--purple); }
  .log-entry.execute { border-color: var(--yellow); }
  .log-entry.memory { border-color: var(--orange); }
  .log-entry.writeback { border-color: var(--green); }
  .log-entry.hazard { border-color: var(--red); }
  .log-tick { color: var(--text3); flex-shrink: 0; width: 30px; }
  .log-stage { flex-shrink: 0; width: 55px; }
  .log-stage.fetch { color: var(--accent2); }
  .log-stage.decode { color: var(--purple); }
  .log-stage.execute { color: var(--yellow); }
  .log-stage.memory { color: var(--orange); }
  .log-stage.writeback { color: var(--green); }
  .log-stage.hazard { color: var(--red); }
  .log-msg { color: var(--text); flex: 1; }

  #tab-fetch { display: none; overflow: hidden; }
  #tab-fetch.active { display: flex; }
  .fetch-layout { display: grid; grid-template-columns: 280px 1fr 240px; height: 100%; }

  .memory-table { width: 100%; border-collapse: collapse; font-family: 'Share Tech Mono', monospace; font-size: 10px; }
  .memory-table th { padding: 4px 6px; text-align: left; font-size: 9px; color: var(--text3); letter-spacing: 1px; text-transform: uppercase; border-bottom: 1px solid var(--border); background: var(--bg3); position: sticky; top: 0; }
  .memory-table td { padding: 3px 6px; border-bottom: 1px solid rgba(26,40,64,0.5); color: var(--text2); }
  .memory-table tr.pc-row td { background: rgba(0,136,255,0.12); color: var(--accent); border-left: 2px solid var(--accent); }
  .memory-table .addr { color: var(--text3); }
  .memory-table .hex { color: var(--purple); }
  .memory-table .mnem { color: var(--green); }
  .memory-table .operand { color: var(--orange); }
  .memory-table tr:hover td { background: var(--glow2); }

  .decode-visual { padding: 12px; display: flex; flex-direction: column; gap: 12px; overflow: auto; }
  .instr-bits { display: flex; flex-direction: column; gap: 4px; }
  .bits-row { display: flex; gap: 1px; flex-wrap: nowrap; }
  .bit-group { display: flex; flex-direction: column; flex: 0 0 auto; }
  .bit-cells { display: flex; }
  .bit-cell { width: 18px; height: 22px; border: 1px solid var(--border); background: var(--bg2); display: flex; align-items: center; justify-content: center; font-family: 'Share Tech Mono', monospace; font-size: 10px; color: var(--text2); border-radius: 1px; flex-shrink: 0; }
  .bit-cell.one { color: var(--accent); background: rgba(0,212,255,0.1); }
  .bit-group-label { font-size: 8px; color: var(--text3); text-align: center; padding-top: 2px; font-family: 'Share Tech Mono', monospace; letter-spacing: 0.5px; }
  .bit-group.opcode .bit-cell { border-color: var(--purple); }
  .bit-group.opcode .bit-cell.one { color: var(--purple); background: rgba(170,68,255,0.15); }
  .bit-group.opcode .bit-group-label { color: var(--purple); }
  .bit-group.rd .bit-cell { border-color: var(--green); }
  .bit-group.rd .bit-cell.one { color: var(--green); background: rgba(0,255,136,0.1); }
  .bit-group.rd .bit-group-label { color: var(--green); }
  .bit-group.funct3 .bit-cell { border-color: var(--yellow); }
  .bit-group.funct3 .bit-group-label { color: var(--yellow); }
  .bit-group.rs1 .bit-cell { border-color: var(--orange); }
  .bit-group.rs1 .bit-group-label { color: var(--orange); }
  .bit-group.rs2 .bit-cell { border-color: var(--accent2); }
  .bit-group.rs2 .bit-group-label { color: var(--accent2); }
  .bit-group.funct7 .bit-cell { border-color: var(--red); }
  .bit-group.funct7 .bit-group-label { color: var(--red); }

  .decode-fields { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
  .decode-field { background: var(--bg2); border: 1px solid var(--border); padding: 8px 10px; position: relative; }
  .decode-field .df-label { font-size: 9px; color: var(--text3); letter-spacing: 1px; text-transform: uppercase; margin-bottom: 3px; }
  .decode-field .df-val { font-family: 'Share Tech Mono', monospace; font-size: 13px; color: var(--accent); }
  .decode-field .df-sub { font-family: 'Share Tech Mono', monospace; font-size: 9px; color: var(--text3); margin-top: 2px; }
  .decode-field.highlight-purple { border-color: var(--purple); }
  .decode-field.highlight-purple .df-val { color: var(--purple); }
  .decode-field.highlight-green { border-color: var(--green); }
  .decode-field.highlight-green .df-val { color: var(--green); }
  .decode-field.highlight-orange { border-color: var(--orange); }
  .decode-field.highlight-orange .df-val { color: var(--orange); }
  .decode-field.highlight-yellow { border-color: var(--yellow); }
  .decode-field.highlight-yellow .df-val { color: var(--yellow); }

  .ctrl-signals { display: flex; flex-wrap: wrap; gap: 4px; }
  .ctrl-sig { padding: 3px 8px; border: 1px solid var(--border); font-family: 'Share Tech Mono', monospace; font-size: 9px; background: var(--bg3); color: var(--text3); transition: all 0.3s; }
  .ctrl-sig.on { border-color: var(--green); color: var(--green); background: rgba(0,255,136,0.08); box-shadow: 0 0 6px rgba(0,255,136,0.2); }

  #tab-alu { display: none; overflow: hidden; }
  #tab-alu.active { display: flex; }
  .alu-layout { display: grid; grid-template-columns: 1fr 320px; height: 100%; }
  .alu-diagram-wrap { display: flex; align-items: center; justify-content: center; padding: 16px; overflow: hidden; }

  .forward-table { width: 100%; border-collapse: collapse; font-family: 'Share Tech Mono', monospace; font-size: 10px; }
  .forward-table th, .forward-table td { padding: 5px 8px; border: 1px solid var(--border); text-align: left; }
  .forward-table th { background: var(--bg3); color: var(--text3); font-size: 9px; letter-spacing: 1px; }
  .forward-table td { color: var(--text2); background: var(--bg2); }
  .forward-table tr.active-forward td { background: rgba(0,212,255,0.08); color: var(--accent); border-color: var(--accent2); }

  #tab-memory { display: none; overflow: hidden; }
  #tab-memory.active { display: flex; }
  .mem-layout { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; height: 100%; }

  .cache-visual { display: flex; flex-direction: column; gap: 3px; overflow: auto; }
  .cache-set { display: flex; gap: 2px; align-items: center; }
  .cache-set-label { font-family: 'Share Tech Mono', monospace; font-size: 9px; color: var(--text3); width: 35px; flex-shrink: 0; text-align: right; padding-right: 6px; }
  .cache-line { flex: 1; border: 1px solid var(--border); background: var(--bg2); padding: 3px 6px; display: flex; gap: 8px; align-items: center; font-family: 'Share Tech Mono', monospace; font-size: 9px; transition: all 0.3s; min-width: 0; }
  .cache-line.valid { border-color: var(--border2); }
  .cache-line.hit { border-color: var(--green); background: rgba(0,255,136,0.1); animation: cacheHit 0.5s ease; }
  @keyframes cacheHit { 0% { background: rgba(0,255,136,0.5); } 100% { background: rgba(0,255,136,0.1); } }
  .cache-line.miss { border-color: var(--red); background: rgba(255,51,85,0.08); animation: cacheMiss 0.5s ease; }
  @keyframes cacheMiss { 0% { background: rgba(255,51,85,0.4); } 100% { background: rgba(255,51,85,0.08); } }
  .cl-v { width: 8px; height: 8px; border: 1px solid; border-radius: 50%; flex-shrink: 0; }
  .cl-v.valid { background: var(--green); border-color: var(--green); box-shadow: 0 0 4px var(--green); }
  .cl-v.invalid { background: transparent; border-color: var(--text3); }
  .cl-d { color: var(--text3); width: 8px; flex-shrink: 0; }
  .cl-d.dirty { color: var(--orange); }
  .cl-tag { color: var(--accent2); min-width: 40px; }
  .cl-data { color: var(--text2); font-size: 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; }
  .cl-lru { color: var(--text3); font-size: 8px; margin-left: auto; }

  .stat-bar { margin-bottom: 8px; }
  .stat-bar-label { display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 3px; }
  .stat-bar-label .name { color: var(--text2); }
  .stat-bar-label .val { font-family: 'Share Tech Mono', monospace; color: var(--green); }
  .stat-bar-track { height: 6px; background: var(--bg3); border: 1px solid var(--border); border-radius: 3px; overflow: hidden; }
  .stat-bar-fill { height: 100%; background: linear-gradient(90deg, var(--accent2), var(--accent)); border-radius: 3px; transition: width 0.5s ease; }

  #tab-timing { display: none; overflow: hidden; }
  #tab-timing.active { display: flex; flex-direction: column; }
  .timing-diagram { flex: 1; overflow: auto; padding: 12px; }
  .timing-header { display: flex; gap: 0; position: sticky; top: 0; background: var(--bg2); z-index: 10; border-bottom: 1px solid var(--border); margin-bottom: 4px; }
  .timing-instr-col { width: 140px; flex-shrink: 0; padding: 4px 8px; font-size: 9px; color: var(--text3); letter-spacing: 1px; text-transform: uppercase; }
  .timing-cycle-header { display: flex; }
  .timing-cycle-cell { width: 42px; height: 24px; flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-family: 'Share Tech Mono', monospace; font-size: 9px; color: var(--text3); border-right: 1px solid var(--border); }
  .timing-cycle-cell.current { color: var(--accent); background: var(--glow2); }
  .timing-row { display: flex; gap: 0; margin-bottom: 2px; }
  .timing-row-label { width: 140px; flex-shrink: 0; padding: 3px 8px; font-family: 'Share Tech Mono', monospace; font-size: 10px; color: var(--yellow); border-right: 1px solid var(--border); background: var(--bg2); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .timing-cells { display: flex; }
  .timing-cell { width: 42px; height: 22px; flex-shrink: 0; border-right: 1px solid rgba(26,40,64,0.5); display: flex; align-items: center; justify-content: center; font-family: 'Share Tech Mono', monospace; font-size: 8px; letter-spacing: 0.5px; background: var(--bg); color: transparent; transition: all 0.3s; }
  .timing-cell.IF { background: rgba(0,136,255,0.2); color: var(--accent2); border: 1px solid rgba(0,136,255,0.3); }
  .timing-cell.ID { background: rgba(170,68,255,0.2); color: var(--purple); border: 1px solid rgba(170,68,255,0.3); }
  .timing-cell.EX { background: rgba(255,221,0,0.15); color: var(--yellow); border: 1px solid rgba(255,221,0,0.3); }
  .timing-cell.MEM { background: rgba(255,136,0,0.15); color: var(--orange); border: 1px solid rgba(255,136,0,0.3); }
  .timing-cell.WB { background: rgba(0,255,136,0.15); color: var(--green); border: 1px solid rgba(0,255,136,0.3); }
  .timing-cell.STALL { background: rgba(255,51,85,0.15); color: var(--red); border: 1px solid rgba(255,51,85,0.3); }

  #tab-branch { display: none; overflow: hidden; }
  #tab-branch.active { display: flex; }
  .branch-layout { display: grid; grid-template-columns: 1fr 1fr; height: 100%; }

  .btb-table { width: 100%; border-collapse: collapse; font-family: 'Share Tech Mono', monospace; font-size: 9px; }
  .btb-table th { padding: 4px 6px; border: 1px solid var(--border); background: var(--bg3); color: var(--text3); font-size: 8px; letter-spacing: 1px; text-transform: uppercase; }
  .btb-table td { padding: 3px 6px; border: 1px solid rgba(26,40,64,0.5); color: var(--text2); background: var(--bg2); }
  .btb-table tr.predict-taken td { background: rgba(0,255,136,0.06); }
  .btb-table tr.predict-taken td:last-child { color: var(--green); }
  .btb-table tr.predict-not td:last-child { color: var(--red); }

  .fsm-visual { display: flex; flex-direction: column; align-items: center; gap: 16px; padding: 20px; }
  .fsm-states { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; position: relative; }
  .fsm-state { width: 90px; height: 55px; border: 2px solid var(--border2); background: var(--bg2); display: flex; flex-direction: column; align-items: center; justify-content: center; font-family: 'Share Tech Mono', monospace; font-size: 10px; cursor: pointer; transition: all 0.3s; }
  .fsm-state.current { border-color: var(--accent); background: var(--glow2); box-shadow: 0 0 20px var(--glow); }
  .fsm-state.sn { border-color: var(--red); }
  .fsm-state.sn.current { background: rgba(255,51,85,0.12); box-shadow: 0 0 20px rgba(255,51,85,0.3); }
  .fsm-state.wn { border-color: var(--orange); }
  .fsm-state.wn.current { background: rgba(255,136,0,0.12); box-shadow: 0 0 20px rgba(255,136,0,0.3); }
  .fsm-state.wt { border-color: var(--yellow); }
  .fsm-state.wt.current { background: rgba(255,221,0,0.1); }
  .fsm-state.st { border-color: var(--green); }
  .fsm-state.st.current { background: rgba(0,255,136,0.08); box-shadow: 0 0 20px rgba(0,255,136,0.3); }
  .fsm-state-label { font-size: 9px; color: var(--text3); letter-spacing: 0.5px; margin-top: 2px; }
  .fsm-predict { font-size: 8px; font-weight: bold; }
  .fsm-predict.taken { color: var(--green); }
  .fsm-predict.not-taken { color: var(--red); }

  #tab-ooo { display: none; overflow: hidden; }
  #tab-ooo.active { display: flex; }
  .ooo-layout { display: grid; grid-template-columns: 1fr 1fr 1fr; height: 100%; }

  .rob-table { width: 100%; border-collapse: collapse; font-family: 'Share Tech Mono', monospace; font-size: 9px; }
  .rob-table th { padding: 4px 6px; border: 1px solid var(--border); background: var(--bg3); color: var(--text3); font-size: 8px; letter-spacing: 1px; text-transform: uppercase; }
  .rob-table td { padding: 4px 6px; border: 1px solid rgba(26,40,64,0.5); background: var(--bg2); }
  .rob-table tr.head-row { background: rgba(0,136,255,0.08); }
  .rob-table tr.tail-row { background: rgba(255,136,0,0.08); }
  .rob-table tr.ready-row td { background: rgba(0,255,136,0.06); }
  .rob-state-ready { color: var(--green); }
  .rob-state-exec { color: var(--yellow); }
  .rob-state-issue { color: var(--accent2); }

  .rs-entry { border: 1px solid var(--border); background: var(--bg2); padding: 6px 8px; margin-bottom: 3px; display: flex; flex-direction: column; gap: 2px; font-family: 'Share Tech Mono', monospace; font-size: 9px; transition: all 0.3s; }
  .rs-entry.ready-to-issue { border-color: var(--green); background: rgba(0,255,136,0.05); animation: rsReady 1s ease infinite alternate; }
  @keyframes rsReady { from { box-shadow: none; } to { box-shadow: 0 0 8px rgba(0,255,136,0.3); } }
  .rs-row { display: flex; gap: 8px; align-items: center; }
  .rs-field { display: flex; gap: 4px; align-items: center; }
  .rs-label { color: var(--text3); font-size: 8px; }
  .rs-val { color: var(--accent); }
  .rs-val.ready { color: var(--green); }
  .rs-val.waiting { color: var(--red); }

  .status-bar { display: flex; gap: 0; background: var(--bg2); border-top: 1px solid var(--border); padding: 0; flex-shrink: 0; overflow: hidden; }
  .status-item { padding: 4px 12px; border-right: 1px solid var(--border); display: flex; align-items: center; gap: 6px; font-size: 10px; }
  .status-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--green); box-shadow: 0 0 6px var(--green); animation: blink 1.5s infinite; }
  .status-dot.red { background: var(--red); box-shadow: 0 0 6px var(--red); }
  .status-dot.yellow { background: var(--yellow); box-shadow: 0 0 6px var(--yellow); }
  @keyframes blink { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
  .status-label { color: var(--text3); text-transform: uppercase; letter-spacing: 1px; font-size: 9px; }
  .status-val { font-family: 'Share Tech Mono', monospace; color: var(--text); font-size: 10px; }
  .status-val.green { color: var(--green); }
  .status-val.red { color: var(--red); }
  .status-val.yellow { color: var(--yellow); }

  ::-webkit-scrollbar { width: 4px; height: 4px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 2px; }

  .section-title { font-family: 'Orbitron', sans-serif; font-size: 9px; color: var(--accent); letter-spacing: 2px; text-transform: uppercase; padding: 6px 0 4px; border-bottom: 1px solid var(--border); margin-bottom: 8px; }
  .mono { font-family: 'Share Tech Mono', monospace; }
  .c-accent { color: var(--accent); }
  .c-green { color: var(--green); }
  .c-orange { color: var(--orange); }
  .c-yellow { color: var(--yellow); }
  .c-red { color: var(--red); }
  .c-purple { color: var(--purple); }
  .c-text2 { color: var(--text2); }
  .c-text3 { color: var(--text3); }

  .speed-control { display: flex; align-items: center; gap: 6px; font-size: 11px; color: var(--text2); }
  .speed-control input { accent-color: var(--accent); width: 80px; cursor: pointer; }

  .hazard-indicator { display: flex; gap: 4px; flex-wrap: wrap; }
  .hazard-badge { font-family: 'Share Tech Mono', monospace; font-size: 9px; padding: 2px 6px; border: 1px solid; opacity: 0.4; transition: all 0.3s; }
  .hazard-badge.active { opacity: 1; animation: hazardPulse 0.5s ease 3; }
  @keyframes hazardPulse { 0%,100% { transform: scale(1); } 50% { transform: scale(1.05); } }
  .hazard-badge.raw { border-color: var(--red); color: var(--red); }
  .hazard-badge.war { border-color: var(--orange); color: var(--orange); }
  .hazard-badge.waw { border-color: var(--yellow); color: var(--yellow); }
  .hazard-badge.structural { border-color: var(--purple); color: var(--purple); }
  .hazard-badge.control { border-color: var(--accent2); color: var(--accent2); }

  .pc-label { font-size: 10px; color: var(--text3); letter-spacing: 1px; text-transform: uppercase; }
  .pc-addr { font-family: 'Share Tech Mono', monospace; font-size: 14px; color: var(--yellow); text-shadow: 0 0 8px rgba(255,221,0,0.5); }
  .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }

  .run-light { width: 8px; height: 8px; border-radius: 50%; background: var(--green); box-shadow: 0 0 8px var(--green); flex-shrink: 0; }
  .run-light.paused { background: var(--orange); box-shadow: 0 0 8px var(--orange); animation: none; }
  .run-light.running { animation: runPulse 0.5s infinite; }
  @keyframes runPulse { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }

  .fwd-path { display: flex; align-items: center; gap: 6px; padding: 4px 8px; border: 1px solid var(--border); background: var(--bg2); font-family: 'Share Tech Mono', monospace; font-size: 10px; margin-bottom: 3px; transition: all 0.3s; }
  .fwd-path.active { border-color: var(--accent); background: var(--glow2); animation: fwdFlash 0.3s ease; }
  @keyframes fwdFlash { 0% { background: rgba(0,212,255,0.4); } 100% { background: var(--glow2); } }
  .fwd-arrow { color: var(--accent2); }

  .span-2-rows { grid-row: span 2; }

  /* Sort overlay */
  #sortOverlay { position: absolute; inset: 0; z-index: 50; display: none; flex-direction: column; pointer-events: none; }
  #sortOverlay.active { display: flex; }
  .sort-bar-panel { background: rgba(5,8,16,0.97); border-bottom: 2px solid var(--accent); padding: 10px 16px 8px; flex-shrink: 0; pointer-events: all; box-shadow: 0 4px 30px rgba(0,212,255,0.12); }
  .sort-bar-header { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
  .sort-bar-title { font-family: 'Orbitron', sans-serif; font-size: 10px; letter-spacing: 2px; color: var(--accent); text-transform: uppercase; }
  .sort-bar-meta { font-family: 'Share Tech Mono', monospace; font-size: 10px; color: var(--text3); }
  .sort-bar-meta span { color: var(--yellow); }
  .sort-bar-close { margin-left: auto; font-size: 10px; padding: 3px 10px; border: 1px solid var(--border2); background: var(--bg3); color: var(--text2); cursor: pointer; font-family: 'Rajdhani', sans-serif; font-weight: 600; letter-spacing: 1px; pointer-events: all; }
  .sort-bar-close:hover { border-color: var(--red); color: var(--red); }
  .sort-bar-el { width: 100%; border-radius: 2px 2px 0 0; transition: height 0.35s cubic-bezier(0.34, 1.56, 0.64, 1), background 0.3s, box-shadow 0.3s; }
  .sort-bar-el.comparing { background: var(--yellow) !important; box-shadow: 0 0 12px rgba(255,221,0,0.6); }
  .sort-bar-el.swapping { background: var(--red) !important; box-shadow: 0 0 16px rgba(255,51,85,0.7); animation: swapPulse 0.4s ease; }
  .sort-bar-el.sorted { background: var(--green) !important; box-shadow: 0 0 8px rgba(0,255,136,0.4); }
  @keyframes swapPulse { 0% { transform: scaleY(1.15); } 50% { transform: scaleY(0.9); } 100% { transform: scaleY(1); } }

  .narrative-panel { flex: 1; display: flex; flex-direction: column; min-height: 0; pointer-events: all; background: rgba(5,8,22,0.96); border-top: 1px solid var(--border); }
  .narrative-current { border-bottom: 1px solid var(--border); padding: 10px 16px; flex-shrink: 0; background: var(--bg3); }
  .narrative-algo { font-size: 13px; font-weight: 600; color: var(--text); line-height: 1.5; margin-bottom: 4px; }
  .narrative-algo .highlight-green { color: var(--green); font-family: 'Share Tech Mono', monospace; }
  .narrative-algo .highlight-yellow { color: var(--yellow); font-family: 'Share Tech Mono', monospace; }
  .narrative-algo .highlight-red { color: var(--red); font-family: 'Share Tech Mono', monospace; }
  .narrative-algo .highlight-accent { color: var(--accent); font-family: 'Share Tech Mono', monospace; }
  .narrative-algo .highlight-orange { color: var(--orange); font-family: 'Share Tech Mono', monospace; }
  .narrative-detail { font-size: 11px; color: var(--text2); line-height: 1.6; }
  .narrative-tags { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 5px; }
  .narrative-tag { font-family: 'Share Tech Mono', monospace; font-size: 9px; padding: 2px 7px; border: 1px solid; border-radius: 1px; }
  .narrative-tag.stall { border-color: var(--red); color: var(--red); background: rgba(255,51,85,0.08); }
  .narrative-tag.fwd { border-color: var(--accent); color: var(--accent); background: rgba(0,212,255,0.08); }
  .narrative-tag.swap { border-color: var(--orange); color: var(--orange); background: rgba(255,136,0,0.08); }
  .narrative-tag.nswap { border-color: var(--green); color: var(--green); background: rgba(0,255,136,0.06); }
  .narrative-tag.branch { border-color: var(--yellow); color: var(--yellow); background: rgba(255,221,0,0.06); }
  .narrative-tag.load { border-color: var(--purple); color: var(--purple); background: rgba(170,68,255,0.08); }
  .narrative-tag.store { border-color: var(--orange); color: var(--orange); background: rgba(255,136,0,0.08); }
  .narrative-tag.alu { border-color: var(--text3); color: var(--text3); }

  .narrative-history { flex: 1; overflow-y: auto; padding: 6px 16px; display: flex; flex-direction: column; gap: 2px; scrollbar-width: thin; scrollbar-color: var(--border2) transparent; }
  .narrative-hist-entry { display: flex; gap: 10px; align-items: flex-start; padding: 5px 8px; background: var(--bg2); border-left: 3px solid var(--border); font-size: 11px; animation: narrativeIn 0.25s ease; }
  @keyframes narrativeIn { from { opacity: 0; transform: translateY(-4px); } to { opacity: 1; transform: translateY(0); } }
  .narrative-hist-entry.type-stall { border-color: var(--red); }
  .narrative-hist-entry.type-swap { border-color: var(--orange); }
  .narrative-hist-entry.type-compare { border-color: var(--yellow); }
  .narrative-hist-entry.type-fwd { border-color: var(--accent); }
  .narrative-hist-entry.type-branch { border-color: var(--green); }
  .narrative-hist-entry.type-load { border-color: var(--purple); }
  .narrative-hist-entry.type-info { border-color: var(--text3); }
  .nh-cycle { font-family: 'Share Tech Mono', monospace; font-size: 9px; color: var(--text3); flex-shrink: 0; width: 34px; padding-top: 1px; }
  .nh-text { color: var(--text2); line-height: 1.55; flex: 1; }
  .nh-text b { color: var(--text); font-weight: 600; }

  .help-overlay { position: absolute; inset: 0; background: rgba(5,8,16,0.92); z-index: 100; display: none; align-items: center; justify-content: center; backdrop-filter: blur(4px); }
  .help-overlay.show { display: flex; }
  .help-box { background: var(--bg3); border: 1px solid var(--accent); box-shadow: 0 0 40px var(--glow); padding: 24px; max-width: 500px; width: 90%; }
  .help-box h2 { font-family: 'Orbitron', sans-serif; font-size: 14px; letter-spacing: 3px; color: var(--accent); margin-bottom: 16px; text-transform: uppercase; }
  .help-row { display: flex; gap: 12px; margin-bottom: 8px; font-size: 12px; }
  .help-key { font-family: 'Share Tech Mono', monospace; color: var(--yellow); min-width: 80px; flex-shrink: 0; }
  .help-desc { color: var(--text2); }

  /* Glossary */
  #tab-glossary { flex-direction: column; overflow: hidden; }


  /* ============================================================
     VERBOSE PIPELINE REGISTER CARDS
     ============================================================ */
  .pr-card {
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
    transition: background 0.3s;
  }
  .pr-card.active { background: rgba(0,136,255,0.04); }
  .pr-card.stalled { background: rgba(255,51,85,0.05); }
  .pr-card.bubble { background: rgba(255,51,85,0.03); }

  .pr-card-header {
    display: flex;
    align-items: center;
    gap: 7px;
    padding: 5px 10px;
    background: var(--bg3);
    border-bottom: 1px solid var(--border);
    cursor: default;
  }
  .pr-reg-badge {
    font-family: 'Orbitron', sans-serif;
    font-size: 8px;
    letter-spacing: 1px;
    padding: 2px 6px;
    border: 1px solid;
    flex-shrink: 0;
  }
  .pr-badge-if  { border-color: var(--accent2); color: var(--accent2); }
  .pr-badge-id  { border-color: var(--purple);  color: var(--purple); }
  .pr-badge-ex  { border-color: var(--yellow);  color: var(--yellow); }
  .pr-badge-mem { border-color: var(--orange);  color: var(--orange); }

  .pr-reg-name {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    color: var(--accent);
    flex: 1;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .pr-stage-label {
    font-size: 9px;
    color: var(--text3);
    flex-shrink: 0;
    font-family: 'Share Tech Mono', monospace;
  }

  .pr-card-body {
    padding: 6px 10px 8px;
    display: flex;
    flex-direction: column;
    gap: 3px;
  }

  .pr-empty-msg {
    font-size: 10px;
    color: var(--text3);
    font-style: italic;
  }

  .pr-what {
    font-size: 11.5px;
    color: var(--text);
    line-height: 1.55;
    font-family: 'Rajdhani', sans-serif;
    font-weight: 500;
  }
  .pr-what .pr-instr { color: var(--yellow); font-family: 'Share Tech Mono', monospace; font-size: 11px; }
  .pr-what .pr-reg   { color: var(--green);  font-family: 'Share Tech Mono', monospace; font-size: 10px; }
  .pr-what .pr-val   { color: var(--accent); font-family: 'Share Tech Mono', monospace; font-size: 10px; }
  .pr-what .pr-addr  { color: var(--orange); font-family: 'Share Tech Mono', monospace; font-size: 10px; }
  .pr-what .pr-stall { color: var(--red);    font-weight: 600; }
  .pr-what .pr-fwd   { color: var(--accent); font-weight: 600; }
  .pr-what .pr-ok    { color: var(--green);  font-weight: 600; }

  .pr-detail {
    font-size: 10px;
    color: var(--text2);
    line-height: 1.5;
    margin-top: 2px;
  }

  .pr-tags {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
    margin-top: 3px;
  }
  .pr-tag {
    font-family: 'Share Tech Mono', monospace;
    font-size: 8px;
    padding: 1px 5px;
    border: 1px solid;
    border-radius: 1px;
  }
  .pr-tag-ok   { border-color: var(--green);  color: var(--green); }
  .pr-tag-warn { border-color: var(--red);    color: var(--red); }
  .pr-tag-fwd  { border-color: var(--accent); color: var(--accent); }
  .pr-tag-info { border-color: var(--text3);  color: var(--text3); }
  .pr-tag-mem  { border-color: var(--orange); color: var(--orange); }

  /* ============================================================
     VERBOSE EXECUTION LOG ENTRIES
     ============================================================ */
  .xlog-entry {
    border-left: 3px solid var(--border2);
    background: var(--bg2);
    padding: 6px 10px 7px;
    display: flex;
    flex-direction: column;
    gap: 2px;
    animation: xlogIn 0.25s ease;
    flex-shrink: 0;
  }
  @keyframes xlogIn { from { opacity:0; transform:translateY(-4px); } to { opacity:1; transform:translateY(0); } }

  .xlog-entry.xl-fetch   { border-color: var(--accent2); }
  .xlog-entry.xl-decode  { border-color: var(--purple); }
  .xlog-entry.xl-execute { border-color: var(--yellow); }
  .xlog-entry.xl-memory  { border-color: var(--orange); }
  .xlog-entry.xl-wb      { border-color: var(--green); }
  .xlog-entry.xl-stall   { border-color: var(--red); background: rgba(255,51,85,0.04); }
  .xlog-entry.xl-fwd     { border-color: var(--accent); background: rgba(0,212,255,0.03); }
  .xlog-entry.xl-branch  { border-color: var(--yellow); }
  .xlog-entry.xl-prog    { border-color: var(--text3); }

  .xlog-meta {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .xlog-cycle {
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    color: var(--text3);
    flex-shrink: 0;
    min-width: 28px;
  }
  .xlog-stage-pill {
    font-family: 'Share Tech Mono', monospace;
    font-size: 8px;
    padding: 1px 6px;
    border: 1px solid;
    flex-shrink: 0;
  }
  .xlog-stage-pill.xl-fetch   { border-color: var(--accent2); color: var(--accent2); }
  .xlog-stage-pill.xl-decode  { border-color: var(--purple);  color: var(--purple); }
  .xlog-stage-pill.xl-execute { border-color: var(--yellow);  color: var(--yellow); }
  .xlog-stage-pill.xl-memory  { border-color: var(--orange);  color: var(--orange); }
  .xlog-stage-pill.xl-wb      { border-color: var(--green);   color: var(--green); }
  .xlog-stage-pill.xl-stall   { border-color: var(--red);     color: var(--red); }
  .xlog-stage-pill.xl-fwd     { border-color: var(--accent);  color: var(--accent); }
  .xlog-stage-pill.xl-branch  { border-color: var(--yellow);  color: var(--yellow); }
  .xlog-stage-pill.xl-prog    { border-color: var(--text3);   color: var(--text3); }

  .xlog-instr {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    color: var(--yellow);
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .xlog-headline {
    font-size: 11.5px;
    color: var(--text);
    line-height: 1.5;
    font-family: 'Rajdhani', sans-serif;
    font-weight: 500;
  }
  .xlog-headline b { color: var(--text); font-weight: 700; }
  .xlog-headline .xl-r { color: var(--green);  font-family: 'Share Tech Mono', monospace; font-size: 10px; }
  .xlog-headline .xl-v { color: var(--accent); font-family: 'Share Tech Mono', monospace; font-size: 10px; }
  .xlog-headline .xl-a { color: var(--orange); font-family: 'Share Tech Mono', monospace; font-size: 10px; }
  .xlog-headline .xl-w { color: var(--red);    font-weight: 700; }
  .xlog-headline .xl-g { color: var(--green);  font-weight: 700; }
  .xlog-detail {
    font-size: 10px;
    color: var(--text2);
    line-height: 1.5;
  }

  /* ============================================================
     TOOLTIP SYSTEM
     ============================================================ */
  [data-tip] {
    cursor: help;
    border-bottom: 1px dashed rgba(0,212,255,0.3);
    transition: border-color 0.15s, color 0.15s;
  }
  [data-tip]:hover { border-color: var(--accent); }

  .tip-box {
    display: none;
    position: fixed;
    z-index: 9999;
    max-width: 310px;
    min-width: 190px;
    background: #04090f;
    border: 1px solid var(--accent);
    box-shadow: 0 0 30px rgba(0,212,255,0.18), 0 6px 28px rgba(0,0,0,0.9);
    padding: 10px 13px 12px;
    pointer-events: none;
  }
  .tip-box.show { display: block; animation: tipIn 0.1s ease; }
  @keyframes tipIn { from { opacity:0; transform:translateY(3px); } to { opacity:1; transform:translateY(0); } }
  .tip-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    letter-spacing: 2px;
    color: var(--accent);
    text-transform: uppercase;
    margin-bottom: 6px;
    padding-bottom: 5px;
    border-bottom: 1px solid var(--border);
  }
  .tip-body {
    font-family: 'Rajdhani', sans-serif;
    font-size: 12.5px;
    color: var(--text2);
    line-height: 1.55;
  }
  .tip-body b { color: var(--text); font-weight: 600; }
  .tip-body code {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    color: var(--yellow);
    background: rgba(255,221,0,0.07);
    padding: 1px 4px;
  }
  .tip-eg {
    display: block;
    margin-top: 6px;
    padding-top: 5px;
    border-top: 1px solid var(--border);
    font-size: 10px;
    color: var(--text3);
    font-family: 'Share Tech Mono', monospace;
  }
  .tip-eg span { color: var(--green); }
</style>
</head>
<body>

<!-- GLOBAL TOOLTIP CARD -->
<div class="tip-box" id="tipBox"><div class="tip-title" id="tipTitle"></div><div class="tip-body" id="tipBody"></div></div>

<header>
  <div class="logo">
    CPUVIS <span>RISC-V RV32I · 5-STAGE PIPELINE · OoO SIMULATION</span>
  </div>
  <div class="global-controls">
    <div id="runLight" class="run-light paused"></div>
    <button class="btn green" id="btnStep" onclick="step()">STEP ▶</button>
    <button class="btn" id="btnRun" onclick="toggleRun()">AUTO RUN</button>
    <button class="btn orange" id="btnReset" onclick="resetSim()">RESET</button>
    <div class="speed-control">
      <span>SPD</span>
      <input type="range" id="speedSlider" min="100" max="2000" value="800" oninput="updateSpeed(this.value)">
    </div>
    <button class="btn" style="border-color:var(--purple);color:var(--purple);" onclick="showPrograms()">PROGRAMS</button>
    <button class="btn" id="btnSortView" onclick="toggleSortOverlay()" style="display:none; border-color:var(--yellow); color:var(--yellow);">SORT VIEW ▤</button>
    <button class="btn" onclick="showHelp()">?</button>
  </div>
  <div class="clock-display">
    <div class="clock-item" data-tip="cycles|Clock Cycles|One <b>cycle</b> = one tick of the CPU clock (here: 3.2 GHz). Each pipeline stage consumes one cycle. More cycles = more time elapsed.<div class='tip-eg'>@ 3.2 GHz: 1 cycle ≈ 0.3 ns</div>"><div class="val" id="cycleCount">0</div><div class="lbl">Cycles</div></div>
    <div class="clock-item" data-tip="instrs|Instructions Committed|Instructions that completed the full pipeline (reached <b>WB</b> stage). Does NOT count instructions still in-flight, NOP bubbles, or squashed speculative work.<div class='tip-eg'>Efficiency = Instrs ÷ Cycles × 100%</div>"><div class="val" id="instrCount">0</div><div class="lbl">Instrs</div></div>
    <div class="clock-item" data-tip="cpi|CPI — Cycles Per Instruction|Average clock cycles per completed instruction. <b>Ideal = 1.0</b>. Every stall cycle and branch misprediction penalty pushes this above 1. Lower is better.<div class='tip-eg'>CPI = Total Cycles ÷ Instructions</div>"><div class="val" id="cpiDisplay">—</div><div class="lbl">CPI</div></div>
    <div class="clock-item" data-tip="ipc|IPC — Instructions Per Cycle|The inverse of CPI. How many instructions retire per cycle. <b>Max = 1.0</b> for in-order pipelines (superscalar CPUs can exceed 1). Higher is better.<div class='tip-eg'>IPC = 1 ÷ CPI = Instrs ÷ Cycles</div>"><div class="val" id="ipcDisplay">—</div><div class="lbl">IPC</div></div>
    <div class="clock-item" data-tip="stalls|Pipeline Stalls|Cycles where the pipeline is frozen to resolve a <b>hazard</b>. The stalled instruction stays in its stage doing nothing — wasted time. Load-use hazards cause exactly 1 stall each.<div class='tip-eg'>Each stall adds +1 to CPI</div>"><div class="val" id="stallCount">0</div><div class="lbl">Stalls</div></div>
    <div class="clock-item" data-tip="misses|Cache Misses|Times data or an instruction wasn't in the fast L1 cache. The CPU stalls while fetching from slower memory: <b>L2 = +10 cycles</b>, DRAM = +200 cycles.<div class='tip-eg'>Miss rate = Misses ÷ Total Accesses</div>"><div class="val" id="missCount">0</div><div class="lbl">Misses</div></div>
  </div>
</header>

<div class="tabs">
  <div class="tab active" onclick="switchTab('overview')"><span class="tab-num">01</span>PIPELINE OVERVIEW</div>
  <div class="tab" onclick="switchTab('fetch')"><span class="tab-num">02</span>FETCH / DECODE</div>
  <div class="tab" onclick="switchTab('alu')"><span class="tab-num">03</span>ALU / EXECUTE</div>
  <div class="tab" onclick="switchTab('memory')"><span class="tab-num">04</span>MEMORY HIERARCHY</div>
  <div class="tab" onclick="switchTab('timing')"><span class="tab-num">05</span>TIMING DIAGRAM</div>
  <div class="tab" onclick="switchTab('branch')"><span class="tab-num">06</span>BRANCH PREDICTOR</div>
  <div class="tab" onclick="switchTab('ooo')"><span class="tab-num">07</span>OUT-OF-ORDER / ROB</div>
  <div class="tab" onclick="switchTab('glossary')" style="border-left:2px solid var(--border2);color:var(--yellow);"><span class="tab-num" style="color:var(--text3);">08</span>GLOSSARY</div>
</div>

<div class="content">

  <!-- TAB 1: PIPELINE OVERVIEW -->
  <div class="tab-panel active" id="tab-overview">
    <div style="display:flex; flex-direction:column; height:100%; overflow:hidden;">
      <div style="display:flex; gap:0; border-bottom:1px solid var(--border); flex-shrink:0; background:var(--bg2);">
        <div style="padding:7px 12px; display:flex; align-items:center; gap:8px; flex:1;">
          <div style="font-size:10px; color:var(--text3); letter-spacing:1px; text-transform:uppercase; white-space:nowrap; flex-shrink:0;">MANUAL INSTR:</div>
          <input class="instr-input" id="instrInputMain" style="flex:1;" placeholder="e.g.  ADD R1,R2,R3  or  LW R4,0(R8)  or  BEQ R1,R2,8" onkeydown="if(event.key==='Enter')addInstruction()">
          <button class="btn green" style="white-space:nowrap;" onclick="addInstruction()">QUEUE ▶</button>
        </div>
        <div style="display:flex; align-items:center; gap:3px; padding:7px 10px; border-left:1px solid var(--border); flex-shrink:0;">
          <span style="font-size:10px; color:var(--text3); letter-spacing:1px; text-transform:uppercase; margin-right:4px;">QUICK:</span>
          <button class="preset-btn" data-tip="add|ADD Rd, Rs1, Rs2|Rd = Rs1 + Rs2. Integer addition. R-type instruction — 3 registers, no immediate. The most basic ALU operation; zero stalls if operands are ready." onclick="queuePreset('ADD R1,R2,R3')">ADD</button>
          <button class="preset-btn" data-tip="sub|SUB Rd, Rs1, Rs2|Rd = Rs1 − Rs2. Integer subtraction. Same encoding slot as ADD but with funct7=0100000 to signal the ALU to subtract." onclick="queuePreset('SUB R4,R1,R2')">SUB</button>
          <button class="preset-btn" data-tip="mul|MUL Rd, Rs1, Rs2|Rd = Rs1 × Rs2 (lower 32 bits). RV32M extension. Uses the multiply unit which may take more cycles on real hardware; here simulated as 1 cycle." onclick="queuePreset('MUL R5,R3,R4')">MUL</button>
          <button class="preset-btn" data-tip="lw|LW Rd, offset(Rs1)|Load Word — reads 4 bytes from memory address Rs1+offset into Rd. The loaded value is only available after the MEM stage, causing a <b>load-use stall</b> if used immediately." onclick="queuePreset('LW R6,0(R1)')">LW</button>
          <button class="preset-btn" data-tip="sw|SW Rs2, offset(Rs1)|Store Word — writes Rs2 to memory address Rs1+offset. Does NOT write a register (no rd). The value must be in Rs2 by the time SW reaches MEM." onclick="queuePreset('SW R6,4(R2)')">SW</button>
          <button class="preset-btn" data-tip="and|AND Rd, Rs1, Rs2|Rd = Rs1 AND Rs2. Bitwise AND — each bit of the result is 1 only if both input bits are 1. Useful for masking (clearing specific bits)." onclick="queuePreset('AND R7,R1,R2')">AND</button>
          <button class="preset-btn" data-tip="or|OR Rd, Rs1, Rs2|Rd = Rs1 OR Rs2. Bitwise OR — each bit is 1 if at least one input bit is 1. Useful for setting specific bits." onclick="queuePreset('OR R8,R3,R5')">OR</button>
          <button class="preset-btn" data-tip="xor|XOR Rd, Rs1, Rs2|Rd = Rs1 XOR Rs2. Bitwise exclusive-OR — bit is 1 if inputs differ. Used in encryption, checksums, and toggling bits." onclick="queuePreset('XOR R9,R1,R7')">XOR</button>
          <button class="preset-btn" data-tip="beq|BEQ Rs1, Rs2, offset|Branch if Equal — if Rs1 == Rs2, jump to PC+offset. Branch condition resolved in EX. A misprediction flushes 2 pipeline stages." onclick="queuePreset('BEQ R1,R2,8')">BEQ</button>
          <button class="preset-btn" data-tip="bne|BNE Rs1, Rs2, offset|Branch if Not Equal — if Rs1 ≠ Rs2, jump to PC+offset. Same pipeline behavior as BEQ but inverts the condition." onclick="queuePreset('BNE R3,R4,12')">BNE</button>
          <button class="preset-btn" data-tip="addi|ADDI Rd, Rs1, imm|Rd = Rs1 + sign_extend(imm). Add Immediate — adds a 12-bit constant directly embedded in the instruction. I-type format. No second source register." onclick="queuePreset('ADDI R1,R2,5')">ADDI</button>
          <button class="preset-btn" data-tip="sll|SLL Rd, Rs1, Rs2|Shift Left Logical — shifts Rs1 left by Rs2 bits, filling with zeros. Equivalent to multiplying by 2^Rs2. Used for fast powers-of-two multiply." onclick="queuePreset('SLL R2,R1,3')">SLL</button>
        </div>
      </div>

      <div style="flex:1; display:grid; grid-template-columns:200px 1fr 220px; grid-template-rows:1fr 1fr; overflow:hidden;">
        <div class="panel span-2-rows" style="grid-row:span 2;">
          <div class="panel-header">
            <div class="panel-title" data-tip="regfile|Register File|32 general-purpose 32-bit registers (R0–R31). R0 is hardwired to 0 — writing to it is ignored. All arithmetic operates on these; values are loaded from memory (LW) and stored back (SW).">REGISTER FILE</div>
            <div class="panel-badge">32×32-bit</div>
          </div>
          <div class="panel-body">
            <div class="reg-grid" id="registerGrid"></div>
          </div>
        </div>

        <div class="panel" style="border-right:none;">
          <div class="panel-header">
            <div class="panel-title">PIPELINE STAGES</div>
            <div class="panel-badge">5-STAGE IN-ORDER</div>
            <div class="hazard-indicator" id="hazardIndicator" style="margin-left:8px;">
              <div class="hazard-badge raw" data-tip="raw|RAW — Read After Write|An instruction tries to READ a register before a previous instruction has finished WRITing it. The most common hazard. Solved by <b>forwarding</b> (usually) or a <b>1-cycle stall</b> for load-use cases.">RAW</div>
              <div class="hazard-badge war" data-tip="war|WAR — Write After Read|An instruction tries to WRITE a register before an earlier instruction has READ it. Rare in in-order pipelines; mainly matters for <b>out-of-order</b> execution.">WAR</div>
              <div class="hazard-badge waw" data-tip="waw|WAW — Write After Write|Two instructions both write the same register. The second write must happen after the first or the wrong value survives. In-order pipelines naturally handle this.">WAW</div>
              <div class="hazard-badge structural" data-tip="structural|Structural Hazard|Two instructions need the <b>same hardware resource</b> at the same time (e.g. one memory port but both a load and an instruction fetch). Requires stalling one of them.">STRUCT</div>
              <div class="hazard-badge control" data-tip="ctrl|Control Hazard|Caused by <b>branch instructions</b>. The pipeline doesn't know which instruction comes next until the branch is resolved in EX. Wrong guesses (mispredictions) waste 2–3 cycles.">CTRL</div>
            </div>
          </div>
          <div class="pipeline-container" style="flex-direction:row; align-items:center; justify-content:flex-start; padding:8px 6px; gap:0; overflow-x:auto; overflow-y:hidden; flex-wrap:nowrap;">
            <div class="stage" id="stageIF" data-tip="if|IF — Instruction Fetch|The CPU reads the next instruction from memory (or L1 I-cache) using the <b>Program Counter (PC)</b> as the address. Takes 1 cycle if it hits the cache. On a load-use stall, IF stays frozen — the same instruction waits here for one extra cycle.">
              <div class="stage-name">IF</div>
              <div style="font-size:8px; color:var(--text3); margin-top:2px;">FETCH</div>
              <div class="stage-instr" id="stageIF-instr">—</div>
            </div>
            <div class="stage-arrow">›</div>
            <div class="stage" id="stageID" data-tip="id|ID — Instruction Decode|The fetched bits are decoded: What operation is this? Which registers does it read/write? The <b>hazard detection unit</b> checks here whether a stall is needed. A NOP bubble in this slot means a stall was inserted.">
              <div class="stage-name">ID</div>
              <div style="font-size:8px; color:var(--text3); margin-top:2px;">DECODE</div>
              <div class="stage-instr" id="stageID-instr">—</div>
            </div>
            <div class="stage-arrow">›</div>
            <div class="stage" id="stageEX" data-tip="ex|EX — Execute|The <b>ALU</b> does the computation: arithmetic, logic, address calculation for loads/stores, or branch condition evaluation. Forwarding paths deliver register values directly here, bypassing the register file.">
              <div class="stage-name">EX</div>
              <div style="font-size:8px; color:var(--text3); margin-top:2px;">EXECUTE</div>
              <div class="stage-instr" id="stageEX-instr">—</div>
            </div>
            <div class="stage-arrow">›</div>
            <div class="stage" id="stageMEM" data-tip="mem|MEM — Memory Access|Only <b>LW/SW</b> instructions actually use this stage. Loads read a value from the D-cache; stores write one. ALU instructions pass through unchanged. Load results become available here — too late for the immediately following instruction (hence load-use stalls).">
              <div class="stage-name">MEM</div>
              <div style="font-size:8px; color:var(--text3); margin-top:2px;">MEMORY</div>
              <div class="stage-instr" id="stageMEM-instr">—</div>
            </div>
            <div class="stage-arrow">›</div>
            <div class="stage" id="stageWB" data-tip="wb|WB — Write Back|The final stage. Results are written back into the <b>register file</b> so future instructions can use them. Once an instruction reaches WB it is considered <b>committed</b> — counted in the Instrs counter.">
              <div class="stage-name">WB</div>
              <div style="font-size:8px; color:var(--text3); margin-top:2px;">WRITEBACK</div>
              <div class="stage-instr" id="stageWB-instr">—</div>
            </div>
          </div>
          <div style="padding:0 12px 8px;">
            <div class="bus-label"><span data-tip="ibus|Instruction Bus (32-bit)|Carries the raw 32-bit encoded instruction word from I-cache → IF/ID pipeline register. The encoding contains opcode, register numbers, and immediate values packed into specific bit fields.">INSTRUCTION BUS (32-bit)</span><span id="instrBusVal" class="mono c-accent">—</span></div>
            <div class="bus-visual"><div class="bus-packet"></div></div>
            <div class="bus-label" style="margin-top:4px;"><span data-tip="dbus|Data Bus (32-bit)|Carries values between the ALU, data cache, and registers. Shows the current ALU result or load/store data. 32 bits wide — matches the RISC-V RV32I register width.">DATA BUS (32-bit)</span><span id="dataBusVal" class="mono c-green">—</span></div>
            <div class="bus-visual"><div class="bus-packet" style="background:linear-gradient(90deg,transparent,var(--green),transparent);"></div></div>
            <div class="bus-label" style="margin-top:4px;"><span data-tip="cbus|Control Bus|Carries control signals that tell each stage what to do: RegWrite, MemRead, Branch, ALUSrc, etc. These are derived during decode and travel with the instruction through the pipeline registers.">CONTROL BUS</span><span id="ctrlBusVal" class="mono c-purple">—</span></div>
            <div class="bus-visual"><div class="bus-packet" style="background:linear-gradient(90deg,transparent,var(--purple),transparent); animation-delay:0.7s;"></div></div>
          </div>
        </div>

        <div class="panel" style="border-right:none;">
          <div class="panel-header">
            <div class="panel-title" data-tip="iqueue|Instruction Queue|Instructions waiting to be fetched into the pipeline. Acts like a FIFO buffer. In a real CPU this corresponds to the L1 instruction cache and fetch buffer. Programs are loaded here before running.">INSTR QUEUE</div>
            <div class="panel-badge" id="queueBadge">0/16</div>
          </div>
          <div class="panel-body" id="instrQueueDisplay" style="overflow:auto; display:flex; flex-direction:column; gap:2px;"></div>
        </div>

        <div class="panel" style="overflow:hidden;">
          <div class="panel-header">
            <div class="panel-title" data-tip="pc|Program Counter (PC)|A special register that always holds the address of the next instruction to fetch. Increments by 4 each cycle. Frozen during load-use stalls.">PC / PIPELINE REGISTERS</div>
            <div id="pcDisplay" style="font-family:'Share Tech Mono',monospace; font-size:13px; color:var(--yellow); text-shadow:0 0 8px rgba(255,221,0,0.5); margin-left:auto;">0x00000000</div>
          </div>
          <div class="panel-body" style="padding:0; overflow-y:auto; display:flex; flex-direction:column; gap:0;">
            <div class="pr-card" id="prCard-IFID">
              <div class="pr-card-header">
                <div class="pr-reg-badge pr-badge-if">IF/ID</div>
                <div class="pr-reg-name" id="prIF_ID_val">EMPTY</div>
                <div class="pr-stage-label">Fetch → Decode</div>
              </div>
              <div class="pr-card-body" id="prCard-IFID-body">
                <div class="pr-empty-msg">No instruction in the pipeline yet. Click STEP or AUTO RUN to begin.</div>
              </div>
            </div>
            <div class="pr-card" id="prCard-IDEX">
              <div class="pr-card-header">
                <div class="pr-reg-badge pr-badge-id">ID/EX</div>
                <div class="pr-reg-name" id="prID_EX_val">EMPTY</div>
                <div class="pr-stage-label">Decode → Execute</div>
              </div>
              <div class="pr-card-body" id="prCard-IDEX-body">
                <div class="pr-empty-msg">Waiting for an instruction to decode.</div>
              </div>
            </div>
            <div class="pr-card" id="prCard-EXMEM">
              <div class="pr-card-header">
                <div class="pr-reg-badge pr-badge-ex">EX/MEM</div>
                <div class="pr-reg-name" id="prEX_MEM_val">EMPTY</div>
                <div class="pr-stage-label">Execute → Memory</div>
              </div>
              <div class="pr-card-body" id="prCard-EXMEM-body">
                <div class="pr-empty-msg">Waiting for an instruction to execute.</div>
              </div>
            </div>
            <div class="pr-card" id="prCard-MEMWB">
              <div class="pr-card-header">
                <div class="pr-reg-badge pr-badge-mem">MEM/WB</div>
                <div class="pr-reg-name" id="prMEM_WB_val">EMPTY</div>
                <div class="pr-stage-label">Memory → Writeback</div>
              </div>
              <div class="pr-card-body" id="prCard-MEMWB-body">
                <div class="pr-empty-msg">Waiting for a memory stage result.</div>
              </div>
            </div>
            <div style="padding:6px 10px; border-top:1px solid var(--border); flex-shrink:0; background:var(--bg3);">
              <div style="font-size:9px; color:var(--text3); margin-bottom:2px; letter-spacing:1px;">NEXT INSTRUCTION AT</div>
              <div id="pcPlusDisplay" style="font-family:'Share Tech Mono',monospace; font-size:11px; color:var(--text2);">PC+4: 0x00000004</div>
            </div>
          </div>
        </div>

        <div class="panel" style="border-bottom:none; display:flex; flex-direction:column; overflow:hidden;">
          <!-- EXECUTION LOG -->
          <div style="display:flex; flex-direction:column; flex:1; min-height:0; border-bottom:1px solid var(--border);">
            <div class="panel-header">
              <div class="panel-title">EXECUTION LOG</div>
              <div id="logVerboseBadge" style="font-family:'Share Tech Mono',monospace; font-size:9px; padding:1px 6px; border:1px solid var(--border2); color:var(--text3); margin-left:6px;">PLAIN ENGLISH</div>
              <button class="btn" style="font-size:9px; padding:2px 8px; margin-left:auto;" onclick="clearLog()">CLR</button>
            </div>
            <div class="panel-body" id="execLog" style="overflow-y:auto; display:flex; flex-direction:column; gap:4px; padding:6px 8px; flex:1; min-height:0;"></div>
          </div>
          <!-- PERFORMANCE -->
          <div style="display:flex; flex-direction:column; flex-shrink:0; max-height:260px; overflow-y:auto;">
            <div class="panel-header"><div class="panel-title">PERFORMANCE</div></div>
            <div class="panel-body">
              <div class="section-title">HAZARD STATS</div>
              <div class="stat-bar">
                <div class="stat-bar-label"><span class="name c-red" data-tip="raw-stat|RAW Hazard Count|Total Read-After-Write hazards detected. Each one is a case where an instruction needed a value before the previous instruction finished computing it. Includes both forwarded cases and stall cases.">RAW Hazards</span><span class="val" id="rawStat">0</span></div>
                <div class="stat-bar-track"><div class="stat-bar-fill" id="rawBar" style="width:0%;background:linear-gradient(90deg,var(--red),#ff6677);"></div></div>
              </div>
              <div class="stat-bar">
                <div class="stat-bar-label"><span class="name c-orange" data-tip="stall-stat|Stall Cycles|Number of cycles the pipeline was frozen. Each stall = +1 CPI. Load-use hazards always cost exactly 1 stall. Branch mispredictions cost 2–3. Structural hazards are rare.">Stall Cycles</span><span class="val" id="stallStat">0</span></div>
                <div class="stat-bar-track"><div class="stat-bar-fill" id="stallBar" style="width:0%;background:linear-gradient(90deg,var(--orange),#ffaa44);"></div></div>
              </div>
              <div class="stat-bar">
                <div class="stat-bar-label"><span class="name c-yellow" data-tip="mispred-stat|Branch Mispredictions|Times the branch predictor guessed wrong. Each misprediction flushes 2–3 instructions and costs 2–3 wasted cycles.">Branch Mispredict</span><span class="val" id="branchMispredStat">0</span></div>
                <div class="stat-bar-track"><div class="stat-bar-fill" id="branchBar" style="width:0%;background:linear-gradient(90deg,var(--yellow),#ffee66);"></div></div>
              </div>
              <div class="stat-bar">
                <div class="stat-bar-label"><span class="name c-accent" data-tip="fwd-stat|Forwarding Paths Used|Times the forwarding unit routed a value directly from EX/MEM or MEM/WB back to EX, avoiding a stall.">Fwd Paths Used</span><span class="val" id="fwdStat">0</span></div>
                <div class="stat-bar-track"><div class="stat-bar-fill" id="fwdBar" style="width:0%;"></div></div>
              </div>
              <div class="section-title" style="margin-top:6px;">THROUGHPUT</div>
              <div class="stat-bar">
                <div class="stat-bar-label"><span class="name" data-tip="eff-stat|Pipeline Efficiency|Percentage of cycles doing useful work: Instrs ÷ Cycles × 100%. 100% is ideal. Stalls and bubbles reduce this.">Pipeline Efficiency</span><span class="val c-green" id="effStat">0%</span></div>
                <div class="stat-bar-track"><div class="stat-bar-fill" id="effBar" style="width:0%;"></div></div>
              </div>
              <div class="stat-bar">
                <div class="stat-bar-label"><span class="name" data-tip="fwdrate-stat|Forwarding Rate|Percentage of instructions that received their input via the forwarding unit instead of waiting.">Forwarding Rate</span><span class="val c-accent" id="fwdRateStat">0%</span></div>
                <div class="stat-bar-track"><div class="stat-bar-fill" id="fwdRateBar" style="width:0%;"></div></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- TAB 2: FETCH / DECODE -->
  <div class="tab-panel" id="tab-fetch">
    <div class="fetch-layout" style="width:100%;">
      <div class="panel" style="border-bottom:none;">
        <div class="panel-header"><div class="panel-title" data-tip="imem|Instruction Memory|Shows all instructions loaded into the simulated CPU, with their addresses, hex encoding, mnemonic, and operands. The highlighted row is the current PC — the next instruction to be fetched.">INSTRUCTION MEMORY</div><div class="panel-badge">RV32I</div></div>
        <div class="panel-body">
          <div style="padding:6px 8px; border-bottom:1px solid var(--border); display:flex; align-items:center; gap:8px;">
            <div class="pc-label">PC →</div>
            <div class="pc-addr" id="fetchPC">0x00000000</div>
          </div>
          <table class="memory-table" id="memoryTable">
            <thead><tr><th>ADDR</th><th>HEX</th><th>MNEM</th><th>OPERANDS</th></tr></thead>
            <tbody id="memoryTableBody"></tbody>
          </table>
        </div>
      </div>
      <div class="panel" style="border-bottom:none;">
        <div class="panel-header"><div class="panel-title" data-tip="idecode|Instruction Decode Unit|Breaks the 32-bit instruction word into its fields: <b>opcode</b>, register numbers, function codes, and immediate values. Shows the active control signals generated for the current instruction in the ID stage.">INSTRUCTION DECODE</div><div class="panel-badge" id="decodeBadge">NO INSTR</div></div>
        <div class="decode-visual">
          <div id="instrEnglishBox" style="background:linear-gradient(135deg,rgba(0,212,255,0.05),rgba(0,0,0,0)); border:1px solid var(--accent2); border-radius:3px; padding:8px 10px; margin-bottom:8px; display:none;">
            <div style="font-size:8px; color:var(--accent2); letter-spacing:1px; text-transform:uppercase; margin-bottom:3px;">WHAT THIS INSTRUCTION DOES</div>
            <div id="instrEnglishText" style="font-size:11px; color:var(--text1); line-height:1.5;"></div>
          </div>
          <div class="section-title">32-BIT INSTRUCTION WORD</div>
          <div class="instr-bits">
            <div class="bits-row" id="bitsRow"></div>
          </div>
          <div class="section-title" style="margin-top:4px;">DECODED FIELDS</div>
          <div class="decode-fields">
            <div class="decode-field highlight-purple"><div class="df-label">OPCODE [6:0]</div><div class="df-val" id="df-opcode">—</div><div class="df-sub" id="df-opcode-type">—</div></div>
            <div class="decode-field highlight-green"><div class="df-label">RD [11:7]</div><div class="df-val" id="df-rd">—</div><div class="df-sub" id="df-rd-name">—</div></div>
            <div class="decode-field highlight-yellow"><div class="df-label">FUNCT3 [14:12]</div><div class="df-val" id="df-funct3">—</div><div class="df-sub" id="df-funct3-op">—</div></div>
            <div class="decode-field highlight-orange"><div class="df-label">RS1 [19:15]</div><div class="df-val" id="df-rs1">—</div><div class="df-sub" id="df-rs1-val">—</div></div>
            <div class="decode-field" style="border-color:var(--accent2);"><div class="df-label">RS2 [24:20]</div><div class="df-val" style="color:var(--accent2);" id="df-rs2">—</div><div class="df-sub" id="df-rs2-val">—</div></div>
            <div class="decode-field" style="border-color:var(--red);"><div class="df-label">FUNCT7 / IMM [31:25]</div><div class="df-val" style="color:var(--red);" id="df-funct7">—</div><div class="df-sub" id="df-funct7-sub">—</div></div>
          </div>
          <div class="section-title">CONTROL SIGNALS</div>
          <div class="ctrl-signals" id="ctrlSignals">
            <div class="ctrl-sig" id="cs-regwrite" data-tip="regwrite|RegWrite|When ON: the result of this instruction will be written to the destination register (rd) in the WB stage. OFF for stores (SW) and branches — they don't write a register.">RegWrite</div>
            <div class="ctrl-sig" id="cs-memread" data-tip="memread|MemRead|When ON: the MEM stage reads a value from data memory at the computed address. Only active for <b>load instructions</b> (LW, LH, LB). This flag is what triggers load-use hazard detection.">MemRead</div>
            <div class="ctrl-sig" id="cs-memwrite" data-tip="memwrite|MemWrite|When ON: the MEM stage writes a value to data memory. Only active for <b>store instructions</b> (SW, SH, SB). The value stored comes from rs2.">MemWrite</div>
            <div class="ctrl-sig" id="cs-branch" data-tip="branch|Branch Control Signal|When ON: this instruction is a conditional branch (BEQ, BNE, BLT, etc.). The ALU evaluates the condition in EX; if taken, the PC is redirected and 2 in-flight instructions are flushed.">Branch</div>
            <div class="ctrl-sig" id="cs-jump" data-tip="jump|Jump Control Signal|When ON: this is an unconditional jump (JAL, JALR). Always redirects the PC. Saves the return address (PC+4) in the destination register rd.">Jump</div>
            <div class="ctrl-sig" id="cs-alusrc" data-tip="alusrc|ALUSrc — ALU Source Mux|Selects what the <b>second operand</b> to the ALU is: OFF = register rs2; ON = sign-extended immediate. R-type uses a register; I-type, loads, stores use an immediate.">ALUSrc</div>
            <div class="ctrl-sig" id="cs-memtoreg" data-tip="memtoreg|MemToReg — Result Source Mux|Selects what gets written to rd in WB: OFF = ALU result; ON = value loaded from memory. Only ON for load instructions.">MemToReg</div>
            <div class="ctrl-sig" id="cs-aluzero" data-tip="aluzero|ALUZero Flag|The ALU's zero-detection flag. Goes ON when the ALU result equals zero. Branches use this to decide whether to take the jump: BEQ takes if zero is 1, BNE takes if zero is 0.">ALUZero</div>
            <div class="ctrl-sig" id="cs-unsigned" data-tip="unsigned|Unsigned Comparison|When ON: comparisons (SLT, BLT, BGE) treat register values as <b>unsigned integers</b> (0 to 4,294,967,295 range) instead of signed (-2^31 to 2^31-1). Affects SLTU and BLTU instructions.">Unsigned</div>
          </div>
          <div class="section-title">IMMEDIATE GENERATION</div>
          <div style="background:var(--bg2); border:1px solid var(--border); padding:8px; font-family:'Share Tech Mono',monospace; font-size:11px;">
            <div style="display:flex; justify-content:space-between; margin-bottom:4px;"><span style="color:var(--text3);">IMM TYPE:</span><span id="immType" class="c-yellow">—</span></div>
            <div style="display:flex; justify-content:space-between; margin-bottom:4px;"><span style="color:var(--text3);">IMM VALUE:</span><span id="immVal" class="c-accent">—</span></div>
            <div style="display:flex; justify-content:space-between;"><span style="color:var(--text3);">SIGN EXTEND:</span><span id="immSext" class="c-green">—</span></div>
          </div>
        </div>
      </div>
      <div class="panel" style="border-right:none; border-bottom:none;">
        <div class="panel-header"><div class="panel-title" data-tip="hazdetect|Hazard Detection Unit|Continuously monitors adjacent pipeline stages for data dependencies. If it detects a load-use hazard (LW in ID, dependent instruction in IF), it inserts a stall bubble and freezes IF and PC for one cycle.">HAZARD DETECTION</div></div>
        <div class="panel-body">
          <div class="section-title" data-tip="fwdpaths|Forwarding (Bypassing)|Instead of waiting for WB to write the register file, the forwarding unit detects when an in-flight instruction has the value a later instruction needs, and routes it directly. <b>EX/MEM→EX</b> is the fastest path (1-cycle lag); <b>MEM/WB→EX</b> handles 2-cycle lags.">FORWARDING PATHS</div>
          <div id="fwdPaths">
            <div class="fwd-path" id="fwd-EX_MEM"><span class="c-text3">EX/MEM</span><span class="fwd-arrow">→</span><span class="c-text3">EX</span><span style="flex:1;"></span><span id="fwd-EX_MEM-val" class="mono c-text3">—</span></div>
            <div class="fwd-path" id="fwd-MEM_WB"><span class="c-text3">MEM/WB</span><span class="fwd-arrow">→</span><span class="c-text3">EX</span><span style="flex:1;"></span><span id="fwd-MEM_WB-val" class="mono c-text3">—</span></div>
            <div class="fwd-path" id="fwd-WB"><span class="c-text3">WB</span><span class="fwd-arrow">→</span><span class="c-text3">ID</span><span style="flex:1;"></span><span id="fwd-WB-val" class="mono c-text3">—</span></div>
          </div>
          <div id="hazardEnglishBox" style="background:linear-gradient(135deg,rgba(255,51,85,0.04),rgba(0,0,0,0)); border:1px solid rgba(255,51,85,0.15); border-radius:3px; padding:8px 10px; margin-bottom:8px;">
            <div style="font-size:8px; color:var(--text3); letter-spacing:1px; text-transform:uppercase; margin-bottom:3px;">HAZARD STATUS</div>
            <div id="hazardEnglishText" style="font-size:11px; color:var(--text2); line-height:1.5;">Pipeline is flowing normally. No hazards detected this cycle.</div>
          </div>
          <div class="section-title" style="margin-top:10px;">LOAD-USE HAZARD</div>
          <div style="background:var(--bg2); border:1px solid var(--border); padding:8px; font-family:'Share Tech Mono',monospace; font-size:10px;">
            <div style="display:flex; justify-content:space-between; margin-bottom:4px;"><span style="color:var(--text3);">DETECTED:</span><span id="loadUseDetect" class="c-red">NO</span></div>
            <div style="display:flex; justify-content:space-between; margin-bottom:4px;"><span style="color:var(--text3);">STALL CYCLES:</span><span id="loadUseStalls" class="c-orange">0</span></div>
            <div style="display:flex; justify-content:space-between;"><span style="color:var(--text3);">BUBBLE INSERT:</span><span id="loadUseBubble" class="c-text3">—</span></div>
          </div>
          <div class="section-title" style="margin-top:10px;">DATA DEPENDENCY TABLE</div>
          <table class="forward-table" id="depTable">
            <thead><tr><th>INSTR</th><th>READS</th><th>WRITES</th><th>STATUS</th></tr></thead>
            <tbody id="depTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <!-- TAB 3: ALU / EXECUTE -->
  <div class="tab-panel" id="tab-alu">
    <div class="alu-layout" style="width:100%;">
      <div class="panel" style="border-bottom:none;">
        <div class="panel-header"><div class="panel-title">ALU / EXECUTE UNIT</div><div class="panel-badge">32-BIT INTEGER</div></div>
        <div class="alu-diagram-wrap">
          <svg id="aluSvg" viewBox="0 0 480 420" width="100%" style="max-height:100%;">
            <defs>
              <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#0d1525" stroke-width="0.5"/>
              </pattern>
            </defs>
            <rect width="480" height="420" fill="url(#grid)"/>
            <polygon points="30,80 30,130 55,115 55,95" fill="#0a1020" stroke="#243650" stroke-width="1"/>
            <text x="38" y="109" fill="#405070" font-size="7" font-family="Share Tech Mono">MUX</text>
            <polygon points="30,160 30,210 55,195 55,175" fill="#0a1020" stroke="#243650" stroke-width="1"/>
            <text x="38" y="189" fill="#405070" font-size="7" font-family="Share Tech Mono">MUX</text>
            <polygon id="aluBody" points="120,60 120,270 200,240 200,90" fill="#080d18" stroke="#1a2840" stroke-width="1.5"/>
            <text x="140" y="160" fill="#405070" font-size="20" font-family="Orbitron" font-weight="700">ALU</text>
            <text x="143" y="175" fill="#405070" font-size="8" font-family="Share Tech Mono">RV32I</text>
            <line id="wireA" x1="55" y1="105" x2="120" y2="130" stroke="#243650" stroke-width="1.5"/>
            <line id="wireB" x1="55" y1="185" x2="120" y2="200" stroke="#243650" stroke-width="1.5"/>
            <rect x="0" y="55" width="28" height="18" fill="#080d18" stroke="#1a2840"/>
            <text x="4" y="68" fill="#7090b0" font-size="8" font-family="Share Tech Mono" id="rs1Label">RS1</text>
            <line x1="28" y1="64" x2="30" y2="105" stroke="#243650" stroke-width="1"/>
            <rect x="0" y="155" width="28" height="18" fill="#080d18" stroke="#1a2840"/>
            <text x="4" y="168" fill="#7090b0" font-size="8" font-family="Share Tech Mono" id="rs2Label">RS2</text>
            <line x1="28" y1="164" x2="30" y2="185" stroke="#243650" stroke-width="1"/>
            <line id="wireOut" x1="200" y1="165" x2="280" y2="165" stroke="#243650" stroke-width="1.5"/>
            <rect x="280" y="145" width="80" height="40" fill="#080d18" stroke="#243650" stroke-width="1.5" rx="2"/>
            <text x="295" y="161" fill="#405070" font-size="8" font-family="Share Tech Mono">RESULT</text>
            <text x="290" y="178" fill="#405070" font-size="11" font-family="Share Tech Mono" id="aluResultText">0x00000000</text>
            <rect x="370" y="100" width="100" height="90" fill="#080d18" stroke="#1a2840" rx="2"/>
            <text x="390" y="115" fill="#405070" font-size="8" font-family="Orbitron">FLAGS</text>
            <text x="378" y="133" fill="#405070" font-size="8" font-family="Share Tech Mono">ZERO:</text>
            <text x="430" y="133" fill="#405070" font-size="9" font-family="Share Tech Mono" id="flagZero">0</text>
            <text x="378" y="148" fill="#405070" font-size="8" font-family="Share Tech Mono">NEG:</text>
            <text x="430" y="148" fill="#405070" font-size="9" font-family="Share Tech Mono" id="flagNeg">0</text>
            <text x="378" y="163" fill="#405070" font-size="8" font-family="Share Tech Mono">OVFL:</text>
            <text x="430" y="163" fill="#405070" font-size="9" font-family="Share Tech Mono" id="flagOvfl">0</text>
            <text x="378" y="178" fill="#405070" font-size="8" font-family="Share Tech Mono">CARRY:</text>
            <text x="430" y="178" fill="#405070" font-size="9" font-family="Share Tech Mono" id="flagCarry">0</text>
            <rect x="130" y="270" width="80" height="30" fill="#080d18" stroke="#1a2840" rx="2"/>
            <text x="145" y="282" fill="#405070" font-size="8" font-family="Share Tech Mono">ALU OP:</text>
            <text x="145" y="294" fill="#405070" font-size="9" font-family="Share Tech Mono" id="aluOpText">NONE</text>
            <rect x="50" y="290" width="65" height="40" fill="#080d18" stroke="#1a2840" rx="2"/>
            <text x="60" y="305" fill="#405070" font-size="8" font-family="Share Tech Mono">OP A:</text>
            <text x="55" y="322" fill="#405070" font-size="9" font-family="Share Tech Mono" id="opAText">0x00000000</text>
            <rect x="225" y="290" width="65" height="40" fill="#080d18" stroke="#1a2840" rx="2"/>
            <text x="235" y="305" fill="#405070" font-size="8" font-family="Share Tech Mono">OP B:</text>
            <text x="230" y="322" fill="#405070" font-size="9" font-family="Share Tech Mono" id="opBText">0x00000000</text>
            <rect x="60" y="340" width="120" height="30" fill="#080d18" stroke="#1a2840" rx="2"/>
            <text x="75" y="355" fill="#405070" font-size="8" font-family="Share Tech Mono">BRANCH TARGET:</text>
            <text x="80" y="367" fill="#405070" font-size="9" font-family="Share Tech Mono" id="branchTargetText">0x00000000</text>
            <circle id="aluActive" cx="455" cy="60" r="6" fill="#1a2840" stroke="#243650"/>
            <text x="435" y="78" fill="#405070" font-size="7" font-family="Share Tech Mono" id="aluActiveLabel">IDLE</text>
          </svg>
        </div>
      </div>
      <div class="panel" style="border-right:none; border-bottom:none;">
        <div class="panel-header"><div class="panel-title">EXECUTION DETAIL</div></div>
        <div class="panel-body">
          <div class="section-title">CURRENT OPERATION</div>
          <div style="background:var(--bg2); border:1px solid var(--border); padding:10px; margin-bottom:10px;">
            <div style="font-family:'Share Tech Mono',monospace; font-size:14px; color:var(--yellow); text-align:center; margin-bottom:8px;" id="currentExecInstr">—</div>
            <div class="grid-2" style="gap:6px;">
              <div class="decode-field"><div class="df-label">OPERAND A</div><div class="df-val" id="execOpA">—</div></div>
              <div class="decode-field"><div class="df-label">OPERAND B</div><div class="df-val" id="execOpB">—</div></div>
              <div class="decode-field highlight-green"><div class="df-label">RESULT</div><div class="df-val" id="execResult">—</div></div>
              <div class="decode-field" style="border-color:var(--yellow);"><div class="df-label">OPERATION</div><div class="df-val" style="color:var(--yellow);" id="execOp">—</div></div>
            </div>
          </div>
          <div id="aluEnglishBox" style="background:linear-gradient(135deg,rgba(0,255,136,0.04),rgba(0,0,0,0)); border:1px solid rgba(0,255,136,0.2); border-radius:3px; padding:8px 10px; margin-bottom:8px; display:none;">
            <div style="font-size:8px; color:var(--green); letter-spacing:1px; text-transform:uppercase; margin-bottom:3px;">IN PLAIN ENGLISH</div>
            <div id="aluEnglishText" style="font-size:11px; color:var(--text1); line-height:1.5;"></div>
          </div>
          <div class="section-title">ALU OPERATIONS</div>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:3px; margin-bottom:10px;">
            <div class="ctrl-sig" id="alu-add">ADD/ADDI</div>
            <div class="ctrl-sig" id="alu-sub">SUB</div>
            <div class="ctrl-sig" id="alu-and">AND/ANDI</div>
            <div class="ctrl-sig" id="alu-or">OR/ORI</div>
            <div class="ctrl-sig" id="alu-xor">XOR/XORI</div>
            <div class="ctrl-sig" id="alu-sll">SLL</div>
            <div class="ctrl-sig" id="alu-srl">SRL</div>
            <div class="ctrl-sig" id="alu-sra">SRA</div>
            <div class="ctrl-sig" id="alu-slt">SLT</div>
            <div class="ctrl-sig" id="alu-sltu">SLTU</div>
            <div class="ctrl-sig" id="alu-mul">MUL</div>
            <div class="ctrl-sig" id="alu-div">DIV</div>
          </div>
          <div class="section-title">FORWARDING UNIT</div>
          <table class="forward-table">
            <thead><tr><th>PATH</th><th>SRC</th><th>DEST</th><th>ACTIVE</th><th>VALUE</th></tr></thead>
            <tbody id="fwdUnitTable">
              <tr id="fwd-row-EX"><td>EX/MEM→EX</td><td id="fwd-src-ex">—</td><td id="fwd-dst-ex">—</td><td id="fwd-active-ex" class="c-text3">NO</td><td id="fwd-val-ex" class="mono">—</td></tr>
              <tr id="fwd-row-MEM"><td>MEM/WB→EX</td><td id="fwd-src-mem">—</td><td id="fwd-dst-mem">—</td><td id="fwd-active-mem" class="c-text3">NO</td><td id="fwd-val-mem" class="mono">—</td></tr>
              <tr id="fwd-row-WB"><td>WB→ID</td><td id="fwd-src-wb">—</td><td id="fwd-dst-wb">—</td><td id="fwd-active-wb" class="c-text3">NO</td><td id="fwd-val-wb" class="mono">—</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <!-- TAB 4: MEMORY HIERARCHY -->
  <div class="tab-panel" id="tab-memory">
    <div class="mem-layout" style="width:100%;">
      <div class="panel">
        <div class="panel-header"><div class="panel-title" data-tip="icache|L1 Instruction Cache|A small, fast cache holding recently fetched instructions. <b>32KB, 8-way set-associative, 64-byte cache lines</b>. A hit costs 1 cycle; a miss stalls the pipeline and fetches from L2 (10 cycles). Indexed by the low bits of the PC.">L1 I-CACHE</div><div class="panel-badge">32KB · 8-WAY · 64B LINE</div></div>
        <div class="panel-body">
          <div style="display:flex; gap:12px; margin-bottom:8px;">
            <div><div style="font-size:9px; color:var(--text3);">HIT RATE</div><div style="font-family:'Share Tech Mono',monospace; font-size:16px; color:var(--green);" id="icacheHitRate">100%</div></div>
            <div><div style="font-size:9px; color:var(--text3);">HITS</div><div style="font-family:'Share Tech Mono',monospace; font-size:16px; color:var(--accent);" id="icacheHits">0</div></div>
            <div><div style="font-size:9px; color:var(--text3);">MISSES</div><div style="font-family:'Share Tech Mono',monospace; font-size:16px; color:var(--red);" id="icacheMisses">0</div></div>
          </div>
          <div style="display:flex; flex-direction:column; gap:2px;" id="icacheVisual"></div>
        </div>
      </div>
      <div class="panel" style="border-right:none;">
        <div class="panel-header"><div class="panel-title" data-tip="dcache|L1 Data Cache|Holds recently accessed data values. Same structure as I-cache: <b>32KB, 8-way set-associative</b>. LW reads and SW writes go here. Write-back policy: dirty lines are written to memory only when evicted (replaced by a new cache line).">L1 D-CACHE</div><div class="panel-badge">32KB · 8-WAY · 64B LINE</div></div>
        <div class="panel-body">
          <div style="display:flex; gap:12px; margin-bottom:8px;">
            <div><div style="font-size:9px; color:var(--text3);">HIT RATE</div><div style="font-family:'Share Tech Mono',monospace; font-size:16px; color:var(--green);" id="dcacheHitRate">100%</div></div>
            <div><div style="font-size:9px; color:var(--text3);">HITS</div><div style="font-family:'Share Tech Mono',monospace; font-size:16px; color:var(--accent);" id="dcacheHits">0</div></div>
            <div><div style="font-size:9px; color:var(--text3);">MISSES</div><div style="font-family:'Share Tech Mono',monospace; font-size:16px; color:var(--red);" id="dcacheMisses">0</div></div>
            <div><div style="font-size:9px; color:var(--text3);">DIRTY</div><div style="font-family:'Share Tech Mono',monospace; font-size:16px; color:var(--orange);" id="dcacheDirty">0</div></div>
          </div>
          <div style="display:flex; flex-direction:column; gap:2px;" id="dcacheVisual"></div>
        </div>
      </div>
      <div class="panel" style="border-bottom:none;">
        <div class="panel-header"><div class="panel-title" data-tip="l2|L2 Cache + TLB|<b>L2 Cache (256KB unified)</b>: shared instruction+data cache, slower but larger than L1. Catches L1 misses with ~10 cycle latency. <b>TLB</b>: Translation Lookaside Buffer — caches virtual→physical address translations so the MMU doesn't need to walk the page table every access.">L2 CACHE + TLB</div><div class="panel-badge">256KB UNIFIED</div></div>
        <div class="panel-body">
          <div class="section-title">L2 CACHE</div>
          <div style="display:flex; gap:12px; margin-bottom:8px;">
            <div><div style="font-size:9px; color:var(--text3);">HIT RATE</div><div style="font-family:'Share Tech Mono',monospace; font-size:14px; color:var(--green);" id="l2HitRate">100%</div></div>
            <div><div style="font-size:9px; color:var(--text3);">HITS</div><div style="font-family:'Share Tech Mono',monospace; font-size:14px; color:var(--accent);" id="l2Hits">0</div></div>
            <div><div style="font-size:9px; color:var(--text3);">MISSES</div><div style="font-family:'Share Tech Mono',monospace; font-size:14px; color:var(--red);" id="l2Misses">0</div></div>
          </div>
          <div style="height:40px; background:var(--bg2); border:1px solid var(--border); display:flex; align-items:center; justify-content:center; font-family:'Share Tech Mono',monospace; font-size:9px; color:var(--text3); margin-bottom:8px;" id="l2AccessIndicator">IDLE</div>
          <div class="section-title">TLB</div>
          <div style="display:flex; gap:8px; margin-bottom:6px;">
            <div><div style="font-size:9px; color:var(--text3);">ITLB HIT</div><div style="font-family:'Share Tech Mono',monospace; color:var(--green);" id="tlbIHits">0</div></div>
            <div><div style="font-size:9px; color:var(--text3);">DTLB HIT</div><div style="font-family:'Share Tech Mono',monospace; color:var(--green);" id="tlbDHits">0</div></div>
            <div><div style="font-size:9px; color:var(--text3);">MISS</div><div style="font-family:'Share Tech Mono',monospace; color:var(--red);" id="tlbMisses">0</div></div>
          </div>
          <table class="forward-table" style="font-size:9px;">
            <thead><tr><th>VPFN</th><th>PPFN</th><th>V</th><th>D</th><th>PROT</th></tr></thead>
            <tbody id="tlbTableBody"></tbody>
          </table>
        </div>
      </div>
      <div class="panel" style="border-right:none; border-bottom:none;">
        <div class="panel-header"><div class="panel-title">MEMORY HIERARCHY</div></div>
        <div class="panel-body">
          <div id="memEnglishBox" style="background:linear-gradient(135deg,rgba(255,136,0,0.04),rgba(0,0,0,0)); border:1px solid rgba(255,136,0,0.2); border-radius:3px; padding:8px 10px; margin-bottom:8px;">
            <div style="font-size:8px; color:var(--orange); letter-spacing:1px; text-transform:uppercase; margin-bottom:3px;">MEMORY STATUS</div>
            <div id="memEnglishText" style="font-size:11px; color:var(--text2); line-height:1.5;">Waiting for memory accesses. When a LW or SW instruction runs, you will see which cache level it hit and how many cycles it cost.</div>
          </div>
          <div class="section-title">LATENCY COMPARISON</div>
          <div style="display:flex; flex-direction:column; gap:4px; margin-bottom:10px;">
            <div class="stat-bar"><div class="stat-bar-label"><span class="name c-green">L1 Cache (32KB)</span><span class="val">1 cycle</span></div><div class="stat-bar-track"><div class="stat-bar-fill" style="width:8%;"></div></div></div>
            <div class="stat-bar"><div class="stat-bar-label"><span class="name c-accent">L2 Cache (256KB)</span><span class="val">10 cycles</span></div><div class="stat-bar-track"><div class="stat-bar-fill" style="width:30%;"></div></div></div>
            <div class="stat-bar"><div class="stat-bar-label"><span class="name c-yellow">L3 Cache (8MB)</span><span class="val">40 cycles</span></div><div class="stat-bar-track"><div class="stat-bar-fill" style="width:55%;background:linear-gradient(90deg,var(--yellow),#ffee66);"></div></div></div>
            <div class="stat-bar"><div class="stat-bar-label"><span class="name c-orange">DRAM (DDR5)</span><span class="val">200 cycles</span></div><div class="stat-bar-track"><div class="stat-bar-fill" style="width:80%;background:linear-gradient(90deg,var(--orange),#ffaa44);"></div></div></div>
            <div class="stat-bar"><div class="stat-bar-label"><span class="name c-red">SSD (NVMe)</span><span class="val">~100µs</span></div><div class="stat-bar-track"><div class="stat-bar-fill" style="width:100%;background:linear-gradient(90deg,var(--red),#ff6677);"></div></div></div>
          </div>
          <div class="section-title">MEMORY ACCESS LOG</div>
          <div id="memAccessLog" style="display:flex; flex-direction:column; gap:2px; overflow-y:auto; max-height:120px;"></div>
          <div class="section-title" style="margin-top:8px;">DATA MEMORY</div>
          <table class="memory-table" style="font-size:9px;">
            <thead><tr><th>ADDR</th><th>HEX</th><th>DEC</th></tr></thead>
            <tbody id="dataMemBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <!-- TAB 5: TIMING DIAGRAM -->
  <div class="tab-panel" id="tab-timing">
    <div style="padding:8px; border-bottom:1px solid var(--border); background:var(--bg2); display:flex; gap:8px; align-items:center; flex-shrink:0;">
      <div style="font-size:10px; color:var(--text3); letter-spacing:1px; text-transform:uppercase;">PIPELINE TIMING DIAGRAM</div>
      <div style="font-size:10px; color:var(--text2); max-width:500px;">Each row = one instruction. Each column = one clock cycle. Read left to right to see an instruction move through IF→ID→EX→MEM→WB. <span style="color:var(--red);">Red STALL</span> = wasted cycle. A diagonal staircase pattern = ideal pipeline — every stage busy every cycle.</div>
      <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
        <div style="display:flex; gap:4px;">
          <div style="display:flex; align-items:center; gap:3px; font-size:10px; color:var(--accent2);"><div style="width:12px; height:8px; background:rgba(0,136,255,0.3); border:1px solid rgba(0,136,255,0.5);"></div>IF</div>
          <div style="display:flex; align-items:center; gap:3px; font-size:10px; color:var(--purple);"><div style="width:12px; height:8px; background:rgba(170,68,255,0.3); border:1px solid rgba(170,68,255,0.5);"></div>ID</div>
          <div style="display:flex; align-items:center; gap:3px; font-size:10px; color:var(--yellow);"><div style="width:12px; height:8px; background:rgba(255,221,0,0.2); border:1px solid rgba(255,221,0,0.5);"></div>EX</div>
          <div style="display:flex; align-items:center; gap:3px; font-size:10px; color:var(--orange);"><div style="width:12px; height:8px; background:rgba(255,136,0,0.2); border:1px solid rgba(255,136,0,0.5);"></div>MEM</div>
          <div style="display:flex; align-items:center; gap:3px; font-size:10px; color:var(--green);"><div style="width:12px; height:8px; background:rgba(0,255,136,0.2); border:1px solid rgba(0,255,136,0.5);"></div>WB</div>
          <div style="display:flex; align-items:center; gap:3px; font-size:10px; color:var(--red);"><div style="width:12px; height:8px; background:rgba(255,51,85,0.2); border:1px solid rgba(255,51,85,0.5);"></div>STALL</div>
        </div>
        <button class="btn" onclick="clearTiming()">CLEAR</button>
      </div>
    </div>
    <div class="timing-diagram" id="timingDiagram">
      <div class="timing-header">
        <div class="timing-instr-col">INSTRUCTION</div>
        <div class="timing-cycle-header" id="timingCycleHeader"></div>
      </div>
      <div id="timingRows"></div>
    </div>
  </div>

  <!-- TAB 6: BRANCH PREDICTOR -->
  <div class="tab-panel" id="tab-branch">
    <div class="branch-layout" style="width:100%;">
      <div class="panel" style="border-bottom:none;">
        <div class="panel-header"><div class="panel-title" data-tip="btb|Branch Target Buffer (BTB)|A small cache that remembers the <b>target address</b> of recently seen branches. When the CPU fetches a branch instruction, it looks it up here to speculatively fetch the predicted target — before the branch condition is even evaluated.">BRANCH TARGET BUFFER</div><div class="panel-badge">64-ENTRY</div></div>
        <div class="panel-body">
          <div style="display:flex; gap:12px; margin-bottom:8px;">
            <div><div style="font-size:9px; color:var(--text3);">ACCURACY</div><div style="font-family:'Share Tech Mono',monospace; font-size:16px; color:var(--green);" id="btbAccuracy">—</div></div>
            <div><div style="font-size:9px; color:var(--text3);">CORRECT</div><div style="font-family:'Share Tech Mono',monospace; font-size:16px; color:var(--accent);" id="btbCorrect">0</div></div>
            <div><div style="font-size:9px; color:var(--text3);">MISPRED</div><div style="font-family:'Share Tech Mono',monospace; font-size:16px; color:var(--red);" id="btbMispred">0</div></div>
            <div><div style="font-size:9px; color:var(--text3);">PENALTY</div><div style="font-family:'Share Tech Mono',monospace; font-size:16px; color:var(--orange);" id="btbPenalty">0</div></div>
          </div>
          <table class="btb-table">
            <thead><tr><th>IDX</th><th>PC TAG</th><th>TARGET</th><th>STATE</th><th>OUTCOME</th></tr></thead>
            <tbody id="btbTableBody"></tbody>
          </table>
        </div>
      </div>
      <div class="panel" style="border-right:none; border-bottom:none;">
        <div class="panel-header"><div class="panel-title" data-tip="2bit|2-Bit Saturating Counter|A simple branch predictor. 4 states: <b>Strongly Not Taken → Weakly Not Taken → Weakly Taken → Strongly Taken</b>. One correct prediction moves toward the extreme; one wrong one moves toward the middle. More robust than 1-bit: a loop exit only mispredicts twice.">2-BIT SATURATING COUNTER FSM</div></div>
        <div class="panel-body">
          <div class="fsm-visual">
            <div style="font-size:10px; color:var(--text3); letter-spacing:1px; text-transform:uppercase; margin-bottom:8px;">PREDICTOR STATE MACHINE</div>
            <div class="fsm-states">
              <div class="fsm-state sn" id="fsm-SN"><div style="font-family:'Share Tech Mono',monospace; font-size:13px; color:var(--red);">SN</div><div class="fsm-state-label">Strongly Not</div><div class="fsm-predict not-taken">NOT TAKEN</div></div>
              <div class="fsm-state wn" id="fsm-WN"><div style="font-family:'Share Tech Mono',monospace; font-size:13px; color:var(--orange);">WN</div><div class="fsm-state-label">Weakly Not</div><div class="fsm-predict not-taken">NOT TAKEN</div></div>
              <div class="fsm-state wt" id="fsm-WT"><div style="font-family:'Share Tech Mono',monospace; font-size:13px; color:var(--yellow);">WT</div><div class="fsm-state-label">Weakly Taken</div><div class="fsm-predict taken">TAKEN</div></div>
              <div class="fsm-state st" id="fsm-ST"><div style="font-family:'Share Tech Mono',monospace; font-size:13px; color:var(--green);">ST</div><div class="fsm-state-label">Strongly Taken</div><div class="fsm-predict taken">TAKEN</div></div>
            </div>
            <div id="branchEnglishBox" style="background:linear-gradient(135deg,rgba(255,221,0,0.04),rgba(0,0,0,0)); border:1px solid rgba(255,221,0,0.2); border-radius:3px; padding:8px 10px; margin-top:8px; margin-bottom:4px;">
              <div style="font-size:8px; color:var(--yellow); letter-spacing:1px; text-transform:uppercase; margin-bottom:3px;">WHAT THE PREDICTOR IS DOING</div>
              <div id="branchEnglishText" style="font-size:11px; color:var(--text1); line-height:1.5;">No branches seen yet. The predictor starts in the <b>Weakly Taken (WT)</b> state — it will guess "taken" for the first branch it sees.</div>
            </div>
            <div style="font-size:10px; color:var(--text3); margin-top:8px;">Current State: <span id="currentFSMState" data-tip="fsmstate|Current Predictor State|SN=Strongly Not Taken, WN=Weakly Not Taken, WT=Weakly Taken, ST=Strongly Taken. The predictor predicts TAKEN if in WT or ST states." style="font-family:'Share Tech Mono',monospace; color:var(--accent);">WT</span></div>
            <div style="display:flex; gap:8px; margin-top:12px;">
              <button class="btn green" onclick="fsmTaken()" style="flex:1;">BRANCH TAKEN</button>
              <button class="btn orange" onclick="fsmNotTaken()" style="flex:1;">NOT TAKEN</button>
            </div>
            <div style="margin-top:16px; width:100%;">
              <div class="section-title">BRANCH HISTORY REGISTER</div>
              <div style="display:flex; gap:2px; margin-top:6px;" id="bhrDisplay"></div>
            </div>
            <div style="margin-top:12px; width:100%;">
              <div class="section-title">RECENT BRANCHES</div>
              <div id="branchHistoryLog" style="display:flex; flex-direction:column; gap:2px; max-height:120px; overflow-y:auto;"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- TAB 7: OUT-OF-ORDER / ROB -->
  <div class="tab-panel" id="tab-ooo">
    <div class="ooo-layout" style="width:100%;">
      <div class="panel" style="border-bottom:none;">
        <div class="panel-header"><div class="panel-title" data-tip="rs|Reservation Stations|Buffers where instructions wait until their <b>operands are ready</b>. An out-of-order CPU can issue instructions in any order — as soon as both inputs are available, it goes to a functional unit. Enables bypassing stalls that would block an in-order pipeline.">RESERVATION STATIONS</div><div class="panel-badge">16 ENTRIES</div></div>
        <div class="panel-body"><div id="rsDisplay"></div></div>
      </div>
      <div class="panel" style="border-bottom:none;">
        <div class="panel-header"><div class="panel-title" data-tip="rob|Reorder Buffer (ROB)|Tracks in-flight instructions in their <b>original program order</b>. Out-of-order CPUs execute instructions in any order, but the ROB ensures results are <b>committed</b> (made permanent) in order. This preserves correct program behavior and makes exceptions precise.">REORDER BUFFER</div><div class="panel-badge">32 ENTRIES</div></div>
        <div class="panel-body">
          <div style="background:linear-gradient(135deg,rgba(0,212,255,0.04),rgba(0,0,0,0)); border:1px solid rgba(0,212,255,0.15); border-radius:3px; padding:8px 10px; margin-bottom:8px; font-size:10px; color:var(--text2); line-height:1.5;">
            <span style="color:var(--accent); font-size:8px; letter-spacing:1px; text-transform:uppercase; display:block; margin-bottom:3px;">HOW THE ROB WORKS</span>
            Instructions enter at the <b>TAIL</b> (newest) and leave at the <b>HEAD</b> (oldest). Even if an instruction finishes early, it can only <b>commit</b> (become permanent) when everything before it in program order has already committed. This preserves correct behaviour — the CPU can execute out of order, but the world sees results in order.
          </div>
          <div style="display:flex; gap:8px; margin-bottom:8px; font-family:'Share Tech Mono',monospace; font-size:10px;">
            <div><span class="c-text3">HEAD: </span><span class="c-accent2" id="robHead">0</span></div>
            <div><span class="c-text3">TAIL: </span><span class="c-orange" id="robTail">0</span></div>
            <div><span class="c-text3">USED: </span><span class="c-green" id="robUsed">0</span>/32</div>
          </div>
          <table class="rob-table">
            <thead><tr><th>IDX</th><th>INSTR</th><th>DEST</th><th>VALUE</th><th>STATE</th></tr></thead>
            <tbody id="robBody"></tbody>
          </table>
        </div>
      </div>
      <div class="panel" style="border-right:none; border-bottom:none;">
        <div class="panel-header"><div class="panel-title">EXECUTION UNITS + COMMIT</div></div>
        <div class="panel-body">
          <div class="section-title">FUNCTIONAL UNITS</div>
          <div style="display:flex; flex-direction:column; gap:4px; margin-bottom:12px;">
            <div class="rs-entry" id="fu-alu1"><div class="rs-row"><span style="color:var(--accent); font-size:10px; width:80px;">INT ALU 1</span><span id="fu-alu1-status" class="c-text3" style="font-size:10px;">IDLE</span><span id="fu-alu1-instr" class="c-yellow" style="font-size:10px; margin-left:auto;">—</span></div></div>
            <div class="rs-entry" id="fu-alu2"><div class="rs-row"><span style="color:var(--accent); font-size:10px; width:80px;">INT ALU 2</span><span id="fu-alu2-status" class="c-text3" style="font-size:10px;">IDLE</span><span id="fu-alu2-instr" class="c-yellow" style="font-size:10px; margin-left:auto;">—</span></div></div>
            <div class="rs-entry" id="fu-mul"><div class="rs-row"><span style="color:var(--purple); font-size:10px; width:80px;">MUL/DIV</span><span id="fu-mul-status" class="c-text3" style="font-size:10px;">IDLE</span><span id="fu-mul-instr" class="c-yellow" style="font-size:10px; margin-left:auto;">—</span></div></div>
            <div class="rs-entry" id="fu-lsu"><div class="rs-row"><span style="color:var(--orange); font-size:10px; width:80px;">LOAD/STORE</span><span id="fu-lsu-status" class="c-text3" style="font-size:10px;">IDLE</span><span id="fu-lsu-instr" class="c-yellow" style="font-size:10px; margin-left:auto;">—</span></div></div>
            <div class="rs-entry" id="fu-bru"><div class="rs-row"><span style="color:var(--yellow); font-size:10px; width:80px;">BRANCH</span><span id="fu-bru-status" class="c-text3" style="font-size:10px;">IDLE</span><span id="fu-bru-instr" class="c-yellow" style="font-size:10px; margin-left:auto;">—</span></div></div>
          </div>
          <div class="section-title">COMMIT</div>
          <div style="background:var(--bg2); border:1px solid var(--border); padding:8px; margin-bottom:8px;">
            <div style="font-family:'Share Tech Mono',monospace; font-size:10px; display:flex; flex-direction:column; gap:4px;">
              <div style="display:flex; justify-content:space-between;"><span class="c-text3">COMMITTED:</span><span id="oooCommitted" class="c-green">0</span></div>
              <div style="display:flex; justify-content:space-between;"><span class="c-text3">SQUASHED:</span><span id="oooSquashed" class="c-red">0</span></div>
              <div style="display:flex; justify-content:space-between;"><span class="c-text3">LAST COMMIT:</span><span id="oooLastCommit" class="c-yellow">—</span></div>
            </div>
          </div>
          <div class="section-title" data-tip="rat|Register Alias Table (RAT)|Maps architectural registers (R0–R31) to <b>ROB entries</b> holding their most recent in-flight value. Enables <b>register renaming</b> — multiple instructions can have different "versions" of the same architectural register, eliminating false WAR/WAW hazards.">REGISTER ALIAS TABLE (RAT)</div>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:2px;" id="ratDisplay"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- TAB 8: GLOSSARY -->
  <div class="tab-panel" id="tab-glossary" style="flex-direction:column; overflow:hidden;">
    <div style="display:flex; height:100%; overflow:hidden;">
      <div style="width:200px; flex-shrink:0; background:var(--bg2); border-right:1px solid var(--border); overflow-y:auto; display:flex; flex-direction:column;">
        <div style="padding:10px 12px; font-family:'Orbitron',sans-serif; font-size:9px; letter-spacing:2px; color:var(--accent); border-bottom:1px solid var(--border); flex-shrink:0;">SECTIONS</div>
        <div id="glossaryNav" style="display:flex; flex-direction:column;"></div>
      </div>
      <div id="glossaryContent" style="flex:1; overflow-y:auto; padding:0; scrollbar-width:thin; scrollbar-color:var(--border2) transparent;"></div>
    </div>
  </div>

  <!-- SORT OVERLAY -->
  <div id="sortOverlay">
    <div class="sort-bar-panel">
      <div class="sort-bar-header">
        <div class="sort-bar-title" id="sortOverlayTitle">BUBBLE SORT</div>
        <div class="sort-bar-meta">PASS <span id="sortPassNum">—</span>&nbsp;/&nbsp;<span id="sortPassTotal">—</span>&nbsp;·&nbsp;COMPARISONS <span id="sortCmpCount">0</span>&nbsp;·&nbsp;SWAPS <span id="sortSwapCount">0</span></div>
        <div id="sortArrayState" style="font-family:'Share Tech Mono',monospace; font-size:11px; color:var(--yellow); margin-left:12px;">—</div>
        <button class="sort-bar-close" onclick="closeSortOverlay()">HIDE ✕</button>
      </div>
      <div style="display:flex; gap:4px; align-items:flex-end; height:90px; padding:0 8px 0;" id="sortBarsContainer"></div>
    </div>
    <div class="narrative-panel">
      <div class="narrative-current">
        <div class="narrative-algo" id="narrativeAlgo">Load a program to begin…</div>
        <div class="narrative-detail" id="narrativeDetail"></div>
        <div class="narrative-tags" id="narrativeTags"></div>
      </div>
      <div class="narrative-history" id="narrativeHistory"></div>
    </div>
  </div>

</div>

<div class="status-bar">
  <div class="status-item"><div class="status-dot" id="simStatusDot"></div><div class="status-label">SIM</div><div class="status-val" id="simStatusVal">IDLE</div></div>
  <div class="status-item"><div class="status-label">STAGE</div><div class="status-val" id="currentStageVal">—</div></div>
  <div class="status-item"><div class="status-label">INSTR</div><div class="status-val c-yellow" id="currentInstrVal">—</div></div>
  <div class="status-item"><div class="status-label">CACHE</div><div class="status-val" id="cacheStatusVal">WARM</div></div>
  <div class="status-item"><div class="status-label">BRANCH</div><div class="status-val" id="branchStatusVal">—</div></div>
  <div class="status-item" id="goalStatusItem" style="flex:1; max-width:420px; display:none; border-left:1px solid var(--border2); border-right:1px solid var(--border2);"><div class="status-label">GOAL</div><div class="status-val" id="goalStatusVal" style="color:var(--text1); font-size:10px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:380px;">—</div></div>
  <div class="status-item" style="margin-left:auto;"><div class="status-label">FREQ</div><div class="status-val c-accent">3.2 GHz</div></div>
  <div class="status-item"><div class="status-label">TEMP</div><div class="status-val" id="tempVal">42°C</div></div>
  <div class="status-item"><div class="status-label">POWER</div><div class="status-val" id="powerVal">12W</div></div>
</div>

<!-- PROGRAMS MODAL -->
<div class="help-overlay" id="programsOverlay" onclick="this.classList.remove('show')">
  <div class="help-box" style="max-width:620px;" onclick="event.stopPropagation()">
    <h2>SELECT PROGRAM</h2>
    <p style="font-size:12px;color:var(--text3);margin-bottom:16px;">Each program is compiled to RISC-V RV32I instructions and loaded into the fetch queue.</p>
    <div style="display:flex;flex-direction:column;gap:8px;">
      <div style="border:1px solid var(--border2);background:var(--bg2);padding:12px;">
        <div style="font-family:'Orbitron',sans-serif;font-size:11px;color:var(--accent);letter-spacing:2px;margin-bottom:8px;">BUBBLE SORT</div>
        <div style="font-size:11px;color:var(--text2);margin-bottom:10px;">Sorts an integer array. Heavy on LW/SW pairs and load-use stalls.</div>
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
          <label style="font-size:10px;color:var(--text3);white-space:nowrap;">ARRAY:</label>
          <input id="bubbleArrayInput" class="instr-input" style="flex:1;font-size:12px;" value="5, 3, 8, 1, 9, 2, 7, 4">
        </div>
        <button class="btn green" style="width:100%;" onclick="launchBubbleSort()">LOAD & RUN BUBBLE SORT ▶</button>
      </div>
      <div style="border:1px solid var(--border2);background:var(--bg2);padding:12px;">
        <div style="font-family:'Orbitron',sans-serif;font-size:11px;color:var(--purple);letter-spacing:2px;margin-bottom:8px;">DOT PRODUCT</div>
        <div style="font-size:11px;color:var(--text2);margin-bottom:10px;">Computes A·B for two vectors. MUL unit + forwarding showcase.</div>
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">
          <label style="font-size:10px;color:var(--text3);white-space:nowrap;">VEC A:</label>
          <input id="dotVecA" class="instr-input" style="flex:1;font-size:12px;" value="1, 2, 3, 4, 5, 6, 7, 8">
          <label style="font-size:10px;color:var(--text3);white-space:nowrap;">VEC B:</label>
          <input id="dotVecB" class="instr-input" style="flex:1;font-size:12px;" value="8, 7, 6, 5, 4, 3, 2, 1">
        </div>
        <button class="btn" style="width:100%;margin-top:8px;border-color:var(--purple);color:var(--purple);" onclick="launchDotProduct()">LOAD & RUN DOT PRODUCT ▶</button>
      </div>
      <div style="border:1px solid var(--border2);background:var(--bg2);padding:12px;">
        <div style="font-family:'Orbitron',sans-serif;font-size:11px;color:var(--yellow);letter-spacing:2px;margin-bottom:8px;">XOR CIPHER</div>
        <div style="font-size:11px;color:var(--text2);margin-bottom:10px;">XOR-encrypts values with a rolling key. Pure ALU showcase, near-zero stalls.</div>
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">
          <label style="font-size:10px;color:var(--text3);white-space:nowrap;">DATA:</label>
          <input id="xorData" class="instr-input" style="flex:1;font-size:12px;" value="72, 101, 108, 108, 111">
          <label style="font-size:10px;color:var(--text3);white-space:nowrap;">KEY:</label>
          <input id="xorKey" class="instr-input" style="width:80px;font-size:12px;" value="0xAB">
        </div>
        <button class="btn" style="width:100%;margin-top:8px;border-color:var(--yellow);color:var(--yellow);" onclick="launchXorCipher()">LOAD & RUN XOR CIPHER ▶</button>
      </div>
    </div>
    <button class="btn" style="margin-top:12px;width:100%;" onclick="document.getElementById('programsOverlay').classList.remove('show')">CANCEL</button>
  </div>
</div>

<!-- HELP OVERLAY -->
<div class="help-overlay" id="helpOverlay" onclick="this.classList.remove('show')">
  <div class="help-box" onclick="event.stopPropagation()">
    <h2>CPU VISUALIZER · HELP</h2>
    <div class="help-row"><div class="help-key">STEP ▶</div><div class="help-desc">Advance one clock cycle through the pipeline</div></div>
    <div class="help-row"><div class="help-key">AUTO RUN</div><div class="help-desc">Continuously step at the selected speed</div></div>
    <div class="help-row"><div class="help-key">RESET</div><div class="help-desc">Clear all pipeline state, registers, and counters</div></div>
    <div class="help-row"><div class="help-key">PROGRAMS</div><div class="help-desc">Load Bubble Sort, Dot Product, or XOR Cipher</div></div>
    <div class="help-row"><div class="help-key">TABS 01-07</div><div class="help-desc">Dive deeper into each CPU subsystem</div></div>
    <div style="margin-top:12px; padding:8px; background:var(--bg2); border:1px solid var(--border); font-size:11px; color:var(--text3);">
      Load-use stall fix: The load instruction (LW) now correctly advances to EX during the stall cycle, while only the consumer instruction stays frozen in IF. This means exactly 1 stall cycle per load-use hazard, then MEM/WB forwarding resolves it.
    </div>
    <button class="btn" style="margin-top:12px; width:100%;" onclick="document.getElementById('helpOverlay').classList.remove('show')">CLOSE</button>
  </div>
</div>

<script>
// ============================================================
// CPU SIMULATION ENGINE — FIXED LOAD-USE STALL LOGIC
// ============================================================

const STAGES = ['IF','ID','EX','MEM','WB'];
const REG_NAMES = ['zero','ra','sp','gp','tp','t0','t1','t2','s0','s1','a0','a1','a2','a3','a4','a5','a6','a7','s2','s3','s4','s5','s6','s7','s8','s9','s10','s11','t3','t4','t5','t6'];

let autoRunInterval = null;
let currentProgramGoal = '';   // plain-English description of what is currently running
let programCompleteFired = false;  // true once the done instruction commits
let speedMs = 800;
let totalCycles = 0;
let totalInstrs = 0;
let totalStalls = 0;
let totalRaw = 0;
let totalBranchMispred = 0;
let totalFwd = 0;
let cacheMisses = 0;

// Pipeline state — each slot holds a parsed instruction object or null
let pipeline = { IF: null, ID: null, EX: null, MEM: null, WB: null };
let instrQueue = [];
let registers = new Array(32).fill(0);
let memory = {};
let instructionMemory = [];
let pc = 0;
let programCounter = 0;

// Branch predictor
let bpState = 'WT';
let bhrRegister = new Array(8).fill(0);
let btbEntries = [];
let branchHistory = [];
let btbCorrect = 0;
let btbMispred = 0;

// Cache
let icacheData = [], dcacheData = [];
let icacheHits = 0, icacheMisses = 0;
let dcacheHits = 0, dcacheMissesCnt = 0;
let l2Hits = 0, l2Misses = 0;
let tlbIHits = 0, tlbDHits = 0, tlbMissesCnt = 0;

// ROB
let rob = [];
let rsList = [];
let rat = new Array(32).fill(-1);
let robHead = 0, robTail = 0;
let oooCommitted = 0, oooSquashed = 0;

// Timing
let timingData = [];
let maxCycles = 20;
let currentCycle = 0;

// Stats
let rawHazards = 0;
let stallCycles = 0;
let mispredictions = 0;
let fwdUsed = 0;

let temp = 42;
let power = 12;

// Sort overlay state
let sortOverlayActive = false;
let pendingBranchFlush = false;   // set by executeEX on misprediction, consumed by step()
let pendingBranchTarget = null;   // instruction index to restart from
let lastMemAccess = null;         // {type, addr, val, hit, level} - for plain-English memory display
let sortArray = [];
let sortArrayInitial = [];
let sortCmpCount = 0;
let sortSwapCount = 0;
let sortPass = 0;
let sortPassTotal = 0;
let sortComparingIdx = [-1, -1];
let sortSortedUpTo = -1;
let sortProgramType = '';

// ============================================================
// INSTRUCTION DEFINITIONS
// ============================================================
const INSTR_DB = {
  'ADD':  { type:'R', opcode:'0110011', funct3:'000', funct7:'0000000', aluOp:'ADD', regWrite:true },
  'SUB':  { type:'R', opcode:'0110011', funct3:'000', funct7:'0100000', aluOp:'SUB', regWrite:true },
  'AND':  { type:'R', opcode:'0110011', funct3:'111', funct7:'0000000', aluOp:'AND', regWrite:true },
  'OR':   { type:'R', opcode:'0110011', funct3:'110', funct7:'0000000', aluOp:'OR',  regWrite:true },
  'XOR':  { type:'R', opcode:'0110011', funct3:'100', funct7:'0000000', aluOp:'XOR', regWrite:true },
  'SLL':  { type:'R', opcode:'0110011', funct3:'001', funct7:'0000000', aluOp:'SLL', regWrite:true },
  'SRL':  { type:'R', opcode:'0110011', funct3:'101', funct7:'0000000', aluOp:'SRL', regWrite:true },
  'SRA':  { type:'R', opcode:'0110011', funct3:'101', funct7:'0100000', aluOp:'SRA', regWrite:true },
  'SLT':  { type:'R', opcode:'0110011', funct3:'010', funct7:'0000000', aluOp:'SLT', regWrite:true },
  'SLTU': { type:'R', opcode:'0110011', funct3:'011', funct7:'0000000', aluOp:'SLTU',regWrite:true },
  'MUL':  { type:'R', opcode:'0110011', funct3:'000', funct7:'0000001', aluOp:'MUL', regWrite:true, mulDiv:true },
  'DIV':  { type:'R', opcode:'0110011', funct3:'100', funct7:'0000001', aluOp:'DIV', regWrite:true, mulDiv:true },
  'ADDI': { type:'I', opcode:'0010011', funct3:'000', aluOp:'ADD', regWrite:true },
  'ANDI': { type:'I', opcode:'0010011', funct3:'111', aluOp:'AND', regWrite:true },
  'ORI':  { type:'I', opcode:'0010011', funct3:'110', aluOp:'OR',  regWrite:true },
  'XORI': { type:'I', opcode:'0010011', funct3:'100', aluOp:'XOR', regWrite:true },
  'SLTI': { type:'I', opcode:'0010011', funct3:'010', aluOp:'SLT', regWrite:true },
  'SLLI': { type:'I', opcode:'0010011', funct3:'001', aluOp:'SLL', regWrite:true },
  'SRLI': { type:'I', opcode:'0010011', funct3:'101', aluOp:'SRL', regWrite:true },
  'LW':   { type:'L', opcode:'0000011', funct3:'010', aluOp:'ADD', regWrite:true, memRead:true },
  'LH':   { type:'L', opcode:'0000011', funct3:'001', aluOp:'ADD', regWrite:true, memRead:true },
  'LB':   { type:'L', opcode:'0000011', funct3:'000', aluOp:'ADD', regWrite:true, memRead:true },
  'SW':   { type:'S', opcode:'0100011', funct3:'010', aluOp:'ADD', memWrite:true },
  'SH':   { type:'S', opcode:'0100011', funct3:'001', aluOp:'ADD', memWrite:true },
  'SB':   { type:'S', opcode:'0100011', funct3:'000', aluOp:'ADD', memWrite:true },
  'BEQ':  { type:'B', opcode:'1100011', funct3:'000', aluOp:'SUB', branch:true },
  'BNE':  { type:'B', opcode:'1100011', funct3:'001', aluOp:'SUB', branch:true },
  'BLT':  { type:'B', opcode:'1100011', funct3:'100', aluOp:'SLT', branch:true },
  'BGE':  { type:'B', opcode:'1100011', funct3:'101', aluOp:'SLT', branch:true },
  'JAL':  { type:'J', opcode:'1101111', aluOp:'ADD', regWrite:true, jump:true },
  'JALR': { type:'I', opcode:'1100111', funct3:'000', aluOp:'ADD', regWrite:true, jump:true },
  'LUI':  { type:'U', opcode:'0110111', aluOp:'LUI', regWrite:true },
  'AUIPC':{ type:'U', opcode:'0010111', aluOp:'ADD', regWrite:true },
  'NOP':  { type:'R', opcode:'0010011', funct3:'000', aluOp:'ADD', regWrite:false },
};

// ============================================================
// INSTRUCTION PARSER
// ============================================================
function parseInstr(raw) {
  if (!raw) return null;
  raw = raw.trim().toUpperCase().replace(/\s+/g,' ').replace(/,\s*/g,',');
  let parts = raw.split(' ');
  let mnem = parts[0];
  let ops = parts.slice(1).join('').split(',');
  let def = INSTR_DB[mnem];
  if (!def) {
    for (let k of Object.keys(INSTR_DB)) {
      if (raw.startsWith(k)) { mnem = k; def = INSTR_DB[k]; break; }
    }
  }
  if (!def) def = INSTR_DB['NOP'];

  let parsed = { raw, mnem, type: def.type, def, rd:0, rs1:0, rs2:0, imm:0, encoding:'', hex:'' };

  const parseReg = s => {
    if (!s) return 0;
    s = s.trim();
    if (s.match(/^R\d+$/)) return parseInt(s.slice(1)) % 32;
    if (s.match(/^X\d+$/)) return parseInt(s.slice(1)) % 32;
    let idx = REG_NAMES.indexOf(s.toLowerCase());
    return idx >= 0 ? idx : 0;
  };
  const parseImm = s => {
    if (!s) return 0;
    s = s.trim();
    let m = s.match(/(-?\d+)\((.+)\)/);
    if (m) { parsed.rs1 = parseReg(m[2]); return parseInt(m[1]); }
    if (s.startsWith('0X')) return parseInt(s, 16);
    return parseInt(s) || 0;
  };

  if (def.type === 'R') {
    parsed.rd  = ops[0] ? parseReg(ops[0]) : 0;
    parsed.rs1 = ops[1] ? parseReg(ops[1]) : 0;
    parsed.rs2 = ops[2] ? parseReg(ops[2]) : 0;
  } else if (def.type === 'I' || def.type === 'L') {
    parsed.rd  = ops[0] ? parseReg(ops[0]) : 0;
    if (def.type === 'L') {
      let m = (ops[1]||'').match(/(-?\d+)\((.+)\)/);
      if (m) { parsed.imm = parseInt(m[1]); parsed.rs1 = parseReg(m[2]); }
      else { parsed.rs1 = ops[1] ? parseReg(ops[1]) : 0; parsed.imm = ops[2] ? parseInt(ops[2]) : 0; }
    } else {
      parsed.rs1 = ops[1] ? parseReg(ops[1]) : 0;
      parsed.imm = ops[2] ? parseImm(ops[2]) : 0;
    }
  } else if (def.type === 'S') {
    parsed.rs2 = ops[0] ? parseReg(ops[0]) : 0;
    let m = (ops[1]||'').match(/(-?\d+)\((.+)\)/);
    if (m) { parsed.imm = parseInt(m[1]); parsed.rs1 = parseReg(m[2]); }
    else { parsed.rs1 = ops[1] ? parseReg(ops[1]) : 0; parsed.imm = ops[2] ? parseInt(ops[2]) : 0; }
  } else if (def.type === 'B') {
    parsed.rs1 = ops[0] ? parseReg(ops[0]) : 0;
    parsed.rs2 = ops[1] ? parseReg(ops[1]) : 0;
    parsed.imm = ops[2] ? parseImm(ops[2]) : 8;
  } else if (def.type === 'J') {
    parsed.rd  = ops[0] ? parseReg(ops[0]) : 0;
    parsed.imm = ops[1] ? parseImm(ops[1]) : 0;
  } else if (def.type === 'U') {
    parsed.rd  = ops[0] ? parseReg(ops[0]) : 0;
    parsed.imm = ops[1] ? parseImm(ops[1]) : 0;
  }

  let bits = def.opcode || '0000000';
  let rd5 = (parsed.rd & 0x1F).toString(2).padStart(5,'0');
  let rs15 = (parsed.rs1 & 0x1F).toString(2).padStart(5,'0');
  let rs25 = (parsed.rs2 & 0x1F).toString(2).padStart(5,'0');
  let f3 = (def.funct3||'000');
  let f7 = (def.funct7||'0000000');
  let imm12 = (parsed.imm & 0xFFF).toString(2).padStart(12,'0');

  if (def.type === 'R') parsed.encoding = f7 + rs25 + rs15 + f3 + rd5 + bits;
  else if (def.type === 'I' || def.type === 'L') parsed.encoding = imm12 + rs15 + f3 + rd5 + bits;
  else if (def.type === 'S') { parsed.encoding = imm12.slice(0,7) + rs25 + rs15 + f3 + imm12.slice(7) + bits; }
  else if (def.type === 'B') parsed.encoding = '0' + imm12.slice(1,7) + rs25 + rs15 + f3 + imm12.slice(8,12) + '0' + bits;
  else if (def.type === 'J') parsed.encoding = '0'.repeat(12) + '00000' + '000' + rd5 + bits;
  else if (def.type === 'U') parsed.encoding = (parsed.imm & 0xFFFFF).toString(2).padStart(20,'0') + rd5 + bits;
  else parsed.encoding = '0'.repeat(32);

  parsed.encoding = parsed.encoding.padEnd(32,'0').slice(0,32);
  parsed.hex = '0x' + parseInt(parsed.encoding, 2).toString(16).padStart(8,'0').toUpperCase();
  return parsed;
}

// ============================================================
// ALU
// ============================================================
function aluExecute(op, a, b) {
  a = a | 0; b = b | 0;
  switch(op) {
    case 'ADD':  return (a + b) | 0;
    case 'SUB':  return (a - b) | 0;
    case 'AND':  return a & b;
    case 'OR':   return a | b;
    case 'XOR':  return a ^ b;
    case 'SLL':  return a << (b & 31);
    case 'SRL':  return (a >>> (b & 31)) | 0;
    case 'SRA':  return a >> (b & 31);
    case 'SLT':  return a < b ? 1 : 0;
    case 'SLTU': return (a >>> 0) < (b >>> 0) ? 1 : 0;
    case 'MUL':  return Math.imul(a, b) | 0;
    case 'DIV':  return b !== 0 ? (a / b | 0) : -1;
    case 'LUI':  return b << 12;
    default:     return a + b;
  }
}

// ============================================================
// FORWARDING
// ============================================================
function checkForward(reg) {
  if (reg === 0) return { forward: false };
  // EX/MEM forwarding: instruction currently in MEM just finished EX
  if (pipeline.MEM && !pipeline.MEM.isBubble && pipeline.MEM.rd === reg && pipeline.MEM.def && pipeline.MEM.def.regWrite) {
    return { forward: true, source: 'EX/MEM', value: pipeline.MEM._result !== undefined ? pipeline.MEM._result : 0 };
  }
  // MEM/WB forwarding: instruction currently in WB
  if (pipeline.WB && !pipeline.WB.isBubble && pipeline.WB.rd === reg && pipeline.WB.def && pipeline.WB.def.regWrite) {
    let val = (pipeline.WB.def.memRead && pipeline.WB._loadVal !== undefined) ? pipeline.WB._loadVal : (pipeline.WB._result || 0);
    return { forward: true, source: 'MEM/WB', value: val };
  }
  return { forward: false };
}

// ============================================================
// *** THE FIXED STEP() FUNCTION ***
//
// THE BUG (original): On load-use stall, both IF and ID were frozen,
// but WB/MEM advanced. This meant the stall check saw the SAME load
// instruction in ID every cycle forever → infinite stall loop.
//
// THE FIX: On load-use stall:
//   - The LOAD (in ID) advances normally to EX (it must execute!)
//   - A NOP BUBBLE is inserted into ID
//   - The CONSUMER (in IF) stays frozen — no new fetch
//   - PC does not increment
//   Next cycle: load is in EX (executing), bubble in ID (no hazard),
//   consumer still in IF. No stall detected. Consumer moves to ID next
//   cycle, and the load result is forwarded MEM→EX. Exactly 1 stall.
// ============================================================
function step() {
  totalCycles++;
  currentCycle++;
  temp = Math.min(95, temp + (Math.random() > 0.7 ? 1 : 0) - (Math.random() > 0.8 ? 1 : 0));
  power = Math.max(5, Math.min(65, power + (Math.random() * 4 - 2) | 0));

  // ── LOAD-USE HAZARD DETECTION ──────────────────────────────────────────────
  // Detect: instruction in ID is a LOAD that will write a register that
  // the instruction in IF needs to read. Cannot forward — data doesn't exist yet.
  let loadUseStall = false;
  if (pipeline.ID && pipeline.IF && !pipeline.ID.isBubble && !pipeline.IF.isBubble) {
    const loadCandidate = pipeline.ID;
    const consumer = pipeline.IF;
    if (loadCandidate.def && loadCandidate.def.memRead && loadCandidate.rd !== 0) {
      if (loadCandidate.rd === consumer.rs1 || loadCandidate.rd === consumer.rs2) {
        loadUseStall = true;
      }
    }
  }

  if (loadUseStall) {
    // ── STALL PATH ────────────────────────────────────────────────────────
    // Load (in ID) advances to EX — it still needs to execute!
    // Bubble inserted into ID to separate load from consumer.
    // Consumer (IF) stays frozen. No new fetch. PC unchanged.
    totalStalls++;
    stallCycles++;
    rawHazards++;
    totalRaw++;

    const bubble = parseInstr('NOP');
    bubble.isBubble = true;

    const loadInstr  = pipeline.ID;  // the load that's causing the stall
    const consumerInstr = pipeline.IF; // the instruction frozen in IF

    // Advance: WB←MEM, MEM←EX, EX←(load moves forward), ID←bubble, IF stays
    pipeline.WB  = pipeline.MEM;     // MEM advances to WB
    pipeline.MEM = pipeline.EX;      // EX advances to MEM
    pipeline.EX  = loadInstr;        // *** LOAD ADVANCES TO EX (key fix) ***
    pipeline.ID  = bubble;           // Bubble replaces load in ID
    // pipeline.IF = pipeline.IF      ← unchanged, consumer stays frozen

    highlightHazard('raw');
    addLog(totalCycles, 'STALL',
      `Load-Use: ${loadInstr.mnem} R${loadInstr.rd} needed by ${consumerInstr.mnem} — 1 cycle bubble`, 'hazard');
    const hEngEl = document.getElementById('hazardEnglishText');
    if (hEngEl) hEngEl.innerHTML = `<span style="color:var(--red);">⚠ Load-Use Stall detected!</span> <b>${loadInstr.raw}</b> is a Load instruction — it needs to visit memory before it knows its result. But <b>${consumerInstr.raw}</b> needs that result right now. The CPU inserts a 1-cycle bubble (do-nothing gap) to wait. Next cycle, the loaded value is forwarded directly and execution continues. <b>Cost: exactly 1 wasted cycle.</b>`;
    setText('loadUseDetect', 'YES');
    setText('loadUseStalls', totalStalls);
    setText('loadUseBubble', `into ID after ${loadInstr.mnem}`);

    if (sortOverlayActive) {
      pushNarrative('stall',
        `<b>⚠ LOAD-USE STALL</b> — 1 cycle bubble inserted`,
        `<b>${loadInstr.raw}</b> moves to Execute. Its result won't arrive until Memory completes next cycle. <b>${consumerInstr.raw}</b> stays frozen in Fetch. A NOP bubble fills Decode. Next cycle: MEM/WB forwarding supplies the value — no further stalls needed.`,
        [{cls:'stall', label:'1-CYCLE STALL'}, {cls:'load', label:'LOAD-USE'}, {cls:'alu', label:'NOP BUBBLE'}]
      );
    }

    // Execute stages that advanced (not the newly placed load in EX — it executes next cycle)
    // WB: pipeline.WB is the old MEM content
    if (pipeline.WB && !pipeline.WB.isBubble) {
      executeWB(pipeline.WB);
      totalInstrs++;
      addLog(totalCycles, 'WB', `Committed: ${pipeline.WB.raw}`, 'writeback');
      updateTimingRow(pipeline.WB, 'WB', currentCycle);
      addROBEntry(pipeline.WB, 'COMMIT');
    }
    // MEM: pipeline.MEM is the old EX content
    if (pipeline.MEM && !pipeline.MEM.isBubble) {
      executeMEM(pipeline.MEM);
      updateTimingRow(pipeline.MEM, 'MEM', currentCycle);
    }
    // EX: the load just moved here — execute it now
    if (pipeline.EX && !pipeline.EX.isBubble) {
      executeEX(pipeline.EX);
      updateTimingRow(pipeline.EX, 'EX', currentCycle);
    }
    // IF: consumer is frozen, log it as stalled
    if (pipeline.IF) {
      updateTimingRow(pipeline.IF, 'STALL', currentCycle);
    }

  } else {
    // ── NORMAL ADVANCE PATH ───────────────────────────────────────────────
    // Fetch next instruction (if any available)
    const fetch_instr = instrQueue.length > 0 ? instrQueue.shift() : null;

    // Check forwarding for the instruction about to enter EX (currently in ID)
    const aboutToExecute = pipeline.ID;
    if (aboutToExecute && !aboutToExecute.isBubble) {
      const fwdA = checkForward(aboutToExecute.rs1);
      const fwdB = checkForward(aboutToExecute.rs2);
      if (fwdA.forward || fwdB.forward) {
        totalFwd++;
        fwdUsed++;
        if (sortOverlayActive) {
          const src = fwdA.forward ? fwdA.source : fwdB.source;
          const reg = fwdA.forward ? `R${aboutToExecute.rs1}` : `R${aboutToExecute.rs2}`;
          const val = fwdA.forward ? fwdA.value : fwdB.value;
          pushNarrative('fwd',
            `<b>Forwarding</b> ${reg}=<span class="highlight-accent">${val}</span> from <span class="highlight-accent">${src}</span> → EX`,
            `${aboutToExecute.raw} needs ${reg}. The forwarding unit routes the result directly — no stall needed.`,
            [{cls:'fwd', label:`${src} FORWARD`}, {cls:'alu', label:'NO STALL'}]
          );
        }
      }
    }

    // Advance all stages
    pipeline.WB  = pipeline.MEM;
    pipeline.MEM = pipeline.EX;
    pipeline.EX  = pipeline.ID;
    pipeline.ID  = pipeline.IF;
    pipeline.IF  = fetch_instr;

    // Increment PC only when we actually fetch a new instruction
    if (fetch_instr) {
      programCounter += 4;
      pc = programCounter;
    }

    // Execute each stage
    if (pipeline.WB && !pipeline.WB.isBubble) {
      executeWB(pipeline.WB);
      totalInstrs++;
      addLog(totalCycles, 'WB', `Committed: ${pipeline.WB.raw}`, 'writeback');
      updateTimingRow(pipeline.WB, 'WB', currentCycle);
      addROBEntry(pipeline.WB, 'COMMIT');
    }
    if (pipeline.MEM && !pipeline.MEM.isBubble) {
      executeMEM(pipeline.MEM);
      updateTimingRow(pipeline.MEM, 'MEM', currentCycle);
    }
    if (pipeline.EX && !pipeline.EX.isBubble) {
      executeEX(pipeline.EX);
      updateTimingRow(pipeline.EX, 'EX', currentCycle);
    }
    if (pipeline.ID && !pipeline.ID.isBubble) {
      addLog(totalCycles, 'ID', `Decode: ${pipeline.ID.raw}`, 'decode');
      updateDecode(pipeline.ID);
      updateTimingRow(pipeline.ID, 'ID', currentCycle);
    }
    if (pipeline.IF) {
      addLog(totalCycles, 'IF',
        `Fetch: ${pipeline.IF.raw} @ 0x${((programCounter-4)>>>0).toString(16).padStart(8,'0').toUpperCase()}`, 'fetch');
      updateTimingRow(pipeline.IF, 'IF', currentCycle);
      simulateCacheAccess('icache', programCounter-4);
    }

    setText('loadUseDetect', 'NO');
    // Update hazard status English
    const hEngNormal = document.getElementById('hazardEnglishText');
    if (hEngNormal) {
      const fwdAny = (pipeline.EX && !pipeline.EX.isBubble) ? (checkForward(pipeline.EX.rs1).forward || checkForward(pipeline.EX.rs2).forward) : false;
      if (fwdAny) {
        hEngNormal.innerHTML = '<span style="color:var(--green);">✓ Forwarding active.</span> A register value needed by the instruction in Execute was produced by an earlier in-flight instruction. The forwarding unit routes it directly — no stall needed. This is the pipeline running at full efficiency.';
      } else {
        hEngNormal.innerHTML = '<span style="color:var(--green);">✓ Pipeline flowing normally.</span> No hazards detected this cycle. Every instruction has access to the values it needs, either from the register file or via forwarding.';
      }
    }
  }

  // ── BRANCH FLUSH ──────────────────────────────────────────────────────────
  // If a branch in EX resolved as taken (or mispredicted), flush the two
  // speculatively-fetched instructions from IF and ID (they're from the wrong path).
  if (pendingBranchFlush) {
    pendingBranchFlush = false;
    const flushBubble1 = parseInstr('NOP'); flushBubble1.isBubble = true;
    const flushBubble2 = parseInstr('NOP'); flushBubble2.isBubble = true;
    // IF and ID had wrong-path instructions - replace with bubbles
    if (pipeline.ID) { addLog(totalCycles, 'BRANCH', `Flushed: ${pipeline.ID.isBubble ? 'bubble' : pipeline.ID.raw} from ID (wrong path)`, 'hazard'); }
    if (pipeline.IF) { addLog(totalCycles, 'BRANCH', `Flushed: ${pipeline.IF.isBubble ? 'bubble' : pipeline.IF.raw} from IF (wrong path)`, 'hazard'); }
    pipeline.IF = flushBubble1;
    pipeline.ID = flushBubble2;
  }

  updateAll();
  updateInstrQueueDisplay();
}

// ============================================================
// STAGE EXECUTORS
// ============================================================
function executeEX(instr) {
  const fwdA = checkForward(instr.rs1);
  const fwdB = checkForward(instr.rs2);
  let opA = fwdA.forward ? fwdA.value : registers[instr.rs1];
  let opB = (instr.def.type === 'I' || instr.def.type === 'L' || instr.def.type === 'S')
    ? instr.imm
    : (fwdB.forward ? fwdB.value : registers[instr.rs2]);

  let result = aluExecute(instr.def.aluOp, opA, opB);
  instr._result = result;
  instr._opA = opA;
  instr._opB = opB;
  instr._memAddr = (instr.def.memRead || instr.def.memWrite) ? result : null;

  updateALUDisplay(instr, opA, opB, result, fwdA, fwdB);
  addLog(totalCycles, 'EX', `Execute: ${instr.raw} → ${result} (${instr.def.aluOp})`, 'execute');

  // Sort narrative hooks
  // Sort state tracking — always runs regardless of overlay visibility
  if (sortProgramType === 'bubble' && instr._sortMeta) {
    const m = instr._sortMeta;
    if (m.type === 'compare') {
      sortCmpCount++;
    }
    if (m.type === 'pass_end') {
      sortPass++;
      sortSortedUpTo = sortArray.length - sortPass;
    }
    if (m.type === 'done') {
      sortSortedUpTo = 0;
      programCompleteFired = true;
    }
    // Display updates only when overlay is open
    if (sortOverlayActive) {
      if (m.type === 'compare') {
        const needsSwap = result === 1;
        renderSortBars(m.j, m.j + 1, -1, -1, sortSortedUpTo);
        pushNarrative('compare',
          `<b>Comparing</b> arr[${m.j}] vs arr[${m.j+1}] → ${needsSwap ? '<span class="highlight-red">SWAP NEEDED</span>' : '<span class="highlight-green">NO SWAP</span>'}`,
          `SLT: is arr[${m.j+1}] < arr[${m.j}]? Result R3=${result}. ${needsSwap ? 'Elements are out of order.' : 'Elements are in order.'}`,
          needsSwap ? [{cls:'swap', label:'OUT OF ORDER'}, {cls:'alu', label:'SLT'}] : [{cls:'nswap', label:'IN ORDER'}, {cls:'alu', label:'SLT'}]
        );
      }
      if (m.type === 'pass_end') {
        renderSortBars(-1, -1, -1, -1, sortSortedUpTo);
        const remaining = sortPassTotal - sortPass;
        const sortedCount = sortArray.length - sortSortedUpTo;
        pushNarrative('info',
          `<b>Pass ${m.pass+1} of ${sortPassTotal} complete</b> — largest unsorted element has bubbled to its final position`,
          `Array so far: [${sortArray.join(', ')}]. Last ${sortedCount} element${sortedCount!==1?'s are':' is'} now in their correct place (shown in green). ${remaining > 0 ? remaining+' pass'+(remaining!==1?'es':'')+' remain.' : 'All done!'}`,
          [{cls:'nswap', label:`PASS ${m.pass+1} DONE`}, {cls:'load', label:`${sortedCount} SORTED`}]
        );
      }
      if (m.type === 'done') {
        renderSortBars(-1,-1,-1,-1,0);
        pushNarrative('info',
          `<b>SORT COMPLETE</b> — array: <span class="highlight-green">[${sortArray.join(', ')}]</span>`,
          `All ${sortPassTotal} passes done. ${sortCmpCount} comparisons, ${sortSwapCount} swaps.`,
          [{cls:'nswap', label:'SORTED ✓'}]
        );
        // Stop immediately - clear queue so auto-repeat can't restart
        instrQueue = [];
        const doneMsg = sortProgramType === 'bubble'
          ? 'Bubble Sort complete — [' + sortArray.join(', ') + '] sorted in ' + totalCycles + ' cycles, ' + totalStalls + ' stalls'
          : 'Program complete in ' + totalCycles + ' cycles';
        stopAutoRun(doneMsg);
      }
    }
  }

  // Universal program-done detection (works for all program types with _sortMeta)
  if (instr._sortMeta && instr._sortMeta.type === 'done' && sortProgramType && sortProgramType !== 'bubble') {
    programCompleteFired = true;
    const doneMsg = sortProgramType === 'dot'
      ? 'Dot Product complete in ' + totalCycles + ' cycles — result in R15'
      : sortProgramType === 'xor'
        ? 'XOR Cipher complete in ' + totalCycles + ' cycles'
        : 'Program complete in ' + totalCycles + ' cycles';
    if (sortOverlayActive) {
      renderSortBars(-1,-1,-1,-1,0);
      pushNarrative('info',
        '<b>PROGRAM COMPLETE</b>',
        doneMsg,
        [{cls:'nswap', label:'DONE ✓'}]
      );
    }
    instrQueue = [];
    stopAutoRun(doneMsg);
  }

  // Branch handling
  if (instr.def.branch) {
    let taken = false;
    switch(instr.mnem) {
      case 'BEQ': taken = opA === opB; break;
      case 'BNE': taken = opA !== opB; break;
      case 'BLT': taken = opA < opB;   break;
      case 'BGE': taken = opA >= opB;  break;
    }
    instr._branchTaken = taken;
    instr._branchTarget = programCounter + instr.imm - 4;
    let predicted = (bpState === 'WT' || bpState === 'ST');
    // If branch is taken, the 2 instructions fetched after it (IF, ID) are WRONG
    // and must be flushed regardless of prediction correctness
    if (taken) {
      pendingBranchFlush = true;
    }
    if (predicted !== taken) {
      totalBranchMispred++;
      mispredictions++;
      btbMispred++;
      addLog(totalCycles, 'BRANCH', `MISPREDICTION! Predicted:${predicted?'T':'N'} Actual:${taken?'T':'N'}`, 'hazard');
      highlightHazard('control');
      // Note: pipeline flush only needed when branch IS taken (wrong sequential path in pipeline).
      // When branch is NOT taken, IF/ID already have the correct sequential instructions.
      // Flush on taken is handled by the `if (taken)` block above.
    } else {
      btbCorrect++;
    }
    updateFSM(taken);
    branchHistory.unshift({ instr: instr.raw, taken, predicted, cycle: totalCycles });
    if (branchHistory.length > 8) branchHistory.pop();
    renderBranchHistory();
  }
}

function executeMEM(instr) {
  if (instr.def.memRead) {
    let addr = instr._memAddr !== null ? instr._memAddr : (registers[instr.rs1] + instr.imm);
    let key = '0x' + (addr >>> 0).toString(16).toUpperCase();
    instr._loadVal = memory[key] !== undefined ? memory[key] : 0;
    instr._result = instr._loadVal;
    simulateCacheAccess('dcache', addr);
    addLog(totalCycles, 'MEM', `Load@${key}: loaded value ${instr._loadVal} into R${instr.rd}`, 'memory');
    logMemAccess('LW', addr, instr._loadVal);
    lastMemAccess = { type:'LW', addr, val:instr._loadVal, hit:true, level:'L1' };
    const mEngEl = document.getElementById('memEnglishText');
    if (mEngEl) mEngEl.innerHTML = memToEnglish(lastMemAccess);

    // Sort state tracking - always runs
    if (sortProgramType === 'bubble' && instr._sortMeta) {
      const m = instr._sortMeta;
      if (m.type === 'load_a') sortComparingIdx = [m.j, m.j+1];
      // Display updates only when overlay is open
      if (sortOverlayActive) {
        if (m.type === 'load_a') {
          renderSortBars(m.j, m.j+1, -1, -1, sortSortedUpTo);
          pushNarrative('load',
            `<b>Pass ${m.pass+1}</b> — Loading arr[${m.j}]=${instr._loadVal} into R1`,
            `${m.desc}. Next LW will cause another load-use stall.`,
            [{cls:'load', label:'LW'}, {cls:'stall', label:'STALL NEXT'}]
          );
        } else if (m.type === 'load_b') {
          renderSortBars(m.j, m.j+1, -1, -1, sortSortedUpTo);
          pushNarrative('load',
            `<b>Pass ${m.pass+1}</b> — Loading arr[${m.j+1}]=${instr._loadVal} into R2`,
            `Both values loaded. SLT will compare in the next cycle.`,
            [{cls:'load', label:'LW'}]
          );
        }
      }
    }
  } else if (instr.def.memWrite) {
    let addr = instr._memAddr !== null ? instr._memAddr : (registers[instr.rs1] + instr.imm);
    let key = '0x' + (addr >>> 0).toString(16).toUpperCase();
    let storeVal = registers[instr.rs2];
    // Check for forwarding of store data too
    let fwdData = checkForward(instr.rs2);
    if (fwdData.forward) storeVal = fwdData.value;
    memory[key] = storeVal;
    simulateCacheAccess('dcache', addr, true);
    addLog(totalCycles, 'MEM', `Store@${key}: wrote value ${storeVal} from R${instr.rs2}`, 'memory');
    logMemAccess('SW', addr, storeVal);
    lastMemAccess = { type:'SW', addr, val:storeVal, hit:true, level:'L1' };
    const mEngEl2 = document.getElementById('memEnglishText');
    if (mEngEl2) mEngEl2.innerHTML = memToEnglish(lastMemAccess);
    initDataMem();

    // Sort state tracking - always update sortArray from memory
    if (sortProgramType === 'bubble' && instr._sortMeta) {
      const m = instr._sortMeta;
      const BASE = 0x1000;
      if (m.type === 'swap_a' || m.type === 'swap_b') {
        // Always sync sortArray from memory so state is correct when overlay reopens
        const n = sortArray.length;
        for (let i = 0; i < n; i++) {
          const k = '0x' + (BASE + i*4).toString(16).toUpperCase();
          if (memory[k] !== undefined) sortArray[i] = memory[k];
        }
        if (m.type === 'swap_a') sortSwapCount++;
        // Display updates only when overlay is open
        if (sortOverlayActive) {
          if (m.type === 'swap_a') {
            renderSortBars(-1,-1,m.j,m.j+1,sortSortedUpTo);
            pushNarrative('swap',
              `<b>SWAP!</b> Writing ${storeVal} → arr[${m.j}]`,
              `Second SW will complete the swap next cycle.`,
              [{cls:'swap', label:'SWAP'}, {cls:'store', label:'SW'}]
            );
          } else {
            renderSortBars(-1,-1,m.j,m.j+1,sortSortedUpTo);
            pushNarrative('swap',
              `<b>SWAP complete</b> — arr now: <span class="highlight-yellow">[${sortArray.join(', ')}]</span>`,
              `Both elements exchanged in memory.`,
              [{cls:'swap', label:'SWAP DONE'}, {cls:'store', label:'SW'}]
            );
          }
        }
      }
    }
  }
}

function executeWB(instr) {
  if (instr.def.regWrite && instr.rd !== 0) {
    let val = (instr.def.memRead && instr._loadVal !== undefined) ? instr._loadVal : (instr._result || 0);
    registers[instr.rd] = val;
    flashRegister(instr.rd);
  }
}

// ============================================================
// CACHE SIMULATION
// ============================================================
function simulateCacheAccess(type, addr, write = false) {
  if (typeof addr !== 'number' || isNaN(addr)) return;
  let set = (addr >> 6) & 7;
  let tag = (addr >> 9) & 0xFFFF;
  let cache = type === 'icache' ? icacheData : dcacheData;
  if (!cache || !cache[set]) return;

  let hitWay = -1;
  for (let w = 0; w < cache[set].length; w++) {
    if (cache[set][w].valid && cache[set][w].tag === tag) { hitWay = w; break; }
  }

  if (hitWay >= 0) {
    if (type === 'icache') { icacheHits++; tlbIHits++; }
    else { dcacheHits++; tlbDHits++; if (write) cache[set][hitWay].dirty = true; }
    cache[set][hitWay].lru = 0;
    cache[set].forEach((l, i) => { if (i !== hitWay) l.lru++; });
    cache[set][hitWay].data = '0x' + (addr>>>0).toString(16).padStart(8,'0').toUpperCase().slice(-8);
    setTimeout(() => renderCacheSet(type, set, 'hit', hitWay), 0);
  } else {
    if (type === 'icache') { icacheMisses++; cacheMisses++; l2Hits++; }
    else { dcacheMissesCnt++; cacheMisses++; l2Hits++; }
    let lruWay = 0;
    cache[set].forEach((l, i) => { if (l.lru > cache[set][lruWay].lru) lruWay = i; });
    cache[set][lruWay] = { valid: true, dirty: write, tag, data: '0x'+addr.toString(16).padStart(8,'0').toUpperCase().slice(-8), lru: 0 };
    cache[set].forEach((l, i) => { if (i !== lruWay) l.lru++; });
    setTimeout(() => renderCacheSet(type, set, 'miss', lruWay), 0);
  }
  updateCacheStats();
}

// ============================================================
// INIT
// ============================================================
function init() {
  initRegisters();
  initCache();
  initBTB();
  initROB();
  initTLB();
  initDataMem();
  renderTimingHeader();
  updateAll();
}

function initRegisters() {
  registers = new Array(32).fill(0);
  registers[0] = 0;
  registers[1] = 0x00000008;
  registers[2] = 0x7FFFFFFC;
  registers[8] = 0x00001000;
  registers[10] = 5;
  registers[11] = 3;
  renderRegisters();
}

function initCache() {
  icacheData = [];
  for (let s = 0; s < 8; s++) {
    let set = [];
    for (let w = 0; w < 8; w++) set.push({ valid: false, dirty: false, tag: 0, data: '—', lru: w });
    icacheData.push(set);
  }
  dcacheData = [];
  for (let s = 0; s < 8; s++) {
    let set = [];
    for (let w = 0; w < 8; w++) set.push({ valid: false, dirty: false, tag: 0, data: '—', lru: w });
    dcacheData.push(set);
  }
  renderCache();
}

function initBTB() {
  btbEntries = [];
  for (let i = 0; i < 16; i++) btbEntries.push({ valid: false, tag: 0, target: 0, state: 'WT', count: 0 });
  renderBTB();
}

function initROB() {
  rob = [];
  for (let i = 0; i < 16; i++) rob.push({ valid: false, instr: '—', dest: -1, value: 0, state: 'EMPTY' });
  rsList = [];
  rat = new Array(32).fill(-1);
  renderROB();
  renderRS();
  renderRAT();
}

function initTLB() {
  document.getElementById('tlbTableBody').innerHTML =
    `<tr><td class="mono c-text3">0x0000</td><td class="mono c-accent2">0x0000</td><td class="c-green">1</td><td class="c-text3">0</td><td class="c-text3">RX</td></tr>
     <tr><td class="mono c-text3">0x7FFF</td><td class="mono c-accent2">0x7FFF</td><td class="c-green">1</td><td class="c-orange">1</td><td class="c-text3">RW</td></tr>
     <tr><td class="mono c-text3">0x1000</td><td class="mono c-accent2">0x1000</td><td class="c-green">1</td><td class="c-orange">1</td><td class="c-text3">RW</td></tr>`;
}

function initDataMem() {
  let body = document.getElementById('dataMemBody');
  if (!body) return;
  body.innerHTML = '';
  for (let i = 0; i < 16; i++) {
    let addr = 0x1000 + i*4;
    let key = '0x' + addr.toString(16).toUpperCase();
    let val = memory[key] !== undefined ? memory[key] : 0;
    body.innerHTML += `<tr><td class="mono c-text3">0x${addr.toString(16).padStart(8,'0').toUpperCase()}</td><td class="mono c-purple">0x${(val>>>0).toString(16).padStart(8,'0').toUpperCase()}</td><td class="mono c-text2">${val}</td></tr>`;
  }
}

// ============================================================
// PROGRAMS
// ============================================================
const PROGRAMS = {
  hazards: [
    'ADD R1,R2,R3',
    'ADD R4,R1,R3',
    'SUB R5,R1,R4',
    'AND R6,R5,R2',
    'LW R7,0(R8)',
    'ADD R9,R7,R1',
    'OR R10,R9,R6',
    'SW R10,4(R2)',
    'BEQ R1,R2,8',
    'ADD R11,R1,R2',
    'SUB R12,R11,R3',
  ],
};

function loadProgram(name) {
  instrQueue = [];
  let prog = PROGRAMS[name] || [];
  prog.forEach(s => {
    let p = parseInstr(s);
    if (p) instrQueue.push(p);
  });
  instructionMemory = [...instrQueue];
  updateInstrQueueDisplay();
  updateMemoryTable();
  addLog(0, 'PROG', `Loaded: ${name.toUpperCase()} (${instrQueue.length} instrs)`, 'writeback');
}

// ============================================================
// RENDER FUNCTIONS
// ============================================================
function renderRegisters() {
  let grid = document.getElementById('registerGrid');
  if (!grid) return;
  grid.innerHTML = '';
  for (let i = 0; i < 32; i++) {
    let hex = (registers[i]>>>0).toString(16).padStart(8,'0').toUpperCase();
    grid.innerHTML += `<div class="reg-item" id="reg-${i}">
      <span class="reg-name">R${i}<span style="font-size:8px;color:var(--text3);"> ${REG_NAMES[i]}</span></span>
      <span class="reg-val" id="reg-val-${i}">0x${hex}</span>
    </div>`;
  }
}

function flashRegister(idx) {
  let el = document.getElementById('reg-'+idx);
  let valEl = document.getElementById('reg-val-'+idx);
  if (el) {
    el.className = 'reg-item written';
    let hex = (registers[idx]>>>0).toString(16).padStart(8,'0').toUpperCase();
    if (valEl) valEl.textContent = '0x'+hex;
    setTimeout(() => { if (el) el.className = 'reg-item'; }, 600);
  }
}

function updatePipelineStages() {
  const stageMap = { IF:'IF', ID:'ID', EX:'EX', MEM:'MEM', WB:'WB' };
  Object.keys(stageMap).forEach(s => {
    let el = document.getElementById('stage'+s);
    let instr = pipeline[s];
    let instrEl = document.getElementById('stage'+s+'-instr');
    if (!el || !instrEl) return;
    if (!instr) {
      el.className = 'stage';
      instrEl.textContent = '—';
    } else if (instr.isBubble) {
      el.className = 'stage stall';
      instrEl.textContent = 'NOP';
    } else {
      el.className = 'stage occupied';
      instrEl.textContent = instr.mnem;
    }
  });

  // Verbose pipeline register cards
  updatePRCard('IFID',  pipeline.IF,  'IF',  'prIF_ID_val');
  updatePRCard('IDEX',  pipeline.ID,  'ID',  'prID_EX_val');
  updatePRCard('EXMEM', pipeline.EX,  'EX',  'prEX_MEM_val');
  updatePRCard('MEMWB', pipeline.MEM, 'MEM', 'prMEM_WB_val');
}

// ─── HUMAN-READABLE REGISTER NAMES ─────────────────────────────────────────
const REG_ABI = ['zero','ra','sp','gp','tp','t0','t1','t2','s0/fp','s1','a0','a1','a2','a3','a4','a5','a6','a7','s2','s3','s4','s5','s6','s7','s8','s9','s10','s11','t3','t4','t5','t6'];
function rn(r) { return `R${r}<span style="font-size:8px;opacity:0.6;">(${REG_ABI[r]||'?'})</span>`; }
function hex(v) { return '0x'+(v>>>0).toString(16).padStart(8,'0').toUpperCase(); }
function dec(v) { return (v|0).toString(); }

// ─── PLAIN-ENGLISH DESCRIPTION PER INSTRUCTION+STAGE ────────────────────────
// ============================================================
// PLAIN ENGLISH EXPLANATION GENERATORS
// ============================================================

function instrToEnglish(instr) {
  if (!instr || !instr.def) return '';
  const rd  = instr.rd  !== undefined ? 'R' + instr.rd  + (REG_NAMES[instr.rd]  ? ' ('+REG_NAMES[instr.rd]+')' : '') : '';
  const rs1 = instr.rs1 !== undefined ? 'R' + instr.rs1 + (REG_NAMES[instr.rs1] ? ' ('+REG_NAMES[instr.rs1]+')' : '') : '';
  const rs2 = instr.rs2 !== undefined ? 'R' + instr.rs2 + (REG_NAMES[instr.rs2] ? ' ('+REG_NAMES[instr.rs2]+')' : '') : '';
  const imm = instr.imm !== undefined ? instr.imm : 0;
  const rv1 = registers[instr.rs1] || 0;
  const rv2 = registers[instr.rs2] || 0;

  const m = instr.mnem;
  if (m === 'ADD')  return `<b>Add:</b> Take the value in ${rs1} (currently <span class="c-accent">${rv1}</span>) and add it to ${rs2} (currently <span class="c-accent">${rv2}</span>). Store the result <span class="c-green">${rv1+rv2}</span> in ${rd}.`;
  if (m === 'SUB')  return `<b>Subtract:</b> Take ${rs1} (<span class="c-accent">${rv1}</span>) and subtract ${rs2} (<span class="c-accent">${rv2}</span>). Store the result <span class="c-green">${rv1-rv2}</span> in ${rd}.`;
  if (m === 'MUL')  return `<b>Multiply:</b> Multiply ${rs1} (<span class="c-accent">${rv1}</span>) × ${rs2} (<span class="c-accent">${rv2}</span>). Store the lower 32 bits of the result in ${rd}.`;
  if (m === 'AND')  return `<b>Bitwise AND:</b> Compare each bit of ${rs1} and ${rs2}. A result bit is 1 only if <i>both</i> source bits are 1. Useful for masking — setting certain bits to zero.`;
  if (m === 'OR')   return `<b>Bitwise OR:</b> Compare each bit of ${rs1} and ${rs2}. A result bit is 1 if <i>either</i> bit is 1. Useful for setting specific bits.`;
  if (m === 'XOR')  return `<b>Bitwise XOR:</b> Compare each bit of ${rs1} and ${rs2}. A result bit is 1 if the two bits are <i>different</i>. XOR with all-1s flips all bits (bitwise NOT).`;
  if (m === 'SLL')  return `<b>Shift Left:</b> Shift all bits in ${rs1} left by ${rs2 !== 'R0 (zero)' ? rs2 : imm} positions, filling with zeros on the right. Each left-shift by 1 doubles the value.`;
  if (m === 'SRL')  return `<b>Logical Shift Right:</b> Shift all bits in ${rs1} right by ${imm} positions, filling with zeros on the left. Each right-shift by 1 halves the value (for unsigned numbers).`;
  if (m === 'SRA')  return `<b>Arithmetic Shift Right:</b> Like SRL, but fills with the <i>sign bit</i> (leftmost bit) instead of zeros. Correctly divides signed numbers by powers of two.`;
  if (m === 'SLT')  return `<b>Set Less Than:</b> Is ${rs1} (<span class="c-accent">${rv1}</span>) less than ${rs2} (<span class="c-accent">${rv2}</span>)? If yes, write <span class="c-green">1</span> into ${rd}. If no, write <span class="c-red">0</span>. Used to build if-then logic.`;
  if (m === 'SLTU') return `<b>Set Less Than (Unsigned):</b> Same as SLT but treats both values as unsigned (no negatives). Is ${rv1>>>0} less than ${rv2>>>0}? Write 1 or 0 into ${rd}.`;
  if (m === 'ADDI') return `<b>Add Immediate:</b> Take ${rs1} (<span class="c-accent">${rv1}</span>) and add the constant <span class="c-yellow">${imm}</span> directly (no second register needed). Store the result <span class="c-green">${rv1+imm}</span> in ${rd}. The constant is baked into the instruction.`;
  if (m === 'ANDI') return `<b>AND Immediate:</b> Bitwise AND ${rs1} with the constant <span class="c-yellow">${imm}</span>. Useful for extracting specific bits from a value (masking).`;
  if (m === 'ORI')  return `<b>OR Immediate:</b> Bitwise OR ${rs1} with the constant <span class="c-yellow">${imm}</span>. Useful for forcing specific bits to 1.`;
  if (m === 'XORI') return `<b>XOR Immediate:</b> Bitwise XOR ${rs1} with the constant <span class="c-yellow">${imm}</span>. If the immediate is -1 (all 1s), this inverts every bit.`;
  if (m === 'LW')   return `<b>Load Word:</b> Compute the memory address ${rs1} + ${imm} = <span class="c-accent">${rv1+imm}</span>. Go to that address in RAM and read 4 bytes. Put the value found there into ${rd}. This <i>always</i> causes a 1-cycle load-use stall if the next instruction needs ${rd}.`;
  if (m === 'SW')   return `<b>Store Word:</b> Compute the address ${rs1} + ${imm} = <span class="c-accent">${rv1+imm}</span>. Write the current value of ${rs2} (<span class="c-accent">${rv2}</span>) to that address in memory. SW does <i>not</i> write any register — it only changes memory.`;
  if (m === 'BEQ')  { const eq = rv1===rv2; return '<b>Branch if Equal:</b> Compare '+rs1+' ('+rv1+') and '+rs2+' ('+rv2+'). '+(eq ? '<span class="c-green">Equal &#8212; jumping forward '+imm+' bytes to the target.</span>' : '<span class="c-red">Not equal &#8212; no jump, continuing forward.</span>'); }
  if (m === 'BNE')  { const ne = rv1!==rv2; return '<b>Branch if Not Equal:</b> Compare '+rs1+' ('+rv1+') and '+rs2+' ('+rv2+'). '+(ne ? '<span class="c-green">Different &#8212; jumping '+imm+' bytes.</span>' : '<span class="c-red">Equal &#8212; no jump.</span>'); }
  if (m === 'BLT')  { const lt = rv1<rv2;  return '<b>Branch if Less Than:</b> Is '+rs1+' ('+rv1+') less than '+rs2+' ('+rv2+')? '+(lt ? '<span class="c-green">Yes &#8212; jumping '+imm+' bytes.</span>' : '<span class="c-red">No &#8212; no jump.</span>'); }
  if (m === 'BGE')  { const ge = rv1>=rv2; return '<b>Branch if Greater/Equal:</b> Is '+rs1+' ('+rv1+') >= '+rs2+' ('+rv2+')? '+(ge ? '<span class="c-green">Yes &#8212; jumping '+imm+' bytes.</span>' : '<span class="c-red">No &#8212; no jump.</span>'); }

  if (m === 'NOP' || (instr.isBubble)) return `<b>NOP / Bubble:</b> This is a "do nothing" placeholder. The CPU inserted it to create a 1-cycle gap in the pipeline — usually to resolve a load-use stall. No register is read or written.`;
  return `<b>${m}:</b> ${instr.raw} — executing the ${m} operation on the current operands.`;
}

function aluToEnglish(instr, opA, opB, result, fwdA, fwdB) {
  if (!instr || !instr.def) return '';
  const m = instr.mnem;
  const fwdNote = (fwdA.forward || fwdB.forward)
    ? ' <span style="color:var(--green); font-size:10px;">(operand' + (fwdA.forward && fwdB.forward ? 's' : '') + ' forwarded — no stall needed)</span>'
    : '';
  const isLoad = instr.def.memRead;
  const isStore = instr.def.memWrite;
  const isBranch = instr.def.branch;

  if (isLoad)  return `The ALU is computing the <b>memory address</b> to read from: ${instr.rs1 !== 0 ? 'R'+instr.rs1+'='+opA : 'base 0'} + offset ${instr.imm} = <span class="c-green">${result}</span> (0x${(result>>>0).toString(16).toUpperCase()}). The actual data fetch happens in the <b>Memory stage</b> next cycle.` + fwdNote;
  if (isStore) return `The ALU is computing the <b>memory address</b> to write to: R${instr.rs1}=${opA} + offset ${instr.imm} = <span class="c-green">${result}</span>. Next cycle the Memory stage will write R${instr.rs2}=${opB} to that address.` + fwdNote;
  if (isBranch) return '<b>Branch comparison:</b> Left: <span class="c-accent">'+opA+'</span> vs Right: <span class="c-accent">'+opB+'</span>. Result = <span class="c-green">'+result+'</span>. '+(result===0 ? 'Equal (zero flag set).' : 'Not equal.')+' Branch target: 0x'+((opA + instr.imm)>>>0).toString(16).toUpperCase()+'.'+fwdNote;
  return `The ALU is performing <b>${instr.def.aluOp}</b>: <span class="c-accent">${opA}</span> ${instr.def.aluOp} <span class="c-accent">${opB}</span> = <span class="c-green">${result}</span>. This result will be written to R${instr.rd} when the instruction reaches the Writeback stage.` + fwdNote;
}

function branchFSMToEnglish(state, lastBranch) {
  const stateDesc = {
    SN: 'Strongly Not Taken — the predictor is very confident it should <b>not</b> jump. It has seen multiple "not taken" outcomes in a row. It takes 2 consecutive "taken" results to move toward predicting taken.',
    WN: 'Weakly Not Taken — the predictor leans toward <b>not jumping</b>, but one "taken" result will flip it to predict taken next time.',
    WT: 'Weakly Taken — the predictor leans toward <b>jumping</b>, but one "not taken" result will flip it to predict not-taken.',
    ST: 'Strongly Taken — the predictor is very confident it should jump. It has seen multiple "taken" branches in a row. Common in tight loops.',
  };
  const predicting = (state === 'WT' || state === 'ST') ? 'TAKEN (will jump)' : 'NOT TAKEN (won\'t jump)';
  let last = lastBranch ? ' Last branch: <b>' + lastBranch.instr + '</b> was ' + (lastBranch.taken ? 'taken' : 'not taken') + (lastBranch.predicted !== lastBranch.taken ? ' — <span class="c-red">MISPREDICTED</span>, pipeline flushed 2 instructions.' : ' — <span class="c-green">predicted correctly</span>.') : '';
  return stateDesc[state] + '<br>Current prediction: <span class="c-yellow">' + predicting + '</span>.' + last;
}

function memToEnglish(lastAccess) {
  if (!lastAccess) return 'Waiting for memory accesses. When a LW or SW instruction runs, check which cache level it hit and how many cycles it cost.';
  const { type, addr, val, hit, level } = lastAccess;
  const hitStr = hit ? '<span class="c-green">HIT</span>' : '<span class="c-red">MISS</span>';
  const levelStr = level === 'L1' ? 'L1 cache (1 cycle — fastest)' : level === 'L2' ? 'L2 cache (~10 cycles)' : 'main memory (200+ cycles — slow!)';
  if (type === 'LW') return `Last operation: <b>Load</b> from address <span class="c-accent">0x${(addr>>>0).toString(16).toUpperCase()}</span>. Cache ${hitStr} in ${levelStr}. Value read: <span class="c-green">${val}</span>. This value was placed into the destination register at Writeback.`;
  if (type === 'SW') return `Last operation: <b>Store</b> of value <span class="c-accent">${val}</span> to address <span class="c-accent">0x${(addr>>>0).toString(16).toUpperCase()}</span>. Cache ${hitStr} in ${levelStr}. The cache line is now marked <b>dirty</b> — it will be written back to DRAM only when evicted.`;
  return 'Waiting for the next load or store instruction.';
}

function describeInstr(instr, stage) {
  if (!instr || !instr.def) return { what: '—', detail: '' };
  const m = instr.mnem;
  const rd = instr.rd, rs1 = instr.rs1, rs2 = instr.rs2, imm = instr.imm;
  const vrd  = registers[rd]  || 0;
  const vrs1 = registers[rs1] || 0;
  const vrs2 = registers[rs2] || 0;

  // Check forwarding state
  const fwdA = checkForward(rs1);
  const fwdB = checkForward(rs2);

  let what = '', detail = '', tags = [];

  if (stage === 'IF') {
    what = `CPU is <b>fetching</b> <span class="pr-instr">${instr.raw}</span> from instruction memory at address <span class="pr-val">${hex(pc - (instrQueue.length >= 0 ? 0 : 4))}</span>.`;
    detail = `This is the first step — the CPU reads the binary encoding of the instruction. No computation yet. The instruction will be decoded in the next cycle.`;
    tags = [{cls:'pr-tag-info', l:'FETCH'}];
  } else if (stage === 'ID') {
    if (m === 'NOP' || instr.isBubble) {
      what = `A <span class="pr-stall">NOP bubble</span> is sitting here. This is a <b>placeholder</b> — not a real instruction.`;
      detail = `A bubble was inserted to create a one-cycle gap between a load instruction and the instruction that needs its result. The CPU is essentially doing nothing useful this cycle in the Decode stage.`;
      tags = [{cls:'pr-tag-warn', l:'BUBBLE'}, {cls:'pr-tag-warn', l:'STALL ARTIFACT'}];
    } else if (instr.def.type === 'R') {
      what = `<b>Decoding</b> <span class="pr-instr">${instr.raw}</span>: add/combine <span class="pr-reg">${rn(rs1)}</span> (currently <span class="pr-val">${dec(vrs1)}</span>) and <span class="pr-reg">${rn(rs2)}</span> (currently <span class="pr-val">${dec(vrs2)}</span>), write result to <span class="pr-reg">${rn(rd)}</span>.`;
      detail = `The CPU identifies this as an R-type instruction — it uses two source registers. The register file is being read right now to get the input values.`;
      tags = [{cls:'pr-tag-info', l:'R-TYPE'}, {cls:'pr-tag-info', l:'ALU OP'}];
    } else if (instr.def.memRead) {
      what = `<b>Decoding</b> <span class="pr-instr">${instr.raw}</span>: load a value from memory address <span class="pr-reg">${rn(rs1)}</span>+<span class="pr-val">${imm}</span> into <span class="pr-reg">${rn(rd)}</span>.`;
      detail = `⚠ If the instruction after this one needs register ${rn(rd)}, a 1-cycle stall will be inserted — the load result won't be available until after the Memory stage.`;
      tags = [{cls:'pr-tag-mem', l:'LOAD'}, {cls:'pr-tag-warn', l:'STALL RISK'}];
    } else if (instr.def.memWrite) {
      what = `<b>Decoding</b> <span class="pr-instr">${instr.raw}</span>: store the value of <span class="pr-reg">${rn(rs2)}</span> (currently <span class="pr-val">${dec(vrs2)}</span>) into memory at address <span class="pr-reg">${rn(rs1)}</span>+<span class="pr-val">${imm}</span>.`;
      detail = `Store instructions don't write to a register — they write to memory. The address calculation happens in Execute next cycle.`;
      tags = [{cls:'pr-tag-mem', l:'STORE'}, {cls:'pr-tag-info', l:'S-TYPE'}];
    } else if (instr.def.branch) {
      what = `<b>Decoding</b> <span class="pr-instr">${instr.raw}</span>: compare <span class="pr-reg">${rn(rs1)}</span> and <span class="pr-reg">${rn(rs2)}</span>. If the condition is true, jump ${imm > 0 ? 'forward' : 'backward'} by <span class="pr-val">${imm}</span> bytes.`;
      detail = `Branch instructions don't know if they'll be taken until Execute. The branch predictor has already guessed — if it was wrong, 2 instructions will be flushed.`;
      tags = [{cls:'pr-tag-warn', l:'BRANCH'}, {cls:'pr-tag-info', l:'B-TYPE'}];
    } else {
      what = `<b>Decoding</b> <span class="pr-instr">${instr.raw}</span>: compute <span class="pr-reg">${rn(rs1)}</span> ${m} <span class="pr-val">${imm}</span>, result → <span class="pr-reg">${rn(rd)}</span>.`;
      detail = `I-type instruction — uses one source register and an immediate constant embedded in the instruction word.`;
      tags = [{cls:'pr-tag-info', l:'I-TYPE'}];
    }
  } else if (stage === 'EX') {
    if (instr.isBubble) {
      what = `A <span class="pr-stall">NOP bubble</span> is passing through Execute. Nothing is computed.`;
      detail = `This bubble was inserted earlier to prevent a data hazard. It's harmless — it won't change any registers or memory.`;
      tags = [{cls:'pr-tag-warn', l:'BUBBLE'}];
    } else {
      const fwdNote = fwdA.forward ? ` (value forwarded from ${fwdA.source} — no stall needed!)` : fwdB.forward ? ` (value forwarded from ${fwdB.source})` : '';
      const result = instr._result !== undefined ? dec(instr._result) : '?';
      if (instr.def.memRead) {
        what = `<b>Executing</b> <span class="pr-instr">${instr.raw}</span>: the ALU computes the memory address = <span class="pr-reg">${rn(rs1)}</span> + <span class="pr-val">${imm}</span>${fwdNote}. Result address is being passed to the Memory stage.`;
        detail = `Load instructions use the ALU only to calculate the address. The actual data fetch happens in the next stage (MEM).`;
        tags = [{cls:'pr-tag-mem', l:'ADDR CALC'}, fwdA.forward ? {cls:'pr-tag-fwd', l:'FORWARDED'} : {cls:'pr-tag-info', l:'REG READ'}];
      } else if (instr.def.memWrite) {
        what = `<b>Executing</b> <span class="pr-instr">${instr.raw}</span>: computing store address = <span class="pr-reg">${rn(rs1)}</span> + <span class="pr-val">${imm}</span>. Will write value <span class="pr-val">${dec(vrs2)}</span> to that address next cycle.`;
        detail = `The ALU calculates where in memory to write. The actual write happens in the MEM stage.`;
        tags = [{cls:'pr-tag-mem', l:'ADDR CALC'}, {cls:'pr-tag-info', l:'STORE PREP'}];
      } else if (instr.def.branch) {
        what = `<b>Executing</b> <span class="pr-instr">${instr.raw}</span>: comparing <span class="pr-reg">${rn(rs1)}</span> and <span class="pr-reg">${rn(rs2)}</span>. Branch target would be <span class="pr-addr">${hex(pc + imm - 4)}</span>.`;
        detail = instr._branchTaken !== undefined ? `Branch outcome: ${instr._branchTaken ? '✓ TAKEN — jumping to target' : '✗ NOT TAKEN — continuing to next instruction'}.` : `Branch condition being evaluated this cycle.`;
        tags = [{cls:'pr-tag-warn', l:'BRANCH EVAL'}];
      } else {
        what = '<b>Executing</b> <span class="pr-instr">' + instr.raw + '</span>: the ALU computes the result = <span class="pr-val">' + result + '</span>' + (fwdA.forward ? ' <span class="pr-fwd">(operand forwarded from ' + fwdA.source + ')</span>' : '') + (fwdB.forward ? ' <span class="pr-fwd">(operand B forwarded from ' + fwdB.source + ')</span>' : '') + '.';
        detail = `This result will be saved to register <span class="pr-reg">${rn(rd)}</span> when the instruction reaches the Writeback stage. If the next instruction needs this value, the forwarding unit will supply it directly — no stall needed.`;
        tags = [fwdA.forward||fwdB.forward ? {cls:'pr-tag-fwd', l:'FORWARDING ACTIVE'} : {cls:'pr-tag-ok', l:'READY'}, {cls:'pr-tag-info', l:instr.def.aluOp}];
      }
    }
  } else if (stage === 'MEM') {
    if (instr.isBubble) {
      what = `A <span class="pr-stall">NOP bubble</span> passing through the Memory stage. No memory access.`;
      detail = `Nothing to do — this was a stall placeholder.`;
      tags = [{cls:'pr-tag-warn', l:'BUBBLE'}];
    } else if (instr.def.memRead) {
      const addr = instr._memAddr !== null && instr._memAddr !== undefined ? hex(instr._memAddr) : `${rn(rs1)}+${imm}`;
      const loaded = instr._loadVal !== undefined ? dec(instr._loadVal) : '?';
      what = `<b>Memory access</b>: reading from address <span class="pr-addr">${addr}</span>. Value loaded: <span class="pr-val">${loaded}</span>. This value will be written to <span class="pr-reg">${rn(rd)}</span> next cycle.`;
      detail = `The data cache is being queried. If it's a cache hit (1 cycle), the value is available immediately. This loaded value can be forwarded directly to any instruction in Execute that needs it — resolving the earlier load-use stall.`;
      tags = [{cls:'pr-tag-mem', l:'D-CACHE READ'}, {cls:'pr-tag-fwd', l:'MEM/WB FORWARD READY'}];
    } else if (instr.def.memWrite) {
      const addr = instr._memAddr !== null && instr._memAddr !== undefined ? hex(instr._memAddr) : `${rn(rs1)}+${imm}`;
      const storeVal = registers[rs2] || 0;
      what = `<b>Memory write</b>: storing <span class="pr-val">${dec(storeVal)}</span> (from <span class="pr-reg">${rn(rs2)}</span>) → address <span class="pr-addr">${addr}</span> in the data cache.`;
      detail = `The value is written to the cache now. If this cache line was recently loaded, it's marked "dirty" and will eventually be written back to main memory.`;
      tags = [{cls:'pr-tag-mem', l:'D-CACHE WRITE'}];
    } else {
      const result = instr._result !== undefined ? dec(instr._result) : '?';
      what = `<b>Passing through</b> Memory stage: <span class="pr-instr">${instr.raw}</span> — no memory access needed. Result <span class="pr-val">${result}</span> is held in the EX/MEM register, ready for writeback.`;
      detail = `Most ALU instructions (ADD, SUB, AND, etc.) don't touch memory. They simply pass through this stage unchanged.`;
      tags = [{cls:'pr-tag-ok', l:'PASS-THROUGH'}, {cls:'pr-tag-info', l:'NO MEM ACCESS'}];
    }
  }

  return { what, detail, tags };
}

// ─── UPDATE ONE PIPELINE REGISTER CARD ──────────────────────────────────────
function updatePRCard(cardId, instr, stage, nameId) {
  const card = document.getElementById('prCard-' + cardId);
  const nameEl = document.getElementById(nameId);
  const bodyEl = document.getElementById('prCard-' + cardId + '-body');
  if (!card || !bodyEl) return;

  if (!instr) {
    if (nameEl) nameEl.textContent = 'EMPTY';
    card.className = 'pr-card';
    bodyEl.innerHTML = `<div class="pr-empty-msg">This slot is empty — no instruction is here right now.</div>`;
    return;
  }

  if (nameEl) nameEl.textContent = instr.isBubble ? 'NOP BUBBLE' : instr.raw;

  card.className = 'pr-card ' + (instr.isBubble ? 'bubble' : 'active');

  const { what, detail, tags } = describeInstr(instr, stage);

  var tagsHtml = (tags && tags.length) ? '<div class="pr-tags">' + tags.filter(Boolean).map(function(t){ return '<div class="pr-tag ' + t.cls + '">' + t.l + '</div>'; }).join('') + '</div>' : '';
  bodyEl.innerHTML = '<div class="pr-what">' + what + '</div>' + (detail ? '<div class="pr-detail">' + detail + '</div>' : '') + tagsHtml;
}

function updateDecode(instr) {
  if (!instr || !instr.def) return;
  document.getElementById('decodeBadge').textContent = instr.type + '-TYPE';

  let bits = instr.encoding;
  let bitsRow = document.getElementById('bitsRow');
  if (!bitsRow) return;
  bitsRow.innerHTML = '';

  let groups = [];
  if (instr.def.type === 'R') {
    groups = [
      { start:25, end:31, cls:'funct7', label:'funct7' },
      { start:20, end:24, cls:'rs2', label:'rs2' },
      { start:15, end:19, cls:'rs1', label:'rs1' },
      { start:12, end:14, cls:'funct3', label:'funct3' },
      { start:7,  end:11, cls:'rd', label:'rd' },
      { start:0,  end:6,  cls:'opcode', label:'opcode' },
    ];
  } else {
    groups = [
      { start:20, end:31, cls:'funct7', label:'imm[11:0]' },
      { start:15, end:19, cls:'rs1', label:'rs1' },
      { start:12, end:14, cls:'funct3', label:'funct3' },
      { start:7,  end:11, cls:'rd', label:'rd' },
      { start:0,  end:6,  cls:'opcode', label:'opcode' },
    ];
  }

  groups.forEach(g => {
    let div = document.createElement('div');
    div.className = `bit-group ${g.cls}`;
    let cells = document.createElement('div');
    cells.className = 'bit-cells';
    let slice = bits.slice(31-g.end, 32-g.start);
    for (let b of slice) {
      let c = document.createElement('div');
      c.className = `bit-cell ${b==='1'?'one':''}`;
      c.textContent = b;
      cells.appendChild(c);
    }
    let lbl = document.createElement('div');
    lbl.className = 'bit-group-label';
    lbl.textContent = g.label;
    div.appendChild(cells);
    div.appendChild(lbl);
    bitsRow.appendChild(div);
  });

  setText('df-opcode', '0b'+instr.def.opcode);
  setText('df-opcode-type', instr.def.type+'-TYPE');
  setText('df-rd', 'R'+instr.rd);
  setText('df-rd-name', REG_NAMES[instr.rd]||'r'+instr.rd);
  setText('df-funct3', '0b'+(instr.def.funct3||'000'));
  setText('df-funct3-op', instr.def.aluOp||'—');
  setText('df-rs1', 'R'+instr.rs1);
  setText('df-rs1-val', `val=${registers[instr.rs1]}`);
  setText('df-rs2', 'R'+instr.rs2);
  setText('df-rs2-val', `val=${registers[instr.rs2]}`);
  setText('df-funct7', instr.def.funct7 || '—');
  setText('df-funct7-sub', instr.def.type==='I'?'(imm extension)':'funct7');

  const sigs = {
    regwrite: !!instr.def.regWrite,
    memread: !!instr.def.memRead,
    memwrite: !!instr.def.memWrite,
    branch: !!instr.def.branch,
    jump: !!instr.def.jump,
    alusrc: instr.def.type !== 'R',
    memtoreg: !!instr.def.memRead,
    aluzero: false,
    unsigned: instr.mnem === 'SLTU' || instr.mnem === 'BLTU',
  };
  Object.keys(sigs).forEach(k => {
    let el = document.getElementById('cs-'+k);
    if (el) el.className = 'ctrl-sig ' + (sigs[k] ? 'on' : 'off');
  });

  let immTypes = { R:'—', I:'I-type', L:'I-type (load)', S:'S-type', B:'B-type', J:'J-type', U:'U-type' };
  setText('immType', immTypes[instr.def.type] || '—');
  setText('immVal', instr.imm !== undefined ? instr.imm.toString() : '—');
  setText('immSext', instr.imm !== undefined ? '0x'+(instr.imm>>>0).toString(16).padStart(8,'0').toUpperCase() : '—');

  // Plain-English explanation
  const engBox = document.getElementById('instrEnglishBox');
  const engText = document.getElementById('instrEnglishText');
  if (engBox && engText) {
    const eng = instrToEnglish(instr);
    if (eng) { engText.innerHTML = eng; engBox.style.display = ''; }
    else { engBox.style.display = 'none'; }
  }
}

function updateALUDisplay(instr, opA, opB, result, fwdA, fwdB) {
  let body = document.getElementById('aluBody');
  if (body) { body.setAttribute('stroke', 'var(--accent)'); body.setAttribute('fill', '#0a1428'); }
  let active = document.getElementById('aluActive');
  if (active) active.setAttribute('fill', 'var(--green)');
  let lbl = document.getElementById('aluActiveLabel');
  if (lbl) { lbl.textContent = 'ACTIVE'; lbl.setAttribute('fill', 'var(--green)'); }

  const setS = (id, val, color) => {
    let el = document.getElementById(id);
    if (el) { el.textContent = val; if (color) el.setAttribute('fill', color); }
  };
  setS('aluResultText', '0x'+(result>>>0).toString(16).padStart(8,'0').toUpperCase(), 'var(--green)');
  setS('opAText', '0x'+(opA>>>0).toString(16).padStart(8,'0').toUpperCase(), 'var(--accent)');
  setS('opBText', '0x'+(opB>>>0).toString(16).padStart(8,'0').toUpperCase(), 'var(--accent2)');
  setS('aluOpText', instr.def.aluOp||'—', 'var(--yellow)');
  setS('rs1Label', 'R'+instr.rs1, fwdA.forward ? 'var(--green)' : '#7090b0');
  setS('rs2Label', 'R'+instr.rs2, fwdB.forward ? 'var(--green)' : '#7090b0');

  let zero = result === 0 ? 1 : 0;
  let neg = (result >> 31) & 1;
  setS('flagZero', zero, zero ? 'var(--green)' : '#405070');
  setS('flagNeg', neg, neg ? 'var(--red)' : '#405070');
  setS('flagOvfl', '0', '#405070');
  setS('flagCarry', '0', '#405070');
  setS('branchTargetText', instr.def.branch ? '0x'+(programCounter+instr.imm-4>>>0).toString(16).padStart(8,'0').toUpperCase() : 'N/A', '#405070');

  setText('currentExecInstr', instr.raw);
  setText('execOpA', '0x'+(opA>>>0).toString(16).padStart(8,'0').toUpperCase() + ' ('+opA+')' + (fwdA.forward ? ' [FWD]' : ''));
  setText('execOpB', '0x'+(opB>>>0).toString(16).padStart(8,'0').toUpperCase() + ' ('+opB+')' + (fwdB.forward ? ' [FWD]' : ''));
  setText('execResult', '0x'+(result>>>0).toString(16).padStart(8,'0').toUpperCase() + ' ('+result+')');
  setText('execOp', instr.def.aluOp);

  ['add','sub','and','or','xor','sll','srl','sra','slt','sltu','mul','div'].forEach(op => {
    let el = document.getElementById('alu-'+op);
    if (el) el.className = 'ctrl-sig ' + (instr.def.aluOp && instr.def.aluOp.toLowerCase() === op ? 'on' : '');
  });

  // Plain-English ALU explanation
  const aluEngBox = document.getElementById('aluEnglishBox');
  const aluEngText = document.getElementById('aluEnglishText');
  if (aluEngBox && aluEngText) {
    aluEngText.innerHTML = aluToEnglish(instr, opA, opB, result, fwdA, fwdB);
    aluEngBox.style.display = '';
  }

  // Forwarding display
  let fwdEXEl = document.getElementById('fwd-EX_MEM');
  let fwdMEMEl = document.getElementById('fwd-MEM_WB');
  if (fwdEXEl) fwdEXEl.className = 'fwd-path' + (fwdA.source === 'EX/MEM' || fwdB.source === 'EX/MEM' ? ' active' : '');
  if (fwdMEMEl) fwdMEMEl.className = 'fwd-path' + (fwdA.source === 'MEM/WB' || fwdB.source === 'MEM/WB' ? ' active' : '');
}

function renderCacheSet(type, setIdx, outcome, wayIdx) {
  let el = document.getElementById(type === 'icache' ? 'icacheVisual' : 'dcacheVisual');
  if (!el) return;
  let setEls = el.querySelectorAll('.cache-set');
  if (setEls[setIdx]) {
    let lines = setEls[setIdx].querySelectorAll('.cache-line');
    if (lines[wayIdx]) {
      lines[wayIdx].className = 'cache-line valid ' + outcome;
      setTimeout(() => { if (lines[wayIdx]) lines[wayIdx].className = 'cache-line valid'; }, 1000);
    }
  }
}

function renderCache() {
  ['icache','dcache'].forEach(type => {
    let cache = type === 'icache' ? icacheData : dcacheData;
    let container = document.getElementById(type === 'icache' ? 'icacheVisual' : 'dcacheVisual');
    if (!container) return;
    container.innerHTML = '';
    cache.forEach((set, s) => {
      let setDiv = document.createElement('div');
      setDiv.className = 'cache-set';
      setDiv.innerHTML = `<div class="cache-set-label">Set ${s}</div>`;
      set.slice(0,4).forEach((line, w) => {
        let lineDiv = document.createElement('div');
        lineDiv.className = `cache-line ${line.valid ? 'valid' : ''}`;
        lineDiv.innerHTML = `<div class="cl-v ${line.valid?'valid':'invalid'}"></div><div class="cl-d ${line.dirty?'dirty':''}">D</div><div class="cl-tag">0x${line.tag.toString(16).padStart(4,'0').toUpperCase()}</div><div class="cl-data">${line.data}</div><div class="cl-lru">${line.lru}</div>`;
        setDiv.appendChild(lineDiv);
      });
      container.appendChild(setDiv);
    });
  });
}

function updateCacheStats() {
  let iTotal = icacheHits + icacheMisses;
  let dTotal = dcacheHits + dcacheMissesCnt;
  let l2Total = l2Hits + l2Misses;
  setText('icacheHitRate', iTotal ? Math.round(icacheHits/iTotal*100)+'%' : '100%');
  setText('icacheHits', icacheHits);
  setText('icacheMisses', icacheMisses);
  setText('dcacheHitRate', dTotal ? Math.round(dcacheHits/dTotal*100)+'%' : '100%');
  setText('dcacheHits', dcacheHits);
  setText('dcacheMisses', dcacheMissesCnt);
  setText('dcacheDirty', dcacheData.flat().filter(l => l.dirty).length);
  setText('l2HitRate', l2Total ? Math.round(l2Hits/l2Total*100)+'%' : '100%');
  setText('l2Hits', l2Hits);
  setText('l2Misses', l2Misses);
  setText('tlbIHits', tlbIHits);
  setText('tlbDHits', tlbDHits);
  setText('tlbMisses', tlbMissesCnt);
}

function renderBTB() {
  let body = document.getElementById('btbTableBody');
  if (!body) return;
  body.innerHTML = '';
  btbEntries.slice(0,12).forEach((e, i) => {
    let stateColors = { SN:'c-red', WN:'c-orange', WT:'c-yellow', ST:'c-green' };
    body.innerHTML += `<tr class="${e.valid ? 'predict-'+(e.state==='WT'||e.state==='ST'?'taken':'not') : ''}">
      <td class="mono c-text3">${i.toString(16).padStart(2,'0')}</td>
      <td class="mono c-text3">${e.valid ? '0x'+e.tag.toString(16).padStart(4,'0').toUpperCase() : '—'}</td>
      <td class="mono c-accent2">${e.valid ? '0x'+e.target.toString(16).padStart(8,'0').toUpperCase() : '—'}</td>
      <td class="mono ${stateColors[e.state]||''}">${e.state}</td>
      <td class="mono ${e.state==='ST'||e.state==='WT'?'c-green':'c-red'}">${e.valid ? (e.state==='ST'||e.state==='WT' ? 'TAKEN' : 'NOT') : '—'}</td>
    </tr>`;
  });
  let total = btbCorrect + btbMispred;
  setText('btbAccuracy', total ? Math.round(btbCorrect/total*100)+'%' : '—');
  setText('btbCorrect', btbCorrect);
  setText('btbMispred', btbMispred);
  setText('btbPenalty', btbMispred * 3);
}

function updateFSM(taken) {
  const transitions = {
    SN: { taken: 'WN', notTaken: 'SN' },
    WN: { taken: 'WT', notTaken: 'SN' },
    WT: { taken: 'ST', notTaken: 'WN' },
    ST: { taken: 'ST', notTaken: 'WT' },
  };
  bpState = transitions[bpState][taken ? 'taken' : 'notTaken'];
  bhrRegister.shift();
  bhrRegister.push(taken ? 1 : 0);
  ['SN','WN','WT','ST'].forEach(s => {
    let el = document.getElementById('fsm-'+s);
    if (el) el.className = 'fsm-state ' + s.toLowerCase() + (bpState === s ? ' current' : '');
  });
  setText('currentFSMState', bpState);
  // Plain-English branch predictor explanation
  const bEngEl = document.getElementById('branchEnglishText');
  if (bEngEl) bEngEl.innerHTML = branchFSMToEnglish(bpState, branchHistory[0] || null);

  let bhrEl = document.getElementById('bhrDisplay');
  if (bhrEl) {
    bhrEl.innerHTML = bhrRegister.map(b => `<div style="width:20px;height:20px;border:1px solid var(--border2);background:var(--bg2);display:flex;align-items:center;justify-content:center;font-family:'Share Tech Mono',monospace;font-size:11px;color:${b?'var(--green)':'var(--red)'};">${b}</div>`).join('');
  }
  renderBTB();
}

function fsmTaken() { updateFSM(true); }
function fsmNotTaken() { updateFSM(false); }

function renderBranchHistory() {
  let el = document.getElementById('branchHistoryLog');
  if (!el) return;
  el.innerHTML = branchHistory.map(b =>
    `<div class="log-entry ${b.taken?'execute':'hazard'}" style="font-size:9px;">
      <span class="log-tick">C${b.cycle}</span>
      <span class="log-stage ${b.taken?'execute':'hazard'}" style="width:40px;">${b.taken?'TAKEN':'NOT'}</span>
      <span class="log-msg">${b.instr} ${b.predicted !== b.taken ? '⚠ MISPRED' : '✓'}</span>
    </div>`).join('');
}

function addROBEntry(instr, state) {
  let freeSlot = rob.findIndex(e => !e.valid);
  if (freeSlot < 0) freeSlot = 0;
  rob[freeSlot] = { valid: state !== 'COMMIT', instr: instr.raw, dest: instr.rd, value: instr._result || 0, state };
  robHead = (robHead + (state==='COMMIT'?1:0)) % 16;
  if (state !== 'COMMIT') robTail = (robTail + 1) % 16;
  if (state === 'COMMIT') oooCommitted++;
  renderROB();
}

function renderROB() {
  let body = document.getElementById('robBody');
  if (!body) return;
  body.innerHTML = '';
  rob.forEach((e, i) => {
    let stateClass = e.state === 'COMMIT' ? 'rob-state-ready' : e.state === 'EX' ? 'rob-state-exec' : 'rob-state-issue';
    let rowClass = i === robHead ? 'head-row' : i === robTail ? 'tail-row' : e.state === 'COMMIT' ? 'ready-row' : '';
    body.innerHTML += `<tr class="${rowClass}">
      <td class="mono c-text3">${i}${i===robHead?'←H':''}${i===robTail?'←T':''}</td>
      <td class="mono c-yellow">${e.instr}</td>
      <td class="mono c-accent2">${e.dest >= 0 ? 'R'+e.dest : '—'}</td>
      <td class="mono c-green">${e.valid ? '0x'+(e.value>>>0).toString(16).padStart(8,'0').toUpperCase() : '—'}</td>
      <td class="mono ${stateClass}">${e.state}</td>
    </tr>`;
  });
  setText('robHead', robHead);
  setText('robTail', robTail);
  setText('robUsed', rob.filter(e=>e.valid).length);
  setText('oooCommitted', oooCommitted);
  setText('oooSquashed', oooSquashed);
  if (pipeline.WB && !pipeline.WB.isBubble) setText('oooLastCommit', pipeline.WB.raw || '—');
}

function renderRS() {
  let el = document.getElementById('rsDisplay');
  if (!el) return;
  let entries = [pipeline.IF, pipeline.ID, pipeline.EX, pipeline.MEM].filter(Boolean);
  if (entries.length === 0) { el.innerHTML = '<div style="color:var(--text3);font-size:10px;padding:8px;">No pending operations</div>'; return; }
  el.innerHTML = entries.map((instr, i) => {
    let stage = ['IF','ID','EX','MEM'][i];
    let ready = stage === 'EX' || stage === 'MEM';
    return `<div class="rs-entry ${ready?'ready-to-issue':''}">
      <div class="rs-row">
        <span class="rs-label" style="width:30px;">[${i}]</span>
        <span class="rs-val c-yellow">${instr.isBubble?'NOP':instr.raw}</span>
        <span style="margin-left:auto;font-size:9px;color:${ready?'var(--green)':'var(--orange)'};">${stage}</span>
      </div>
      ${!instr.isBubble ? `<div class="rs-row">
        <span class="rs-field"><span class="rs-label">RS1:</span><span class="rs-val ${ready?'ready':'waiting'}">R${instr.rs1}=${registers[instr.rs1]}</span></span>
        <span class="rs-field" style="margin-left:12px;"><span class="rs-label">RS2:</span><span class="rs-val ${ready?'ready':'waiting'}">R${instr.rs2}=${registers[instr.rs2]}</span></span>
      </div>` : ''}
    </div>`;
  }).join('');
}

function renderRAT() {
  let el = document.getElementById('ratDisplay');
  if (!el) return;
  el.innerHTML = '';
  for (let i = 0; i < 16; i++) {
    el.innerHTML += `<div style="display:flex;gap:4px;align-items:center;font-family:'Share Tech Mono',monospace;font-size:9px;padding:2px 4px;background:var(--bg2);border:1px solid var(--border);">
      <span class="c-text3">R${i}:</span>
      <span class="${rat[i]>=0?'c-orange':'c-text3'}">${rat[i]>=0?'ROB'+rat[i]:'ARCH'}</span>
    </div>`;
  }
}

function updateMemoryTable() {
  let body = document.getElementById('memoryTableBody');
  if (!body) return;
  body.innerHTML = '';
  instructionMemory.forEach((instr, i) => {
    let addr = i * 4;
    let isCurrent = addr === (programCounter - 4);
    body.innerHTML += `<tr class="${isCurrent ? 'pc-row' : ''}">
      <td class="addr">0x${addr.toString(16).padStart(8,'0').toUpperCase()}</td>
      <td class="hex">${instr.hex}</td>
      <td class="mnem">${instr.mnem}</td>
      <td class="operand">${instr.raw.replace(instr.mnem,'').trim()}</td>
    </tr>`;
  });
}

function updateInstrQueueDisplay() {
  let el = document.getElementById('instrQueueDisplay');
  if (!el) return;
  el.innerHTML = '';
  instrQueue.forEach((instr, i) => {
    el.innerHTML += `<div style="display:flex;gap:6px;padding:3px 6px;background:var(--bg2);border:1px solid var(--border);border-left:2px solid var(--accent2);font-family:'Share Tech Mono',monospace;font-size:10px;">
      <span class="c-text3">${i.toString().padStart(2,'0')}</span>
      <span class="c-yellow">${instr.mnem}</span>
      <span class="c-text2">${instr.raw.replace(instr.mnem,'').trim()}</span>
      <span style="margin-left:auto;color:var(--text3);font-size:9px;">${instr.def.type}</span>
    </div>`;
  });
  setText('queueBadge', instrQueue.length+'/16');
}

// ─── VERBOSE EXECUTION LOG ────────────────────────────────────────────────────
// Maps terse internal messages to plain-English explanations
function addLog(cycle, stage, msg, cls = 'fetch') {
  let log = document.getElementById('execLog');
  if (!log) return;

  // Build the verbose explanation
  const xlCls = ({
    fetch:'xl-fetch', decode:'xl-decode', execute:'xl-execute', memory:'xl-memory', writeback:'xl-wb', hazard:'xl-stall', forward:'xl-fwd', branch:'xl-branch',
  })[cls] || 'xl-prog';

  const stageLabels = {
    'IF': 'FETCH', 'ID': 'DECODE', 'EX': 'EXECUTE', 'MEM': 'MEMORY',
    'WB': 'WRITEBACK', 'STALL': 'STALL', 'FWD': 'FORWARD',
    'BRANCH': 'BRANCH', 'PROG': 'LOAD', 'SIM': 'SIM', 'QUEUE':'QUEUE'
  };
  const stageDisplay = stageLabels[stage] || stage;

  // Build headline + detail based on the stage and message content
  let headline = '', detail = '';

  if (stage === 'IF') {
    // msg: "Fetch: LW R2,8(R9) @ 0x00000038"
    const parts = msg.replace('Fetch: ', '').split(' @ ');
    const instrPart = parts[0] || msg;
    const addrPart = parts[1] || '';
    headline = 'The CPU just <b>fetched</b> instruction <span class="xl-r">' + instrPart + '</span> from memory' + (addrPart ? ' at address <span class="xl-v">' + addrPart + '</span>' : '') + '.';
    detail = `Fetching = reading the raw binary of the instruction from the instruction cache. Nothing is computed yet. This instruction will move to Decode next cycle.`;
  } else if (stage === 'ID') {
    // msg: "Decode: LW R2,8(R9)"
    const instrPart = msg.replace('Decode: ', '');
    headline = `<b>Decoding</b> <span class="xl-r">${instrPart}</span>: the CPU identifies what operation this is and which registers it needs.`;
    detail = `The instruction's binary bits are split into fields: opcode (what to do), source registers (where to get input), destination register (where to put the result). The register file is read here.`;
  } else if (stage === 'EX') {
    // msg: "Execute: LW R2,8(R9) → 4168 (ADD)"  or  "Execute: ADD R15,R15,R3 → 5 (ADD)"
    const inner = msg.replace('Execute: ', '');
    const arrowIdx = inner.lastIndexOf(' → ');
    const instrPart = arrowIdx >= 0 ? inner.slice(0, arrowIdx) : inner;
    const resultPart = arrowIdx >= 0 ? inner.slice(arrowIdx + 3) : '';
    if (resultPart.includes('ADD') && instrPart.includes('LW')) {
      headline = `<b>Execute</b>: <span class="xl-r">${instrPart}</span> — the ALU computed the <b>memory address</b> = <span class="xl-v">${resultPart.split(' ')[0]}</span>.`;
      detail = `For a load (LW), the ALU's only job is computing where in memory to look: base register + offset. The actual data fetch happens in the Memory stage next.`;
    } else {
      headline = `<b>Execute</b>: <span class="xl-r">${instrPart}</span> — ALU result = <span class="xl-v">${resultPart}</span>.`;
      detail = `The arithmetic/logic unit computed the answer. This result travels to the Memory stage (or directly to Writeback for non-memory instructions).`;
    }
  } else if (stage === 'MEM') {
    if (msg.startsWith('Load@')) {
      // "Load@0xADDR: loaded value X into RN"
      const m = msg.match(/Load@(0x\w+): loaded value (-?\d+) into R(\d+)/);
      if (m) {
        headline = `<b>Memory read</b> from address <span class="xl-a">${m[1]}</span> returned value <span class="xl-v">${m[2]}</span> → will write to <span class="xl-r">R${m[3]}</span>.`;
        detail = `The data cache was queried. On a hit (most of the time), the result comes back in 1 cycle. This loaded value is now available in the MEM/WB pipeline register — the forwarding unit can supply it directly to any Execute-stage instruction that needs it.`;
      } else { headline = msg; }
    } else if (msg.startsWith('Store@')) {
      const m = msg.match(/Store@(0x\w+): wrote value (-?\d+) from R(\d+)/);
      if (m) {
        headline = `<b>Memory write</b>: stored value <span class="xl-v">${m[2]}</span> (from <span class="xl-r">R${m[3]}</span>) into address <span class="xl-a">${m[1]}</span>.`;
        detail = `The value is now in the data cache (marked "dirty"). It will eventually be written back to main DRAM when the cache line is evicted. No register is updated — store instructions don't write to the register file.`;
      } else { headline = msg; }
    } else {
      headline = msg;
    }
  } else if (stage === 'WB') {
    // msg: "Committed: ADD R15,R15,R3"
    const instrPart = msg.replace('Committed: ', '');
    // Figure out what register was written
    const instrObj = [pipeline.WB].filter(Boolean).find(i => i && !i.isBubble && i.raw === instrPart);
    const rdPart = instrObj ? ` → <span class="xl-r">R${instrObj.rd}</span> = <span class="xl-v">${dec(registers[instrObj.rd] || 0)}</span>` : '';
    headline = `<span class="xl-g">✓ Committed</span>: <span class="xl-r">${instrPart}</span>${rdPart} — <b>instruction is complete</b>.`;
    detail = `Writing the final result back into the register file. From this point, any subsequent instruction reading this register will get the new value. The instruction counter goes up by 1.`;
  } else if (stage === 'STALL' || cls === 'hazard') {
    // msg: "Load-Use: LW R2 needed by MUL — 1 cycle bubble"
    if (msg.startsWith('Load-Use:')) {
      const inner = msg.replace('Load-Use: ', '');
      headline = `<span class="xl-w">⚠ STALL</span>: ${inner}`;
      detail = `The load instruction (LW) won't have its result ready until after the Memory stage — but the following instruction needs it right now in Execute. Solution: freeze the consumer in Fetch for 1 cycle, insert a NOP bubble into Decode, and let the load advance. Next cycle the value is forwarded directly from Memory → Execute. Cost: exactly 1 wasted cycle.`;
    } else if (msg.startsWith('MISPREDICTION')) {
      headline = `<span class="xl-w">⚠ BRANCH MISPREDICTION</span>: ${msg}`;
      detail = `The branch predictor guessed wrong. 2 instructions that were speculatively fetched must be thrown away (flushed). The CPU restarts from the correct path. Cost: ~2–3 wasted cycles.`;
    } else {
      headline = `<span class="xl-w">⚠ STALL</span>: ${msg}`;
      detail = `The pipeline is frozen to resolve a hazard.`;
    }
  } else if (stage === 'BRANCH' || cls === 'branch') {
    headline = `<b>Branch resolved</b>: ${msg}`;
    detail = msg.includes('MISPRED')
      ? `The predictor was wrong — pipeline must be flushed and restarted from the correct address.`
      : `The predictor was correct — no penalty cycles wasted.`;
  } else if (stage === 'PROG') {
    headline = `<b>Program loaded</b>: ${msg}`;
    detail = `Instructions queued in the instruction buffer, ready for the pipeline to begin fetching.`;
  } else {
    headline = msg;
    detail = '';
  }

  const entry = document.createElement('div');
  entry.className = `xlog-entry ${xlCls}`;
  entry.innerHTML = '<div class="xlog-meta"><span class="xlog-cycle">C' + cycle + '</span><span class="xlog-stage-pill ' + xlCls + '">' + stageDisplay + '</span></div><div class="xlog-headline">' + headline + '</div>' + (detail ? '<div class="xlog-detail">' + detail + '</div>' : '');
  log.insertBefore(entry, log.firstChild);
  while (log.children.length > 60) log.removeChild(log.lastChild);
}

// dec() defined above near describeInstr

function logMemAccess(type, addr, val) {
  let el = document.getElementById('memAccessLog');
  if (!el) return;
  let e = document.createElement('div');
  e.className = 'log-entry memory';
  e.innerHTML = `<span class="log-tick">C${totalCycles}</span><span class="log-stage memory">${type}</span><span class="log-msg">0x${(addr>>>0).toString(16).padStart(8,'0').toUpperCase()} = ${val}</span>`;
  el.insertBefore(e, el.firstChild);
  while (el.children.length > 20) el.removeChild(el.lastChild);
  let l2El = document.getElementById('l2AccessIndicator');
  if (l2El) {
    l2El.textContent = `${type} @ 0x${(addr>>>0).toString(16).padStart(8,'0').toUpperCase()}`;
    l2El.style.color = 'var(--accent)';
    setTimeout(() => { if (l2El) { l2El.textContent = 'IDLE'; l2El.style.color = 'var(--text3)'; } }, 800);
  }
}

function highlightHazard(type) {
  document.querySelectorAll('.hazard-badge').forEach(b => {
    b.classList.remove('active');
    if (b.classList.contains(type)) {
      b.classList.add('active');
      setTimeout(() => b.classList.remove('active'), 2000);
    }
  });
}

function updateTimingRow(instr, stage, cycle) {
  if (!instr || instr.isBubble) return;
  let label = instr.raw;
  let existing = timingData.find(r => r.label === label && r.startCycle && cycle - r.startCycle < 12);
  if (!existing) {
    existing = { label, cells: {}, startCycle: cycle };
    timingData.unshift(existing);
    if (timingData.length > 12) timingData.pop();
  }
  existing.cells[cycle] = stage;
  renderTimingDiagram();
}

function renderTimingHeader() {
  let header = document.getElementById('timingCycleHeader');
  if (!header) return;
  header.innerHTML = '';
  for (let c = 1; c <= maxCycles; c++) {
    header.innerHTML += `<div class="timing-cycle-cell ${c === currentCycle ? 'current' : ''}">C${c}</div>`;
  }
}

function renderTimingDiagram() {
  let rows = document.getElementById('timingRows');
  if (!rows) return;
  rows.innerHTML = '';
  renderTimingHeader();
  timingData.forEach(row => {
    let div = document.createElement('div');
    div.className = 'timing-row';
    div.innerHTML = `<div class="timing-row-label">${row.label.slice(0,18)}</div>`;
    let cells = document.createElement('div');
    cells.className = 'timing-cells';
    for (let c = 1; c <= maxCycles; c++) {
      let s = row.cells[c] || '';
      cells.innerHTML += `<div class="timing-cell ${s}">${s}</div>`;
    }
    div.appendChild(cells);
    rows.appendChild(div);
  });
}

function clearTiming() {
  timingData = [];
  currentCycle = 0;
  renderTimingDiagram();
}

function updateDepTable() {
  let body = document.getElementById('depTableBody');
  if (!body) return;
  let entries = [pipeline.IF, pipeline.ID, pipeline.EX, pipeline.MEM, pipeline.WB].filter(Boolean);
  body.innerHTML = entries.map(instr => {
    if (instr.isBubble) return `<tr><td class="mono c-text3" colspan="4">NOP/BUBBLE</td></tr>`;
    let reads = [instr.rs1 !== 0 ? 'R'+instr.rs1 : '', instr.rs2 !== 0 ? 'R'+instr.rs2 : ''].filter(Boolean).join(',') || '—';
    let writes = instr.def.regWrite && instr.rd !== 0 ? 'R'+instr.rd : '—';
    let fwdA = checkForward(instr.rs1);
    let fwdB = checkForward(instr.rs2);
    let status = fwdA.forward || fwdB.forward ? 'FORWARD' : 'CLEAR';
    return `<tr>
      <td class="mono c-yellow">${instr.mnem}</td>
      <td class="mono c-orange">${reads}</td>
      <td class="mono c-green">${writes}</td>
      <td class="mono ${status==='FORWARD'?'c-accent':'c-green'}">${status}</td>
    </tr>`;
  }).join('');
}

function updateFUDisplay() {
  const fus = [
    { id: 'alu1', instr: pipeline.EX },
    { id: 'alu2', instr: pipeline.MEM },
    { id: 'mul',  instr: pipeline.EX && pipeline.EX.def && pipeline.EX.def.mulDiv ? pipeline.EX : null },
    { id: 'lsu',  instr: pipeline.MEM && pipeline.MEM.def && (pipeline.MEM.def.memRead||pipeline.MEM.def.memWrite) ? pipeline.MEM : null },
    { id: 'bru',  instr: pipeline.EX && pipeline.EX.def && pipeline.EX.def.branch ? pipeline.EX : null },
  ];
  fus.forEach(fu => {
    let el = document.getElementById('fu-'+fu.id);
    let statusEl = document.getElementById('fu-'+fu.id+'-status');
    let instrEl = document.getElementById('fu-'+fu.id+'-instr');
    if (!el || !statusEl || !instrEl) return;
    if (fu.instr && !fu.instr.isBubble) {
      el.className = 'rs-entry ready-to-issue';
      statusEl.textContent = 'BUSY'; statusEl.className = 'c-yellow';
      instrEl.textContent = fu.instr.raw;
    } else {
      el.className = 'rs-entry';
      statusEl.textContent = 'IDLE'; statusEl.className = 'c-text3';
      instrEl.textContent = '—';
    }
  });
}

function updateAll() {
  setText('cycleCount', totalCycles);
  setText('instrCount', totalInstrs);
  setText('cpiDisplay', totalInstrs > 0 ? (totalCycles/totalInstrs).toFixed(2) : '—');
  setText('ipcDisplay', totalCycles > 0 ? (totalInstrs/totalCycles).toFixed(2) : '—');
  setText('stallCount', totalStalls);
  setText('missCount', cacheMisses);

  updatePipelineStages();

  setText('pcDisplay', '0x'+(pc>>>0).toString(16).padStart(8,'0').toUpperCase());
  setText('pcPlusDisplay', 'PC+4: 0x'+((pc+4)>>>0).toString(16).padStart(8,'0').toUpperCase());
  setText('fetchPC', '0x'+(pc>>>0).toString(16).padStart(8,'0').toUpperCase());

  setText('instrBusVal', pipeline.ID && !pipeline.ID.isBubble ? pipeline.ID.hex : '—');
  setText('dataBusVal', pipeline.EX && !pipeline.EX.isBubble && pipeline.EX._result !== undefined ? '0x'+(pipeline.EX._result>>>0).toString(16).padStart(8,'0').toUpperCase() : '—');
  setText('ctrlBusVal', pipeline.EX && !pipeline.EX.isBubble ? (pipeline.EX.def.aluOp||'—') : '—');

  let simDot = document.getElementById('simStatusDot');
  if (simDot) simDot.className = autoRunInterval ? 'status-dot' : 'status-dot yellow';
  setText('simStatusVal', autoRunInterval ? 'RUNNING' : (totalCycles > 0 ? 'PAUSED' : 'IDLE'));
  let curInstr = pipeline.EX || pipeline.ID || pipeline.IF;
  setText('currentStageVal', curInstr ? (pipeline.EX && !pipeline.EX.isBubble ? 'EX' : pipeline.ID && !pipeline.ID.isBubble ? 'ID' : 'IF') : '—');
  setText('currentInstrVal', curInstr ? (curInstr.isBubble ? 'NOP' : curInstr.mnem) : '—');
  setText('tempVal', temp+'°C');
  setText('powerVal', power+'W');

  setText('rawStat', totalRaw);
  setText('stallStat', totalStalls);
  setText('branchMispredStat', totalBranchMispred);
  setText('fwdStat', totalFwd);
  let eff = totalCycles > 0 ? Math.round(totalInstrs/totalCycles*100) : 0;
  setText('effStat', eff+'%');
  let fwdRate = totalInstrs > 0 ? Math.min(Math.round(totalFwd/totalInstrs*100), 100) : 0;
  setText('fwdRateStat', fwdRate+'%');

  setWidth('rawBar', Math.min(totalRaw/20*100,100)+'%');
  setWidth('stallBar', Math.min(totalStalls/20*100,100)+'%');
  setWidth('branchBar', Math.min(totalBranchMispred/5*100,100)+'%');
  setWidth('fwdBar', Math.min(totalFwd/20*100,100)+'%');
  setWidth('effBar', eff+'%');
  setWidth('fwdRateBar', fwdRate+'%');

  for (let i = 0; i < 32; i++) {
    let el = document.getElementById('reg-val-'+i);
    if (el) el.textContent = '0x'+(registers[i]>>>0).toString(16).padStart(8,'0').toUpperCase();
  }

  updateDepTable();
  renderRS();
  renderRAT();
  updateFUDisplay();

  let rl = document.getElementById('runLight');
  if (rl) rl.className = 'run-light ' + (autoRunInterval ? 'running' : 'paused');
  // Update GOAL status bar with live progress during auto-run
  if (autoRunInterval && currentProgramGoal && !programCompleteFired) {
    const goalVal = document.getElementById('goalStatusVal');
    if (goalVal && sortProgramType === 'bubble' && sortPassTotal > 0) {
      goalVal.textContent = 'Bubble Sort: pass ' + Math.min(sortPass+1, sortPassTotal) + '/' + sortPassTotal +
        ' — ' + sortCmpCount + ' comparisons, ' + sortSwapCount + ' swaps, ' +
        totalStalls + ' stall cycles so far';
    }
  }
}

// ============================================================
// HELPERS
// ============================================================
function setText(id, val) {
  let el = document.getElementById(id);
  if (el) el.textContent = val;
}
function setWidth(id, val) {
  let el = document.getElementById(id);
  if (el) el.style.width = val;
}

function addInstruction() {
  let input = document.getElementById('instrInputMain');
  let raw = input.value.trim();
  if (!raw) return;
  let instr = parseInstr(raw);
  if (instr) {
    instrQueue.push(instr);
    if (!instructionMemory.find(i => i.raw === instr.raw)) instructionMemory.push(instr);
    updateInstrQueueDisplay();
    updateMemoryTable();
    input.value = '';
    addLog(totalCycles, 'QUEUE', `Added: ${instr.raw}`, 'fetch');
    // Update goal to reflect what's queued
    const qlen = instrQueue.length;
    setGoal('Manual sequence: ' + qlen + ' instruction' + (qlen !== 1 ? 's' : '') + ' queued — CPU will execute them in order, then loop', 'var(--text2)');
  }
}

function queuePreset(raw) {
  let instr = parseInstr(raw);
  if (instr) {
    instrQueue.push(instr);
    if (!instructionMemory.find(i => i.raw === raw)) instructionMemory.push(instr);
    updateInstrQueueDisplay();
    updateMemoryTable();
  }
}

function setGoal(goal, color) {
  currentProgramGoal = goal;
  programCompleteFired = false;
  const item = document.getElementById('goalStatusItem');
  const val  = document.getElementById('goalStatusVal');
  if (!item || !val) return;
  if (goal) {
    item.style.display = '';
    val.textContent = goal;
    val.style.color = color || 'var(--text1)';
  } else {
    item.style.display = 'none';
    val.textContent = '—';
  }
}

function stopAutoRun(reason) {
  if (!autoRunInterval) return;
  clearInterval(autoRunInterval);
  autoRunInterval = null;
  document.getElementById('btnRun').textContent = 'AUTO RUN';
  document.getElementById('btnRun').classList.remove('active');
  const rl = document.getElementById('runLight');
  if (rl) rl.className = 'run-light paused';
  if (reason) {
    setGoal('✓ DONE — ' + reason, 'var(--green)');
    addLog(totalCycles, 'SIM', '── ' + reason + ' ──', 'writeback');
  }
}

function toggleRun() {
  if (autoRunInterval) {
    clearInterval(autoRunInterval);
    autoRunInterval = null;
    document.getElementById('btnRun').textContent = 'AUTO RUN';
    document.getElementById('btnRun').classList.remove('active');
  } else {
    autoRunInterval = setInterval(() => {
      if (instrQueue.length === 0 && !pipeline.IF && !pipeline.ID && !pipeline.EX && !pipeline.MEM && !pipeline.WB) {
        if (programCompleteFired) {
          // Program finished cleanly - don't restart
          stopAutoRun('');
          return;
        }
        if (instructionMemory.length > 0) {
          instrQueue = instructionMemory.map(i => parseInstr(i.raw)).filter(Boolean);
          instrQueue.forEach((instr, i) => { instr._sortMeta = (instructionMemory[i] && instructionMemory[i]._sortMeta) || null; });
          // Reset sort display state so pass counter and bars restart cleanly
          if (sortProgramType) {
            sortPass = 0; sortCmpCount = 0; sortSwapCount = 0;
            sortSortedUpTo = -1;
            if (sortArrayInitial.length > 0) {
              sortArray = [...sortArrayInitial];
              // Restore initial memory values
              const BASE = 0x1000;
              sortArrayInitial.forEach((v, i) => { memory['0x'+(BASE+i*4).toString(16).toUpperCase()] = v; });
            }
          }
          updateInstrQueueDisplay();
          addLog(totalCycles, 'SIM', '── Program loop restart ──', 'writeback');
        } else {
          totalCycles++;
          updateAll();
          return;
        }
      }
      step();
    }, speedMs);
    document.getElementById('btnRun').textContent = 'STOP ■';
    document.getElementById('btnRun').classList.add('active');
  }
  let rl = document.getElementById('runLight');
  if (rl) rl.className = 'run-light ' + (autoRunInterval ? 'running' : 'paused');
}

function updateSpeed(val) {
  speedMs = 2100 - parseInt(val);
  if (autoRunInterval) {
    clearInterval(autoRunInterval);
    autoRunInterval = setInterval(() => step(), speedMs);
  }
}

function resetSim() {
  if (autoRunInterval) { clearInterval(autoRunInterval); autoRunInterval = null; }
  pipeline = { IF: null, ID: null, EX: null, MEM: null, WB: null };
  instrQueue = [];
  instructionMemory = [];
  pc = 0; programCounter = 0;
  totalCycles = 0; totalInstrs = 0; totalStalls = 0; totalRaw = 0;
  totalBranchMispred = 0; totalFwd = 0; cacheMisses = 0;
  rawHazards = 0; stallCycles = 0; mispredictions = 0; fwdUsed = 0;
  icacheHits = 0; icacheMisses = 0; dcacheHits = 0; dcacheMissesCnt = 0;
  l2Hits = 0; l2Misses = 0; tlbIHits = 0; tlbDHits = 0; tlbMissesCnt = 0;
  btbCorrect = 0; btbMispred = 0;
  branchHistory = [];
  timingData = []; currentCycle = 0;
  bpState = 'WT'; bhrRegister = new Array(8).fill(0);
  oooCommitted = 0; oooSquashed = 0;
  temp = 42; power = 12;
  memory = {};
  sortOverlayActive = false;
  sortProgramType = '';
  sortArray = []; sortArrayInitial = [];
  sortCmpCount = 0; sortSwapCount = 0; sortPass = 0; sortSortedUpTo = -1;
  const overlayEl = document.getElementById('sortOverlay');
  if (overlayEl) overlayEl.classList.remove('active');
  const sortBtn = document.getElementById('btnSortView');
  if (sortBtn) sortBtn.style.display = 'none';

  initRegisters();
  initCache();
  initBTB();
  initROB();
  updateInstrQueueDisplay();
  updateMemoryTable();
  updateAll();
  clearLog();
  renderTimingDiagram();
  renderBranchHistory();

  document.getElementById('btnRun').textContent = 'AUTO RUN';
  document.getElementById('btnRun').classList.remove('active');
  document.getElementById('runLight').className = 'run-light paused';
  setGoal(''); programCompleteFired = false;
  document.getElementById('bitsRow').innerHTML = '';
  document.getElementById('decodeBadge').textContent = 'NO INSTR';
  const resetEng = (id, msg) => { let el = document.getElementById(id); if (el) el.innerHTML = msg; };
  resetEng('instrEnglishText', '');
  const instrEngBox = document.getElementById('instrEnglishBox');
  if (instrEngBox) instrEngBox.style.display = 'none';
  resetEng('aluEnglishText', '');
  const aluEngBox = document.getElementById('aluEnglishBox');
  if (aluEngBox) aluEngBox.style.display = 'none';
  resetEng('hazardEnglishText', 'Pipeline is flowing normally. No hazards detected this cycle.');
  resetEng('memEnglishText', 'Waiting for memory accesses. When a LW or SW runs, check which cache level was hit.');
  resetEng('branchEnglishText', 'No branches seen yet. The predictor starts in the <b>Weakly Taken (WT)</b> state — it will guess "taken" for the first branch it sees.');
  addLog(0, 'SIM', 'Simulation reset — load-use stall fix active', 'fetch');
}

function clearLog() {
  let log = document.getElementById('execLog');
  if (log) log.innerHTML = '';
}

function switchTab(name) {
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  const allIds = ['tab-overview','tab-fetch','tab-alu','tab-memory','tab-timing','tab-branch','tab-ooo','tab-glossary'];
  allIds.forEach(id => {
    let p = document.getElementById(id);
    if (p) { p.classList.remove('active'); p.style.display = 'none'; }
  });
  const tabMap = { overview:0, fetch:1, alu:2, memory:3, timing:4, branch:5, ooo:6, glossary:7 };
  let tabs = document.querySelectorAll('.tab');
  let idx = tabMap[name];
  if (tabs[idx]) tabs[idx].classList.add('active');
  let panel = document.getElementById('tab-'+name);
  if (panel) {
    panel.classList.add('active');
    panel.style.display = 'flex';
    if (name === 'timing' || name === 'overview' || name === 'glossary') panel.style.flexDirection = 'column';
    else panel.style.flexDirection = 'row';
  }
  const overlayEl = document.getElementById('sortOverlay');
  if (overlayEl) {
    if (name === 'overview' && sortOverlayActive) overlayEl.classList.add('active');
    else overlayEl.classList.remove('active');
  }
  if (name === 'memory') renderCache();
  if (name === 'timing') renderTimingDiagram();
  if (name === 'branch') { renderBTB(); renderBranchHistory(); }
  if (name === 'ooo') { renderROB(); renderRS(); renderRAT(); }
  if (name === 'fetch') { updateMemoryTable(); if (pipeline.ID) updateDecode(pipeline.ID); }
  if (name === 'glossary') renderGlossary();
}

function showHelp() { document.getElementById('helpOverlay').classList.add('show'); }
function showPrograms() { document.getElementById('programsOverlay').classList.add('show'); }

// ============================================================
// SORT OVERLAY
// ============================================================
function closeSortOverlay() {
  sortOverlayActive = false;
  document.getElementById('sortOverlay').classList.remove('active');
  const btn = document.getElementById('btnSortView');
  if (btn && sortProgramType) btn.textContent = 'SORT VIEW ▤';
}

function openSortOverlay(title) {
  sortOverlayActive = true;
  document.getElementById('sortOverlayTitle').textContent = title;
  document.getElementById('sortOverlay').classList.add('active');
  const btn = document.getElementById('btnSortView');
  if (btn) { btn.style.display = ''; btn.textContent = 'SORT VIEW ✕'; }
  switchTab('overview');
  // Re-render current sort state so reopening shows current progress, not initial state
  if (sortArray.length > 0) {
    renderSortBars(-1, -1, -1, -1, sortSortedUpTo);
  }
}

function toggleSortOverlay() {
  if (sortOverlayActive) {
    closeSortOverlay();
  } else {
    // Re-open if a program has been loaded
    if (sortProgramType) {
      sortOverlayActive = true;
      const titles = { bubble: 'BUBBLE SORT', dot: 'DOT PRODUCT  A·B', xor: 'XOR CIPHER' };
      document.getElementById('sortOverlayTitle').textContent = titles[sortProgramType] || 'SORT VIEW';
      document.getElementById('sortOverlay').classList.add('active');
      const btn = document.getElementById('btnSortView');
      if (btn) btn.textContent = 'SORT VIEW ✕';
      switchTab('overview');
    }
  }
}

function renderSortBars(comparingA, comparingB, swappingA, swappingB, sortedFrom) {
  const container = document.getElementById('sortBarsContainer');
  if (!container || !sortArray.length) return;
  const maxVal = Math.max(...sortArray, 1);
  container.innerHTML = sortArray.map((val, i) => {
    const heightPct = Math.max(8, Math.round((val / maxVal) * 100));
    const isComparing = (i === comparingA || i === comparingB);
    const isSwapping  = (i === swappingA  || i === swappingB);
    const isSorted    = (sortedFrom >= 0 && i >= sortedFrom);
    let bg = isSwapping ? 'var(--red)' : isComparing ? 'var(--yellow)' : isSorted ? 'var(--green)' : `hsl(${200 + i*18},70%,40%)`;
    return `<div style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:flex-end; gap:2px; height:100%;">
      <div style="font-family:'Share Tech Mono',monospace; font-size:9px; color:${isSwapping?'var(--red)':isComparing?'var(--yellow)':isSorted?'var(--green)':'var(--text3)'};">${val}</div>
      <div style="width:100%; height:${heightPct}%; background:${bg}; border-radius:2px 2px 0 0;"></div>
      <div style="font-family:'Share Tech Mono',monospace; font-size:8px; color:var(--text3);">[${i}]</div>
    </div>`;
  }).join('');
  document.getElementById('sortArrayState').textContent = '[' + sortArray.join(', ') + ']';
  document.getElementById('sortCmpCount').textContent = sortCmpCount;
  document.getElementById('sortSwapCount').textContent = sortSwapCount;
  document.getElementById('sortPassNum').textContent = sortPass + 1;
  document.getElementById('sortPassTotal').textContent = sortPassTotal;
}

function pushNarrative(type, algo, detail, tags) {
  const algoEl = document.getElementById('narrativeAlgo');
  const detailEl = document.getElementById('narrativeDetail');
  const tagsEl = document.getElementById('narrativeTags');
  if (algoEl) algoEl.innerHTML = algo;
  if (detailEl) detailEl.innerHTML = detail;
  if (tagsEl) tagsEl.innerHTML = tags.map(t => `<div class="narrative-tag ${t.cls}">${t.label}</div>`).join('');
  const histEl = document.getElementById('narrativeHistory');
  if (!histEl) return;
  const entry = document.createElement('div');
  entry.className = `narrative-hist-entry type-${type}`;
  entry.innerHTML = `<div class="nh-cycle">C${totalCycles}</div><div class="nh-text">${algo}</div>`;
  histEl.insertBefore(entry, histEl.firstChild);
  while (histEl.children.length > 60) histEl.removeChild(histEl.lastChild);
}

function parseUserInts(str) {
  return str.split(/[\s,]+/).map(s => s.trim()).filter(Boolean).map(s => {
    if (s.startsWith('0x') || s.startsWith('0X')) return parseInt(s, 16);
    return parseInt(s) || 0;
  });
}

function launchBubbleSort() {
  document.getElementById('programsOverlay').classList.remove('show');
  resetSim();
  let arr = parseUserInts(document.getElementById('bubbleArrayInput').value);
  if (arr.length < 2) arr = [5,3,8,1,9,2,7,4];
  if (arr.length > 8) arr = arr.slice(0, 8);
  const n = arr.length;
  const BASE = 0x1000;
  arr.forEach((v, i) => { memory['0x'+(BASE + i*4).toString(16).toUpperCase()] = v; });

  sortArray = [...arr];
  sortArrayInitial = [...arr];
  sortCmpCount = 0; sortSwapCount = 0;
  sortPass = 0; sortPassTotal = n - 1;
  sortSortedUpTo = -1; sortProgramType = 'bubble';

  let instrs = [];
  let sortMeta = [];
  instrs.push(`ADDI R8,R0,${BASE}`); sortMeta.push({ type:'init' });
  instrs.push(`ADDI R10,R0,${n}`);   sortMeta.push({ type:'init' });

  for (let pass = 0; pass < n - 1; pass++) {
    for (let j = 0; j < n - 1 - pass; j++) {
      const off1 = j * 4, off2 = (j+1) * 4;
      instrs.push(`LW R1,${off1}(R8)`);   sortMeta.push({ type:'load_a', pass, j, off: off1, desc:`Load arr[${j}]` });
      instrs.push(`LW R2,${off2}(R8)`);   sortMeta.push({ type:'load_b', pass, j, off: off2, desc:`Load arr[${j+1}]` });
      instrs.push(`SLT R3,R2,R1`);        sortMeta.push({ type:'compare', pass, j });
      instrs.push(`BEQ R3,R0,12`);        sortMeta.push({ type:'branch', pass, j });
      instrs.push(`SW R2,${off1}(R8)`);   sortMeta.push({ type:'swap_a', pass, j, off: off1 });
      instrs.push(`SW R1,${off2}(R8)`);   sortMeta.push({ type:'swap_b', pass, j, off: off2 });
    }
    instrs.push(`ADD R0,R0,R0`); sortMeta.push({ type:'pass_end', pass });
  }
  instrs.push(`ADD R15,R0,R0`); sortMeta.push({ type:'done' });

  instrQueue = instrs.map(s => parseInstr(s)).filter(Boolean);
  instrQueue.forEach((instr, i) => { instr._sortMeta = sortMeta[i] || null; });
  instructionMemory = instrQueue.map(instr => ({...instr}));
  updateInstrQueueDisplay();
  updateMemoryTable();
  initDataMem();

  openSortOverlay('BUBBLE SORT');
  renderSortBars(-1,-1,-1,-1,-1);
  setGoal('Bubble Sort: sorting [' + arr.join(', ') + '] using ' + instrs.length + ' instructions — watch for load-use stalls on every LW pair', 'var(--accent)');
  if (autoRunInterval) { /* already running, keep going */ } else { toggleRun(); }
  pushNarrative('info',
    `<b>Bubble Sort starting</b> — array: <span class="highlight-yellow">[${arr.join(', ')}]</span>`,
    `${n-1} passes needed. Each pass compares adjacent elements. Watch for load-use stalls on LW→SLT pairs — exactly 1 stall cycle each, then MEM/WB forwarding resolves it.`,
    [{cls:'alu', label:'ADDI×2'}, {cls:'load', label:`LW×${(n-1)*n}`}, {cls:'stall', label:'1-CYCLE STALLS'}]
  );
  addLog(0, 'PROG', `Bubble Sort: [${arr.join(', ')}] → ${instrs.length} instructions`, 'writeback');
}

function launchDotProduct() {
  document.getElementById('programsOverlay').classList.remove('show');
  resetSim();
  let vecA = parseUserInts(document.getElementById('dotVecA').value);
  let vecB = parseUserInts(document.getElementById('dotVecB').value);
  if (vecA.length === 0) vecA = [1,2,3,4,5,6,7,8];
  if (vecB.length === 0) vecB = [8,7,6,5,4,3,2,1];
  const n = Math.min(vecA.length, vecB.length, 8);
  vecA = vecA.slice(0,n); vecB = vecB.slice(0,n);
  const BASE_A = 0x1000, BASE_B = 0x1040;
  vecA.forEach((v, i) => { memory['0x'+(BASE_A + i*4).toString(16).toUpperCase()] = v; });
  vecB.forEach((v, i) => { memory['0x'+(BASE_B + i*4).toString(16).toUpperCase()] = v; });

  let instrs = [];
  let sortMeta = [];
  instrs.push(`ADDI R8,R0,${BASE_A}`);
  instrs.push(`ADDI R9,R0,${BASE_B}`);
  instrs.push(`ADD R15,R0,R0`);
  for (let i = 0; i < n; i++) {
    instrs.push(`LW R1,${i*4}(R8)`);
    instrs.push(`LW R2,${i*4}(R9)`);
    instrs.push(`MUL R3,R1,R2`);
    instrs.push(`ADD R15,R15,R3`);
  }
  instrs.push(`SW R15,0(R8)`);
  instrs.push(`ADD R10,R15,R0`); sortMeta.push({ type:'done' });

  instrQueue = instrs.map(s => parseInstr(s)).filter(Boolean);
  instrQueue.forEach((instr, i) => { instr._sortMeta = sortMeta[i] || null; });
  instructionMemory = instrQueue.map(instr => ({...instr}));
  updateInstrQueueDisplay();
  updateMemoryTable();
  initDataMem();

  const expected = vecA.reduce((acc, a, i) => acc + a * vecB[i], 0);
  sortProgramType = 'dot';
  sortArray = vecA;
  openSortOverlay('DOT PRODUCT  A·B');
  renderSortBars(-1,-1,-1,-1,-1);
  setGoal('Dot Product: computing A·B across ' + n + ' elements — pure ALU multiply-accumulate, no branches', 'var(--purple)');
  if (autoRunInterval) { /* already running */ } else { toggleRun(); }
  pushNarrative('info',
    `<b>Dot Product starting</b> — A·B = ${expected}`,
    `${n} multiply-accumulate iterations. Heavy MUL unit usage + forwarding. LW→MUL chains cause load-use stalls (1 cycle each), then MUL→ADD resolved by EX/MEM forwarding.`,
    [{cls:'alu', label:'MUL×'+n}, {cls:'fwd', label:'FORWARDING'}]
  );
  addLog(0, 'PROG', `Dot Product: expected=${expected}`, 'writeback');
}

function launchXorCipher() {
  document.getElementById('programsOverlay').classList.remove('show');
  resetSim();
  let data = parseUserInts(document.getElementById('xorData').value);
  let keyStr = document.getElementById('xorKey').value.trim();
  let key = keyStr.startsWith('0x') || keyStr.startsWith('0X') ? parseInt(keyStr,16) : parseInt(keyStr)||0xAB;
  if (data.length === 0) data = [72,101,108,108,111];
  if (data.length > 8) data = data.slice(0,8);
  const n = data.length;
  const BASE = 0x1000;
  data.forEach((v, i) => { memory['0x'+(BASE + i*4).toString(16).toUpperCase()] = v; });

  let instrs = [];
  let sortMeta = [];
  instrs.push(`ADDI R8,R0,${BASE}`);
  instrs.push(`ADDI R10,R0,${key & 0xFF}`);
  for (let i = 0; i < n; i++) {
    instrs.push(`LW R1,${i*4}(R8)`);
    instrs.push(`XOR R2,R1,R10`);
    instrs.push(`SLL R11,R10,3`);
    instrs.push(`SRL R12,R10,5`);
    instrs.push(`OR R10,R11,R12`);
    instrs.push(`XOR R10,R10,R2`);
    instrs.push(`SW R2,${i*4}(R8)`);
  }
  instrs.push(`ADD R15,R0,R0`); sortMeta.push({ type:'done' });

  instrQueue = instrs.map(s => parseInstr(s)).filter(Boolean);
  instrQueue.forEach((instr, i) => { instr._sortMeta = sortMeta[i] || null; });
  instructionMemory = instrQueue.map(instr => ({...instr}));
  updateInstrQueueDisplay();
  updateMemoryTable();
  initDataMem();

  sortProgramType = 'xor';
  sortArray = [...data];
  openSortOverlay('XOR CIPHER');
  renderSortBars(-1,-1,-1,-1,-1);
  setGoal('XOR Cipher: encrypting ' + n + ' bytes with key 0x' + key.toString(16).toUpperCase() + ' — one XOR per byte, no memory stalls', 'var(--yellow)');
  if (autoRunInterval) { /* already running */ } else { toggleRun(); }
  pushNarrative('info',
    `<b>XOR Cipher starting</b> — encrypting with rolling key <span class="highlight-accent">0x${key.toString(16).toUpperCase()}</span>`,
    `Pure ALU showcase — XOR, SLL, SRL, OR chains with near-zero stalls. Each LW causes 1 load-use stall, but the rest is pure forwarding. Watch pipeline efficiency stay high!`,
    [{cls:'alu', label:'XOR/SLL/SRL'}, {cls:'fwd', label:'MAX FORWARDING'}, {cls:'nswap', label:'~1 STALL/ITER'}]
  );
  addLog(0, 'PROG', `XOR Cipher: ${n} bytes, key=0x${key.toString(16).toUpperCase()}`, 'writeback');
}

// ============================================================
// GLOSSARY
// ============================================================
const GLOSSARY = {
  'Pipeline Concepts': [
    { term: 'Pipeline Stall', def: 'A cycle where no new instruction progresses, used to resolve hazards. In load-use hazards, exactly 1 stall cycle is inserted — the load advances to EX, a bubble fills ID, and the consumer waits in IF.' },
    { term: 'Load-Use Hazard', def: 'When a load instruction (LW) is immediately followed by an instruction that needs the loaded value. Cannot be resolved by forwarding alone — requires exactly 1 stall cycle.' },
    { term: 'Forwarding (Bypassing)', def: 'Routing data directly from a later pipeline stage (EX/MEM or MEM/WB) back to an earlier stage (EX) to avoid stalls for most RAW hazards.' },
    { term: 'Bubble (NOP)', def: 'A fake NOP instruction injected into the pipeline to separate dependent instructions. Does not write any register or memory.' },
    { term: 'RAW Hazard', def: 'Read After Write — when instruction B needs a value that instruction A has not yet written to the register file.' },
    { term: 'WAW Hazard', def: 'Write After Write — two instructions write the same register. In-order pipelines handle this naturally.' },
    { term: 'WAR Hazard', def: 'Write After Read — instruction B writes a register that instruction A still needs to read. Mainly affects out-of-order processors.' },
  ],
  'RISC-V Architecture': [
    { term: 'RV32I', def: 'The base 32-bit integer RISC-V ISA. 32 registers (x0-x31), fixed 32-bit instruction width, load/store architecture.' },
    { term: 'R-Type', def: 'Register-type instruction: uses two source registers (rs1, rs2) and writes to a destination register (rd). Example: ADD R1, R2, R3.' },
    { term: 'I-Type', def: 'Immediate-type: uses one source register and a 12-bit immediate. Includes ADDI, ANDI, ORI, loads.' },
    { term: 'S-Type', def: 'Store-type: stores a register value to memory. The immediate is split across [31:25] and [11:7].' },
    { term: 'B-Type', def: 'Branch-type: conditional branches. Target = PC + sign_extend(imm). Uses two source registers for comparison.' },
    { term: 'Program Counter (PC)', def: 'Holds the address of the next instruction to fetch. Increments by 4 each cycle (word-aligned). Stays frozen during load-use stalls.' },
  ],
  'Performance Metrics': [
    { term: 'CPI', def: 'Cycles Per Instruction. Ideal pipeline: CPI=1. Stalls increase CPI. Formula: CPI = Total Cycles / Instructions Committed.' },
    { term: 'IPC', def: 'Instructions Per Cycle = 1/CPI. Maximum theoretical IPC for a 5-stage in-order pipeline = 1.0.' },
    { term: 'Pipeline Efficiency', def: 'Percentage of cycles where useful work is done: (Instructions / Cycles) × 100%. Stalls and bubbles reduce this below 100%.' },
    { term: 'Branch Penalty', def: 'Cycles wasted due to branch misprediction. Typically 2-3 cycles for a 5-stage pipeline.' },
  ],
  'Cache': [
    { term: 'Cache Hit', def: 'The requested data is found in the cache. Latency: 1 cycle for L1.' },
    { term: 'Cache Miss', def: 'Data not in cache, must fetch from L2 (10 cycles) or DRAM (200 cycles).' },
    { term: 'Set-Associative Cache', def: 'Cache organized into sets, each with multiple ways. This visualizer shows 8-way set-associative L1 caches.' },
    { term: 'LRU (Least Recently Used)', def: 'Eviction policy: replace the cache line that was accessed least recently.' },
    { term: 'Write-Back', def: 'Cache write policy where writes go to cache first; dirty lines are written to memory only when evicted.' },
  ],
};

function renderGlossary() {
  const nav = document.getElementById('glossaryNav');
  const content = document.getElementById('glossaryContent');
  if (!nav || !content) return;

  nav.innerHTML = '';
  content.innerHTML = '';

  Object.keys(GLOSSARY).forEach(section => {
    const navItem = document.createElement('div');
    navItem.style.cssText = 'padding:8px 12px; font-size:11px; color:var(--text2); cursor:pointer; border-bottom:1px solid var(--border); transition:color 0.2s;';
    navItem.textContent = section;
    navItem.onclick = () => {
      const el = document.getElementById('glossary-'+section.replace(/\s+/g,'_'));
      if (el) el.scrollIntoView({ behavior: 'smooth' });
    };
    navItem.onmouseover = () => navItem.style.color = 'var(--accent)';
    navItem.onmouseout = () => navItem.style.color = 'var(--text2)';
    nav.appendChild(navItem);

    const secDiv = document.createElement('div');
    secDiv.id = 'glossary-'+section.replace(/\s+/g,'_');
    secDiv.style.cssText = 'padding:16px 20px; border-bottom:1px solid var(--border);';
    secDiv.innerHTML = `<div style="font-family:'Orbitron',sans-serif;font-size:10px;letter-spacing:2px;color:var(--accent);text-transform:uppercase;margin-bottom:12px;">${section}</div>`;

    GLOSSARY[section].forEach(item => {
      secDiv.innerHTML += `<div style="margin-bottom:12px;">
        <div style="font-family:'Share Tech Mono',monospace;font-size:12px;color:var(--yellow);margin-bottom:3px;">${item.term}</div>
        <div style="font-size:12px;color:var(--text2);line-height:1.6;">${item.def}</div>
      </div>`;
    });
    content.appendChild(secDiv);
  });
}

// ============================================================
// INIT
// ============================================================
// ============================================================
// TOOLTIP ENGINE
// ============================================================
(function() {
  const box   = document.getElementById('tipBox');
  const title = document.getElementById('tipTitle');
  const body  = document.getElementById('tipBody');
  let cur = null;

  const TIPS = {};  // populated from data-tip attributes at runtime

  function parseTip(raw) {
    // Format: "key|Title|Body HTML"
    const parts = raw.split('|');
    return { key: parts[0], title: parts[1] || '', body: parts[2] || '' };
  }

  function show(el, e) {
    const t = parseTip(el.dataset.tip);
    title.textContent = t.title;
    body.innerHTML = t.body;
    box.classList.add('show');
    position(e);
    cur = el;
  }

  function hide() {
    box.classList.remove('show');
    cur = null;
  }

  function position(e) {
    const pad = 14;
    const bw = box.offsetWidth  || 280;
    const bh = box.offsetHeight || 120;
    let x = e.clientX + pad;
    let y = e.clientY + pad;
    if (x + bw > window.innerWidth  - 8) x = e.clientX - bw - pad;
    if (y + bh > window.innerHeight - 8) y = e.clientY - bh - pad;
    box.style.left = x + 'px';
    box.style.top  = y + 'px';
  }

  document.addEventListener('mouseover', function(e) {
    const el = e.target.closest('[data-tip]');
    if (el && el !== cur) show(el, e);
    else if (!el && cur) hide();
  });

  document.addEventListener('mousemove', function(e) {
    if (cur) position(e);
  });

  document.addEventListener('mouseout', function(e) {
    if (!e.relatedTarget || !e.relatedTarget.closest('[data-tip]')) {
      // small delay so tooltip doesn't flicker on child elements
      setTimeout(() => { if (!document.querySelector('[data-tip]:hover')) hide(); }, 80);
    }
  });

  // Hide on scroll / tab switch
  document.addEventListener('scroll', hide, true);
})();

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
  init();
});

</script>
</body>
</html>
