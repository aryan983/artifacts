<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GPU Cache Coherency ‚Äî Architecture Explorer</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Outfit:wght@300;400;600;700;800&display=swap');
:root {
  --bg: #0a0b0f; --surface: #12141a; --surface2: #1a1d26;
  --border: #2a2d3a; --text: #e0e2ec; --dim: #6b7094;
  --l1: #ff6b6b; --l2: #ffa94d; --smem: #51cf66;
  --global: #339af0; --dram: #845ef7; --coherency: #f06595;
  --new-block: #22d3ee; --changed: #facc15;
}
* { margin:0; padding:0; box-sizing:border-box; }
body { background:var(--bg); color:var(--text); font-family:'Outfit',sans-serif; min-height:100vh; overflow-x:hidden; }
.grain { position:fixed; inset:0; pointer-events:none; z-index:999; opacity:.03;
  background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E"); }

header { text-align:center; padding:20px 16px 10px; }
header h1 { font-size:clamp(1.6rem,3.5vw,2.6rem); font-weight:800; letter-spacing:-1px;
background:linear-gradient(135deg,#ff6b6b,#ffa94d,#51cf66,#339af0,#845ef7);
-webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text; }
header p { color:var(--dim); font-family:'JetBrains Mono',monospace; font-size:.75rem; margin-top:4px; letter-spacing:2px; text-transform:uppercase; }

.arch-tabs { display:flex; justify-content:center; gap:0; padding:10px 16px 6px; flex-wrap:wrap; }
.arch-tab {
background:var(--surface); border:1px solid var(--border); color:var(--dim);
font-family:'JetBrains Mono',monospace; font-size:.7rem; padding:8px 14px;
cursor:pointer; transition:all .2s; letter-spacing:.3px; position:relative;
border-right:none;
}
.arch-tab:first-child { border-radius:6px 0 0 6px; }
.arch-tab:last-child { border-radius:0 6px 6px 0; border-right:1px solid var(--border); }
.arch-tab:hover { color:var(--text); background:var(--surface2); }
.arch-tab.active { background:var(--surface2); color:#fff; border-color:var(--accent-color,var(--global)); }
.arch-tab.active::after { content:''; position:absolute; bottom:-1px; left:10%; right:10%; height:2px; background:var(--accent-color,var(--global)); border-radius:1px; }
.arch-tab .tab-gen { display:block; font-size:.55rem; color:var(--dim); margin-top:2px; font-weight:400; }
.arch-tab.active .tab-gen { color:var(--accent-color,var(--global)); }

.diff-banner {
max-width:1200px; margin:6px auto 0; padding:8px 14px;
background:var(--surface); border:1px solid var(--border); border-radius:8px;
font-size:.75rem; line-height:1.5; display:none; text-align:center;
}
.diff-banner.visible { display:block; }
.diff-banner .new-tag { color:var(--new-block); font-weight:600; }
.diff-banner .changed-tag { color:var(--changed); font-weight:600; }
.diff-banner .removed-tag { color:#ff6b6b; font-weight:600; text-decoration:line-through; }

.controls { display:flex; justify-content:center; gap:12px; padding:12px 20px; flex-wrap:wrap; }
.controls button {
background:var(--surface2); border:1px solid var(--border); color:var(--text);
font-family:'JetBrains Mono',monospace; font-size:.75rem; padding:8px 16px;
border-radius:6px; cursor:pointer; transition:all .2s; letter-spacing:.5px;
position:relative;
}
.controls button:hover { border-color:var(--coherency); color:#fff; }
.controls button.active { background:var(--coherency); border-color:var(--coherency); color:#fff; }
.controls button.reset-btn { background:transparent; border-color:#ff6b6b50; color:#ff6b6b; }
.controls button.reset-btn:hover { background:#ff6b6b20; border-color:#ff6b6b; }

/* ‚îÄ‚îÄ Pause button ‚îÄ‚îÄ */
.controls button.pause-btn {
  background:transparent; border-color:#845ef760; color:#845ef7;
}
.controls button.pause-btn:hover { background:#845ef720; border-color:#845ef7; color:#c0a8ff; }
.controls button.pause-btn.active { background:#845ef7; border-color:#845ef7; color:#fff; }

/* ‚îÄ‚îÄ Atomic button ‚îÄ‚îÄ */
.controls button.atomic-btn {
  background: transparent; border-color: #f59e0b60; color: #f59e0b;
}
.controls button.atomic-btn:hover { background:#f59e0b18; border-color:#f59e0b; color:#fbbf24; }
.controls button.atomic-btn.apex-only { display:none; }

/* ‚îÄ‚îÄ Rich block info panel (arbiter etc.) ‚îÄ‚îÄ */
.arb-section { margin-bottom: 10px; }
.arb-section-title {
  font-family: 'JetBrains Mono', monospace; font-size: .6rem;
  text-transform: uppercase; letter-spacing: 1.5px;
  color: #f59e0b; margin-bottom: 5px; padding-bottom: 3px;
  border-bottom: 1px solid #f59e0b22;
}
.arb-section-title.green { color: #51cf66; border-bottom-color: #51cf6622; }
.arb-section-title.blue  { color: #339af0; border-bottom-color: #339af022; }
.arb-section-title.purple{ color: #a78bfa; border-bottom-color: #a78bfa22; }
.arb-section-title.pink  { color: #ffa94d; border-bottom-color: #ffa94d22; }
.arb-pipeline {
  display: flex; align-items: center; gap: 0; margin: 6px 0 8px;
  font-family: 'JetBrains Mono', monospace; font-size: .58rem;
}
.arb-step {
  background: #1a1d26; border: 1px solid #2a2d3a; border-radius: 4px;
  padding: 3px 6px; color: #aaa; white-space: nowrap; position: relative;
}
.arb-step.amber { border-color: #f59e0b50; color: #f59e0b; background: #f59e0b0a; }
.arb-step.green { border-color: #51cf6650; color: #51cf66; background: #51cf660a; }
.arb-step.blue  { border-color: #339af050; color: #339af0; background: #339af00a; }
.arb-step.orange{ border-color: #ffa94d50; color: #ffa94d; background: #ffa94d0a; }
.arb-step.purple{ border-color: #a78bfa50; color: #a78bfa; background: #a78bfa0a; }
.arb-arrow { color: #3a3d55; font-size: .65rem; padding: 0 2px; }
.arb-row { display: flex; gap: 6px; margin-bottom: 4px; font-size: .73rem; line-height: 1.5; }
.arb-row-label {
  font-family: 'JetBrains Mono', monospace; font-size: .6rem;
  color: #f59e0b; min-width: 60px; flex-shrink: 0; padding-top: 1px;
}
.arb-row-val { color: #c0c4d8; flex: 1; }
.arb-note { font-size: .7rem; color: #6b7094; line-height: 1.55; margin-bottom: 6px; font-style: italic; }
.arb-tag {
  display: inline-block; font-family: 'JetBrains Mono', monospace;
  font-size: .55rem; padding: 1px 5px; border-radius: 3px; margin: 1px 2px;
  border: 1px solid; vertical-align: middle;
}
.arb-tag.amber { color: #f59e0b; border-color: #f59e0b50; background: #f59e0b10; }
.arb-tag.green { color: #51cf66; border-color: #51cf6650; background: #51cf6610; }
.arb-tag.blue  { color: #339af0; border-color: #339af050; background: #339af010; }
.arb-tag.purple{ color: #a78bfa; border-color: #a78bfa50; background: #a78bfa10; }
.arb-tag.orange{ color: #ffa94d; border-color: #ffa94d50; background: #ffa94d10; }
.arb-divider { border: none; border-top: 1px solid #1e2030; margin: 8px 0; }
.tt-wide {
  max-width: 380px !important;
  min-width: 340px !important;
}
.tt-arb-section {
  margin-top: 8px;
  padding-top: 7px;
  border-top: 1px solid var(--border);
}
.tt-arb-label {
  font-family: 'JetBrains Mono', monospace;
  font-size: .56rem;
  color: #6b7090;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 4px;
}
.tt-arb-queue {
  display: flex;
  gap: 3px;
  flex-wrap: wrap;
  margin-bottom: 3px;
}
.tt-arb-slot {
  width: 26px; height: 18px;
  border-radius: 3px;
  background: #1e2030;
  border: 1px solid #2a2d3a;
  font-family: 'JetBrains Mono', monospace;
  font-size: .56rem;
  display: flex; align-items: center; justify-content: center;
  color: #6b7090;
  transition: all .2s;
}
.tt-arb-slot.occ { background:#f59e0b22; border-color:#f59e0b80; color:#fbbf24; }
.tt-arb-slot.ret { background:#339af022; border-color:#339af080; color:#339af0; }
.tt-arb-slot.don { background:#51cf6622; border-color:#51cf6680; color:#51cf66; }
.tt-arb-rob {
  display: flex;
  gap: 3px;
  margin-bottom: 3px;
}
.tt-arb-rob-slot {
  flex: 1;
  height: 16px;
  border-radius: 3px;
  background: #1e2030;
  border: 1px solid #2a2d3a;
  font-family: 'JetBrains Mono', monospace;
  font-size: .5rem;
  display: flex; align-items: center; justify-content: center;
  color: #6b7090;
}
.tt-arb-rob-slot.pend { background:#f59e0b18; border-color:#f59e0b50; color:#f59e0b; }
.tt-arb-rob-slot.comp { background:#339af018; border-color:#339af050; color:#339af0; }
.tt-arb-rob-slot.retr { background:#a78bfa18; border-color:#a78bfa50; color:#a78bfa; }
.tt-arb-rob-slot.done { background:#51cf6618; border-color:#51cf6650; color:#51cf66; }
.tt-arb-bar-bg {
  height: 5px; border-radius: 3px; background: #1e2030;
  overflow: hidden; margin: 3px 0;
}
.tt-arb-bar-fill {
  height: 100%; border-radius: 3px;
  background: linear-gradient(90deg, #51cf66, #f59e0b, #ff6b6b);
  transition: width .3s;
}
.tt-arb-grant-log {
  font-family: 'JetBrains Mono', monospace;
  font-size: .58rem;
  color: #6b7090;
  line-height: 1.7;
}
.tt-arb-grant-log .gs { color: #f59e0b; }
.tt-arb-grant-log .gc { color: #e0e2ec; }

/* ‚îÄ‚îÄ Latency badge on blocks ‚îÄ‚îÄ */
.lat-badge {
  position: absolute;
  pointer-events: none;
  z-index: 25;
  font-family: 'JetBrains Mono', monospace;
  font-size: .58rem;
  font-weight: 700;
  padding: 2px 7px;
  border-radius: 4px;
  border: 1px solid currentColor;
  opacity: 0;
  transition: opacity .2s;
  white-space: nowrap;
}
.lat-badge.visible { opacity: 1; }
.paused-badge.visible { display:block; }

/* ‚îÄ‚îÄ Scenario tooltip ‚îÄ‚îÄ */
#scenario-tooltip {
  position:fixed; pointer-events:none; z-index:300;
  background:#090b12; border:1px solid var(--border);
  border-radius:12px; padding:14px 16px; max-width:290px; min-width:220px;
  box-shadow:0 14px 44px rgba(0,0,0,.9);
  opacity:0; transition:opacity .15s, transform .15s;
  transform:translateY(6px);
  font-size:.75rem; line-height:1.6;
}
#scenario-tooltip.visible { opacity:1; transform:translateY(0); }
#scenario-tooltip .st-title {
  font-family:'JetBrains Mono',monospace; font-weight:700; font-size:.82rem;
  margin-bottom:8px; display:flex; align-items:center; gap:8px;
}
#scenario-tooltip .st-dot { width:8px; height:8px; border-radius:2px; flex-shrink:0; }
#scenario-tooltip .st-desc { color:#c8cce0; font-size:.75rem; line-height:1.55; margin-bottom:8px; }
#scenario-tooltip .st-detail {
  background:#0f1520; border:1px solid #339af020; border-radius:7px;
  padding:8px 10px;
}
#scenario-tooltip .st-detail-label {
  font-family:'JetBrains Mono',monospace; font-size:.55rem; font-weight:700;
  text-transform:uppercase; letter-spacing:1.5px; color:#339af099; margin-bottom:3px;
}
#scenario-tooltip .st-detail-text { color:#90c8f0; font-size:.72rem; line-height:1.5; }

.main-container { display:flex; gap:24px; padding:12px 20px; max-width:1400px; margin:0 auto; align-items:flex-start; }
.viz-area { flex:1; min-width:0; position:relative; }
canvas { width:100%; height:640px; background:var(--surface); border-radius:12px; border:1px solid var(--border); display:block; cursor:default; }
@media(max-width:500px){ canvas { height:580px; } .viz-area { max-width:none; } }

/* ‚îÄ‚îÄ Tooltip ‚îÄ‚îÄ */
#block-tooltip {
  position:absolute; pointer-events:none; z-index:100;
  background:#0d0f16; border:1px solid var(--border);
  border-radius:10px; padding:11px 14px; max-width:240px;
  box-shadow: 0 8px 32px rgba(0,0,0,.7);
  opacity:0; transition:opacity .15s;
  font-size:.75rem; line-height:1.55;
}
#block-tooltip.visible { opacity:1; }
#block-tooltip .tt-title { font-weight:700; font-size:.85rem; margin-bottom:6px; display:flex; align-items:center; gap:7px; }
#block-tooltip .tt-dot { width:9px; height:9px; border-radius:3px; flex-shrink:0; }
#block-tooltip .tt-desc { color:var(--dim); margin-bottom:7px; }
#block-tooltip .tt-meta { display:flex; flex-wrap:wrap; gap:5px; }
#block-tooltip .tt-chip {
  font-family:'JetBrains Mono',monospace; font-size:.6rem; font-weight:600;
  padding:2px 7px; border-radius:4px;
}
#block-tooltip .tt-hint {
  margin-top:8px; padding-top:6px; border-top:1px solid var(--border);
  font-size:.65rem; color:#6b7094; font-family:'JetBrains Mono',monospace;
  display:flex; align-items:center; gap:5px;
}
#block-tooltip .tt-hint::before { content:'‚óâ'; font-size:.7rem; }

/* ‚îÄ‚îÄ Instruction tooltip ‚îÄ‚îÄ */
#instr-tooltip {
  position:fixed; pointer-events:none; z-index:200;
  background:#080a10; border:1px solid var(--border);
  border-radius:12px; padding:14px 16px; max-width:310px; min-width:240px;
  box-shadow: 0 12px 40px rgba(0,0,0,.85);
  opacity:0; transition:opacity .15s, transform .15s;
  transform:translateY(4px);
  font-size:.75rem; line-height:1.6;
}
#instr-tooltip.visible { opacity:1; transform:translateY(0); }
#instr-tooltip .it-name {
  font-family:'JetBrains Mono',monospace; font-weight:700; font-size:.82rem;
  margin-bottom:8px; display:flex; align-items:center; gap:8px;
}
#instr-tooltip .it-dot { width:8px; height:8px; border-radius:2px; flex-shrink:0; }
#instr-tooltip .it-section { margin-bottom:8px; }
#instr-tooltip .it-label {
  font-family:'JetBrains Mono',monospace; font-size:.55rem; font-weight:700;
  text-transform:uppercase; letter-spacing:1.5px; color:#6b7094; margin-bottom:3px;
}
#instr-tooltip .it-text { color:#c8cce0; font-size:.74rem; line-height:1.55; }
#instr-tooltip .it-why-box {
  background:#0f1a12; border:1px solid #51cf6625; border-radius:7px;
  padding:8px 10px; margin-top:6px;
}
#instr-tooltip .it-why-box .it-label { color:#51cf6699; }
#instr-tooltip .it-why-box .it-text { color:#a0dbb0; }

/* ‚îÄ‚îÄ Selection panel ‚îÄ‚îÄ */
#sel-panel {
  background:var(--surface); border:1px solid var(--border); border-radius:10px;
  padding:14px; display:none; margin-top:12px;
}
#sel-panel { max-height: 70vh; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #2a2d3a transparent; }
#sel-panel.visible { display:block; }
#sel-panel h4 { font-size:.65rem; font-family:'JetBrains Mono',monospace; text-transform:uppercase; letter-spacing:2px; color:var(--dim); margin-bottom:10px; }
#sel-panel .sel-name { font-weight:700; font-size:.95rem; margin-bottom:6px; }
#sel-panel .sel-desc { font-size:.78rem; color:var(--dim); line-height:1.55; margin-bottom:10px; }
#sel-panel .sel-connections { }
#sel-panel .sel-connections h5 { font-size:.6rem; font-family:'JetBrains Mono',monospace; text-transform:uppercase; letter-spacing:1.5px; color:var(--dim); margin-bottom:7px; }
#sel-panel .conn-list { display:flex; flex-direction:column; gap:5px; }
#sel-panel .conn-item {
  display:flex; align-items:flex-start; gap:8px; padding:7px 10px;
  background:var(--bg); border-radius:6px; border:1px solid var(--border);
  font-size:.75rem; line-height:1.45; cursor:pointer; transition:border-color .15s;
}
#sel-panel .conn-item:hover { border-color: #4a4d5a; }
#sel-panel .conn-item .ci-arrow { font-family:'JetBrains Mono',monospace; font-size:.7rem; flex-shrink:0; margin-top:1px; }
#sel-panel .conn-item .ci-body { flex:1; }
#sel-panel .conn-item .ci-target { font-weight:600; }
#sel-panel .conn-item .ci-why { color:var(--dim); font-size:.7rem; display:block; }
#sel-panel .close-btn { float:right; font-size:.7rem; color:var(--dim); cursor:pointer; font-family:'JetBrains Mono',monospace; padding:2px 6px; border:1px solid var(--border); border-radius:4px; }
#sel-panel .close-btn:hover { color:var(--text); }

.info-panel { width:360px; flex-shrink:0; display:flex; flex-direction:column; gap:12px; }
.info-card { background:var(--surface); border:1px solid var(--border); border-radius:10px; padding:14px; }
.info-card h3 { font-size:.65rem; font-family:'JetBrains Mono',monospace; text-transform:uppercase; letter-spacing:2px; color:var(--dim); margin-bottom:10px; }

/* Instruction reference chips */
.instr-section { margin-top:0; }
.instr-chips { display:flex; flex-wrap:wrap; gap:8px; }
.instr-chip {
  font-family:'JetBrains Mono',monospace; font-size:.72rem; font-weight:700;
  padding:5px 11px; border-radius:6px; cursor:pointer;
  border:1px solid transparent; transition:all .15s;
  user-select:none;
}
.instr-chip:hover { transform:translateY(-1px); box-shadow:0 4px 14px rgba(0,0,0,.4); }

.bottom-section { max-width:1200px; margin:0 auto; padding:0 20px 30px; }
.bottom-grid { display:grid; grid-template-columns:1fr 1fr; gap:16px; }

@media(min-width:1101px) {
.perf-bars { height:32px; }
.perf-bar-val { font-size:.58rem; }
.perf-label { min-width:70px; font-size:.75rem; }
}

.acc-item { border-bottom:1px solid var(--border); }
.acc-item:last-child { border-bottom:none; }
.acc-head { display:flex; align-items:center; gap:8px; padding:8px 0; cursor:pointer; user-select:none; -webkit-user-select:none; }
.acc-head:active { opacity:.7; }
.acc-dot { width:8px; height:8px; border-radius:3px; flex-shrink:0; }
.acc-title { flex:1; font-weight:600; font-size:.8rem; }
.acc-meta { font-family:'JetBrains Mono',monospace; font-size:.6rem; color:var(--dim); }
.acc-chev { font-size:.65rem; color:var(--dim); transition:transform .25s; }
.acc-item.open .acc-chev { transform:rotate(90deg); }
.acc-body { max-height:0; overflow:hidden; transition:max-height .3s,padding .3s; padding:0 0 0 16px; }
.acc-item.open .acc-body { max-height:350px; padding:0 0 8px 16px; }
.acc-body p { font-size:.75rem; line-height:1.5; color:var(--dim); margin:0; }
.acc-body p strong { color:var(--text); }
.acc-badge-new { font-size:.55rem; background:var(--new-block); color:#000; padding:1px 5px; border-radius:3px; font-weight:700; margin-left:4px; }
.acc-badge-changed { font-size:.55rem; background:var(--changed); color:#000; padding:1px 5px; border-radius:3px; font-weight:700; margin-left:4px; }

.stats-grid { display:grid; grid-template-columns:1fr 1fr; gap:6px; }
.stat-item { background:var(--bg); border-radius:6px; padding:8px; text-align:center; }
.stat-value { font-size:1.3rem; font-weight:700; font-family:'JetBrains Mono',monospace; }
.stat-label { font-size:.6rem; color:var(--dim); text-transform:uppercase; letter-spacing:1px; margin-top:1px; }

.state-row { display:flex; align-items:center; gap:8px; margin-bottom:6px; font-size:.8rem; }
.state-dot { width:8px; height:8px; border-radius:50%; flex-shrink:0; }
.state-label { font-weight:600; min-width:70px; }
.state-desc { color:var(--dim); font-size:.73rem; }

.explainer { position:relative; overflow:hidden; min-height:100px; max-height:400px; }
.explainer::before { content:''; position:absolute; top:0; left:0; right:0; height:3px;
background:linear-gradient(90deg,var(--l1),var(--l2),var(--smem),var(--global),var(--dram)); border-radius:10px 10px 0 0; opacity:.6; }
.explainer-title { font-weight:700; font-size:.95rem; margin-bottom:8px; display:flex; align-items:center; gap:8px; }
.explainer-title .dot { width:8px; height:8px; border-radius:50%; animation:pulse-dot 1.5s ease-in-out infinite; }
@keyframes pulse-dot { 0%,100%{opacity:.5;transform:scale(1)} 50%{opacity:1;transform:scale(1.3)} }
.step-list { list-style:none; max-height:220px; overflow-y:auto; overscroll-behavior:contain; scrollbar-width:thin; scrollbar-color:var(--border) transparent; }
.step-list::-webkit-scrollbar{width:4px} .step-list::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px}
.step-list li { display:flex; align-items:flex-start; gap:8px; padding:5px 0; font-size:.78rem; line-height:1.4; opacity:0; transform:translateX(-6px); transition:opacity .4s,transform .4s; }
.step-list li.visible { opacity:1; transform:translateX(0); }
.step-list li.active { opacity:1; transform:translateX(0); }
.step-list li.past { opacity:.4; }
.step-num { font-family:'JetBrains Mono',monospace; font-size:.65rem; font-weight:600; min-width:18px; height:18px; display:flex; align-items:center; justify-content:center; border-radius:4px; flex-shrink:0; }
.step-text { flex:1; }
.step-text .micro { display:block; font-size:.68rem; color:var(--dim); font-family:'JetBrains Mono',monospace; margin-top:1px; }
.explainer-summary { margin-top:8px; padding-top:8px; border-top:1px solid var(--border); font-size:.73rem; color:var(--dim); font-style:italic; opacity:0; transition:opacity .5s; }
.explainer-summary.visible { opacity:1; }

.event-log { max-height:160px; overflow-y:auto; overscroll-behavior:contain; scrollbar-width:thin; scrollbar-color:var(--border) transparent; }
.event-log::-webkit-scrollbar{width:4px} .event-log::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px}
.log-entry { font-family:'JetBrains Mono',monospace; font-size:.65rem; padding:3px 0; border-bottom:1px solid rgba(42,45,58,.5); color:var(--dim); animation:fadeIn .3s; }
.log-entry .tag { display:inline-block; padding:1px 5px; border-radius:3px; font-size:.6rem; margin-right:3px; }
@keyframes fadeIn { from{opacity:0;transform:translateY(-4px)} to{opacity:1;transform:translateY(0)} }

.arch-intro { max-width:1200px; margin:6px auto 0; padding:0 20px; }
.arch-intro-inner {
background:var(--surface); border:1px solid var(--border); border-radius:10px;
padding:14px 16px; display:flex; gap:14px; align-items:flex-start;
}
.arch-intro-badge {
font-family:'JetBrains Mono',monospace; font-size:.6rem; font-weight:700;
padding:4px 10px; border-radius:5px; white-space:nowrap; flex-shrink:0; margin-top:2px;
}
.arch-intro-text { font-size:.8rem; line-height:1.55; color:var(--dim); }
.arch-intro-text strong { color:var(--text); }

.easy-card { border-left:3px solid var(--smem); }
.easy-card h3 span { color:var(--smem); font-size:.6rem; margin-left:6px; font-weight:400; }
.easy-q { padding:8px 0; border-bottom:1px solid var(--border); cursor:pointer; user-select:none; -webkit-user-select:none; }
.easy-q:last-child { border-bottom:none; }
.easy-q:active { opacity:.7; }
.easy-head { display:flex; align-items:center; gap:8px; }
.easy-emoji { font-size:1rem; flex-shrink:0; width:22px; text-align:center; }
.easy-title { flex:1; font-weight:600; font-size:.82rem; }
.easy-chev { font-size:.65rem; color:var(--dim); transition:transform .25s; }
.easy-q.open .easy-chev { transform:rotate(90deg); }
.easy-body { max-height:0; overflow:hidden; transition:max-height .3s,padding .3s; padding:0 0 0 30px; }
.easy-q.open .easy-body { max-height:500px; padding:4px 0 6px 30px; }
.easy-body p { font-size:.78rem; line-height:1.6; color:var(--dim); margin:0 0 6px; }
.easy-body p strong { color:var(--text); }
.easy-body .analogy { font-style:italic; color:var(--smem); font-size:.73rem; }

.perf-card h3 { margin-bottom:12px; }
.perf-row { display:flex; align-items:center; gap:8px; margin-bottom:8px; }
.perf-label { font-size:.7rem; font-family:'JetBrains Mono',monospace; color:var(--dim); min-width:65px; flex-shrink:0; }
.perf-bars { flex:1; display:flex; gap:2px; height:28px; align-items:flex-end; }
.perf-bar {
flex:1; border-radius:2px 2px 0 0; position:relative; min-height:2px;
transition:height .4s ease; display:flex; align-items:flex-end; justify-content:center;
}
.perf-bar-val {
font-family:'JetBrains Mono',monospace; font-size:.5rem; font-weight:600;
position:absolute; top:-12px; width:100%; text-align:center; white-space:nowrap;
}
.perf-bar.active { outline:1px solid #fff3; outline-offset:1px; }
.perf-legend { display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; justify-content:center; }
.perf-legend-item { display:flex; align-items:center; gap:4px; font-size:.6rem; font-family:'JetBrains Mono',monospace; color:var(--dim); }
.perf-legend-dot { width:8px; height:8px; border-radius:2px; }

@media(max-width:1100px) {
.main-container { flex-direction:column; }
.info-panel { width:100%; flex-direction:row; flex-wrap:wrap; }
.info-card { flex:1; min-width:260px; }
.bottom-grid { grid-template-columns:1fr; }
}
</style>
</head>
<body>
<div class="grain"></div>

<header>
  <h1>GPU Cache Coherency</h1>
  <p>Architecture Explorer ¬∑ Memory Hierarchy ¬∑ Data Flow</p>
</header>

<div class="arch-tabs" id="arch-tabs">
  <div class="arch-tab active" data-arch="pascal" style="--accent-color:#51cf66" onclick="switchArch('pascal')">Pascal<span class="tab-gen">SM 6.1 ¬∑ 2016</span></div>
  <div class="arch-tab" data-arch="volta" style="--accent-color:#339af0" onclick="switchArch('volta')">Volta<span class="tab-gen">SM 7.0 ¬∑ 2017</span></div>
  <div class="arch-tab" data-arch="ampere" style="--accent-color:#ffa94d" onclick="switchArch('ampere')">Ampere<span class="tab-gen">SM 8.0 ¬∑ 2020</span></div>
  <div class="arch-tab" data-arch="hopper" style="--accent-color:#845ef7" onclick="switchArch('hopper')">Hopper<span class="tab-gen">SM 9.0 ¬∑ 2022</span></div>
  <div class="arch-tab" data-arch="apex" style="--accent-color:#f59e0b" onclick="switchArch('apex')">Apex ‚ú¶<span class="tab-gen">SM 10.0 ¬∑ Concept</span></div>
</div>

<div class="diff-banner" id="diff-banner"></div>
<div class="arch-intro"><div class="arch-intro-inner" id="arch-intro"></div></div>

<div class="controls">
  <button class="scenario-btn" data-scenario="read"   onclick="triggerScenario('read')">SM Read</button>
  <button class="scenario-btn" data-scenario="write"  onclick="triggerScenario('write')">SM Write</button>
  <button class="scenario-btn" data-scenario="invalidate" onclick="triggerScenario('invalidate')">Invalidate</button>
  <button class="scenario-btn" data-scenario="writeback"  onclick="triggerScenario('writeback')">Write-Back</button>
  <button class="scenario-btn" data-scenario="shared"     onclick="triggerScenario('shared')">Shared Mem</button>
  <button class="scenario-btn atomic-btn" data-scenario="atomic" onclick="triggerScenario('atomic')" id="btn-atomic">‚öõ atomicAdd</button>
  <button id="btn-pause" class="pause-btn" onclick="togglePause()">‚è∏ Pause</button>
  <button id="btn-auto" class="active" onclick="toggleAuto()">Auto</button>
  <button class="reset-btn" onclick="resetAll()">Reset</button>
</div>

<div class="main-container">
  <div class="viz-area">
    <canvas id="canvas"></canvas>
    <!-- paused badge removed -->
    <!-- Block tooltip -->
    <div id="block-tooltip">
      <div class="tt-title"><div class="tt-dot" id="tt-dot"></div><span id="tt-name"></span></div>
      <div class="tt-desc" id="tt-desc"></div>
      <div class="tt-meta" id="tt-meta"></div>
      <div class="tt-hint" id="tt-hint">Click to explore connections</div>
    </div>
    <!-- Selection panel -->
    <div id="sel-panel">
      <span class="close-btn" onclick="clearSelection()">‚úï close</span>
      <h4>Block Selected</h4>
      <div class="sel-name" id="sel-name"></div>
      <div class="sel-desc" id="sel-desc"></div>
      <div class="sel-connections">
        <h5>Connects To</h5>
        <div class="conn-list" id="conn-list"></div>
      </div>
    </div>
  </div>
  <div class="info-panel">
    <div class="info-card" id="key-card"></div>
    <div class="info-card">
      <h3>Cache States (MSI)</h3>
      <div class="state-row"><div class="state-dot" style="background:#51cf66"></div><span class="state-label">Modified</span><span class="state-desc">Dirty, exclusive</span></div>
      <div class="state-row"><div class="state-dot" style="background:#339af0"></div><span class="state-label">Shared</span><span class="state-desc">Clean, multi-reader</span></div>
      <div class="state-row"><div class="state-dot" style="background:#555"></div><span class="state-label">Invalid</span><span class="state-desc">Stale / absent</span></div>
    </div>
    <div class="info-card">
      <h3>Live Stats</h3>
      <div class="stats-grid">
        <div class="stat-item"><div class="stat-value" id="stat-hits" style="color:var(--smem)">0</div><div class="stat-label">Hits</div></div>
        <div class="stat-item"><div class="stat-value" id="stat-misses" style="color:var(--l1)">0</div><div class="stat-label">Misses</div></div>
        <div class="stat-item"><div class="stat-value" id="stat-inv" style="color:var(--coherency)">0</div><div class="stat-label">Invalidations</div></div>
        <div class="stat-item"><div class="stat-value" id="stat-wb" style="color:var(--l2)">0</div><div class="stat-label">Write-Backs</div></div>
      </div>
    </div>
    <div class="info-card explainer" id="explainer-card">
      <h3>What's Happening</h3>
      <div id="explainer-title" class="explainer-title" style="color:var(--dim)"><span class="dot" style="background:var(--dim)"></span>Click a scenario or wait for auto...</div>
      <ol class="step-list" id="step-list"></ol>
      <div class="explainer-summary" id="explainer-summary"></div>
    </div>
    <div class="info-card">
      <h3>Event Log</h3>
      <div class="event-log" id="event-log"></div>
    </div>
  </div>
</div>

<div class="bottom-section">
  <div class="bottom-grid">
    <div class="info-card easy-card">
      <h3>Easy Explain <span>for beginners</span></h3>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">üè†</span><span class="easy-title">What is a cache?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p>A cache is a <strong>small, fast storage</strong> that keeps copies of frequently used data close to where it's needed.</p><p class="analogy">Analogy: Your desk (cache) vs the library (main memory). You keep the books you're reading on your desk so you don't have to walk to the library every time.</p></div>
      </div>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">ü§ù</span><span class="easy-title">What is cache coherency?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p>When <strong>multiple processors</strong> (SMs) each have their own cache, they might hold different copies of the same data. Cache coherency keeps everyone's copies consistent.</p></div>
      </div>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">üì¶</span><span class="easy-title">What is an SM?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p>A <strong>Streaming Multiprocessor</strong> is the GPU's core compute unit. Each SM runs thousands of threads in parallel using "warps" (groups of 32 threads).</p></div>
      </div>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">‚ö°</span><span class="easy-title">Shared memory vs L1?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p><strong>L1</strong> is automatic ‚Äî hardware decides what to cache. <strong>Shared memory</strong> is manual ‚Äî programmer explicitly loads data. Faster and predictable, but more work.</p></div>
      </div>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">üö´</span><span class="easy-title">What does "invalidate" mean?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p>When one SM writes, others' cached copies become <strong>outdated</strong>. Invalidation says "throw away your copy." Next access fetches fresh from L2.</p></div>
      </div>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">üîÑ</span><span class="easy-title">What does "write-evict" mean?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p>Instead of keeping a dirty copy in L1, the SM <strong>drops the L1 copy entirely</strong> and writes straight to L2. Simpler than CPU write-back but more L2 traffic.</p></div>
      </div>
    </div>
  </div>
</div>

<div class="bottom-section instr-section">
  <div class="bottom-grid">
    <div class="info-card" id="instr-ref-card">
      <h3>Instruction Reference <span style="font-size:.6rem;color:var(--dim);font-weight:400;font-family:'JetBrains Mono',monospace;text-transform:uppercase;letter-spacing:1px">‚Äî hover any chip</span></h3>
      <div class="instr-chips" id="instr-chips"></div>
    </div>
  </div>
</div>

<!-- Scenario tooltip at body level -->
<div id="scenario-tooltip">
  <div class="st-title"><div class="st-dot" id="st-dot"></div><span id="st-title-text"></span></div>
  <div class="st-desc" id="st-desc-text"></div>
  <div class="st-detail">
    <div class="st-detail-label">What to watch for</div>
    <div class="st-detail-text" id="st-watch-text"></div>
  </div>
</div>

<!-- Instruction tooltip at body level so fixed positioning works correctly -->
<div id="instr-tooltip">
  <div class="it-name"><div class="it-dot" id="it-dot"></div><span id="it-name"></span></div>
  <div class="it-section">
    <div class="it-label">What it does</div>
    <div class="it-text" id="it-what"></div>
  </div>
  <div class="it-why-box">
    <div class="it-label">Why you need this op</div>
    <div class="it-text" id="it-why"></div>
  </div>
</div>

<script>
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
var W, H, dpr;
var initialized = false;

// ‚îÄ‚îÄ Pause state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
var paused = false;

function togglePause() {
  paused = !paused;
  var btn = document.getElementById('btn-pause');
  var badge = document.getElementById('paused-badge');
  if (paused) {
    btn.classList.add('active');
    btn.textContent = '‚ñ∂ Resume';
    badge.classList.add('visible');
    // Also stop auto when pausing
    if (autoMode) { autoMode = false; document.getElementById('btn-auto').classList.remove('active'); }
    logEvent('Paused ‚Äî animation frozen', '#845ef7');
  } else {
    btn.classList.remove('active');
    btn.textContent = '‚è∏ Pause';
    badge.classList.remove('visible');
    lastTime = performance.now(); // reset dt so we don't get a big jump
    logEvent('Resumed', '#845ef7');
  }
}

// ‚îÄ‚îÄ Scenario button tooltip data ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
var SCENARIO_INFO = {
  read: {
    title: 'SM Read  (L1 Miss ‚Üí L2 Fetch)',
    color: '#ff6b6b',
    desc: 'A warp issues a global load (LD.E). The SM checks its L1 ‚Äî on a miss, it sends a read request down to L2. The cache line travels back and fills L1.',
    watch: 'Watch the RdReq particle travel SM‚ÜíBus‚ÜíL2, then DATA come back and fill the L1 line. L1 state transitions: Invalid ‚Üí Shared.'
  },
  write: {
    title: 'SM Write  (write-evict + INV)',
    color: '#51cf66',
    desc: 'Pascal: writes bypass L1 and go straight to L2 (write-through). Volta+: SM writes to L1 (Modified), then evicts to L2 and broadcasts INV to invalidate other SMs\' copies.',
    watch: 'On Volta+: see the INV packets fan out to all other SMs, turning their L1 lines grey (Invalid). On Pascal: just a direct WR to L2, no INV needed.'
  },
  invalidate: {
    title: 'Broadcast Invalidation',
    color: '#f06595',
    desc: 'A global coherency event ‚Äî a write happened somewhere and all cached copies of that address must be dropped. The coherency bus broadcasts INV to every SM simultaneously.',
    watch: 'INV packets fire from the bus center to all SMs in parallel. Each SM\'s L1 transitions to Invalid (grey). Cost scales linearly with SM count ‚Äî this is why write-heavy kernels are expensive.'
  },
  writeback: {
    title: 'Write-Back Cascade (L1‚ÜíL2‚ÜíDRAM)',
    color: '#ffa94d',
    desc: 'A dirty L1 line is being evicted (capacity pressure). It writes to L2. If L2 is also full, the victim cascades all the way to DRAM through the memory controller.',
    watch: 'The full eviction chain: WB particle L1‚ÜíBus‚ÜíL2, then EVICT particle L2‚ÜíCrossbar‚ÜíGlobal Mem‚ÜíHBM. The HBM block flashes purple at the end ‚Äî data is now only in DRAM.'
  },
  shared: {
    title: 'Shared Memory Access (+ DSMEM on Hopper)',
    color: '#51cf66',
    desc: 'Threads access __shared__ SRAM via LDS/STS ‚Äî no coherency protocol, no bus traffic, no L2 involvement. Pure on-chip speed. Hopper adds DSMEM: cross-SM shared memory within a cluster.',
    watch: 'Notice: no bus or L2 activity at all. The particles stay entirely inside the SM. On Hopper, a second DSMEM particle crosses to the adjacent SM ‚Äî still on-chip, ~20 cycle latency.'
  },
  atomic: {
    title: '‚öõ atomicAdd ‚Äî Hardware Serialization',
    color: '#f59e0b',
    desc: 'Multiple SMs simultaneously call atomicAdd() to the same address. Without an arbiter, two SMs could both read the value, add to it, and one result gets silently lost. The Apex Arbiter prevents this by serializing all requests with sequence numbers.',
    watch: 'On Apex: watch ATOM packets queue in the Arbiter panel (hover it to expand). Each gets a SEQ#. GRANTs fire one at a time. On older archs: watch the raw bus contention with no coordination ‚Äî and imagine the race conditions without hardware atomics.'
  }
};

var scenarioTooltipEl = document.getElementById('scenario-tooltip');
var scenarioVisible = false;

function showScenarioTooltip(key, clientX, clientY) {
  var info = SCENARIO_INFO[key];
  if (!info) return;
  document.getElementById('st-dot').style.background = info.color;
  scenarioTooltipEl.style.borderColor = info.color + '50';
  document.getElementById('st-title-text').textContent = info.title;
  document.getElementById('st-desc-text').textContent = info.desc;
  document.getElementById('st-watch-text').textContent = info.watch;
  positionScenarioTooltip(clientX, clientY);
  scenarioTooltipEl.classList.add('visible');
  scenarioVisible = true;
}

function hideScenarioTooltip() {
  scenarioTooltipEl.classList.remove('visible');
  scenarioVisible = false;
}

function positionScenarioTooltip(clientX, clientY) {
  var tw = 300, th = 200;
  var vw = window.innerWidth, vh = window.innerHeight;
  var tx = clientX - tw / 2;
  var ty = clientY - th - 14; // above the button
  if (tx + tw > vw - 10) tx = vw - tw - 10;
  if (tx < 8) tx = 8;
  if (ty < 8) ty = clientY + 40; // flip below if no room above
  scenarioTooltipEl.style.left = tx + 'px';
  scenarioTooltipEl.style.top  = ty + 'px';
}

// Attach hover listeners to scenario buttons
document.querySelectorAll('.scenario-btn').forEach(function(btn) {
  var key = btn.getAttribute('data-scenario');
  btn.addEventListener('mouseenter', function(e) {
    showScenarioTooltip(key, e.clientX, e.clientY);
  });
  btn.addEventListener('mousemove', function(e) {
    positionScenarioTooltip(e.clientX, e.clientY);
  });
  btn.addEventListener('mouseleave', function() {
    hideScenarioTooltip();
  });
});

function resize() {
  dpr = window.devicePixelRatio || 1;
  var r = canvas.getBoundingClientRect();
  var newW = r.width || canvas.offsetWidth || 640;
  var newH = r.height || canvas.offsetHeight || 520;
  if (newW === W && newH === H) return;
  W = newW; H = newH;
  canvas.width  = Math.round(W * dpr);
  canvas.height = Math.round(H * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  if (initialized) buildLayout();
}

window.addEventListener('resize', resize);

function rrect(x, y, w, h, r) {
  r = Math.min(r, w/2, h/2);
  ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y);
  ctx.arcTo(x+w,y,x+w,y+r,r); ctx.lineTo(x+w,y+h-r);
  ctx.arcTo(x+w,y+h,x+w-r,y+h,r); ctx.lineTo(x+r,y+h);
  ctx.arcTo(x,y+h,x,y+h-r,r); ctx.lineTo(x,y+r);
  ctx.arcTo(x,y,x+r,y,r); ctx.closePath();
}

var BLOCK_INFO = {
  regs:      { name:'Register File', color:'#a8b0d0', desc:'Fastest storage on the chip. Each thread gets its own private registers ‚Äî no sharing, no coherency needed. 32-bit per lane, ~255 per thread.', chips:[{t:'~1 cycle',c:'#51cf66'},{t:'private',c:'#339af0'}], connects:[{to:'l1',arrow:'‚Üí',why:'Spill registers to L1 when exhausted (register spilling)'},{to:'smem',arrow:'‚Üî',why:'Threads read/write shared mem via LDS/STS instructions'}] },
  l1:        { name:'L1 Cache (unified)', color:'#ff6b6b', desc:'Per-SM cache. Pascal: read-only for global data ‚Äî zero coherency overhead. Volta+: caches writes too, requires invalidation protocol when another SM writes to the same address.', chips:[{t:'~28 cycles',c:'#ffa94d'},{t:'per-SM',c:'#339af0'}], connects:[{to:'bus',arrow:'‚Üí',why:'Miss ‚Üí sends RdReq or INV across coherency bus'},{to:'smem',arrow:'‚Üî',why:'Shares physical SRAM pool (Volta+); split is software-configurable'},{to:'regs',arrow:'‚Üê',why:'Fills data into thread registers on cache hit/fill'}] },
  texCache:  { name:'Texture Cache (TEX$)', color:'#e599f7', desc:'Separate read-only cache optimized for 2D spatial locality. Used for sampled textures. Pascal keeps this distinct from L1; Volta+ merged them.', chips:[{t:'read-only',c:'#e599f7'},{t:'~24KB',c:'#a0a0a0'}], connects:[{to:'l2',arrow:'‚Üí',why:'All misses fetch from L2'},{to:'regs',arrow:'‚Üê',why:'Filtered/sampled results go into registers'}] },
  smem:      { name:'Shared Memory (SMEM)', color:'#51cf66', desc:'Software-managed on-chip SRAM. Threads in the same CTA (thread block) share this scratchpad. No coherency protocol ‚Äî programmer controls all reads/writes explicitly. 32 memory banks.', chips:[{t:'~20 cycles',c:'#51cf66'},{t:'per-CTA',c:'#339af0'},{t:'no coherency',c:'#f06595'}], connects:[{to:'regs',arrow:'‚Üî',why:'LDS/STS instructions move data between threads and SMEM'},{to:'l1',arrow:'‚Üî',why:'Shares the same physical SRAM as L1 (Volta+), split is configurable'},{to:'async',arrow:'‚Üê',why:'cp.async loads data from global memory directly into SMEM (Ampere+)'}] },
  tma:       { name:'Tensor Memory Accelerator (TMA)', color:'#22d3ee', desc:'Hopper hardware DMA engine. Handles bulk multi-dimensional tensor transfers between global memory and SMEM. Offloads address calculation from threads, freeing them for compute.', chips:[{t:'NEW: Hopper',c:'#22d3ee'},{t:'hardware DMA',c:'#845ef7'}], connects:[{to:'smem',arrow:'‚Üí',why:'Deposits tensor tiles directly into SMEM with tensor-aware addressing'},{to:'globalMem',arrow:'‚Üê',why:'Reads from global memory with N-D tensor coordinate logic'}] },
  dsmem:     { name:'Distributed Shared Memory (DSMEM)', color:'#22d3ee', desc:'Hopper feature. SMs within the same Thread Block Cluster can directly read each other\'s shared memory ‚Äî at roughly SMEM latency ‚Äî without going through L2. Enables tighter SM cooperation.', chips:[{t:'NEW: Hopper',c:'#22d3ee'},{t:'cluster-scope',c:'#845ef7'},{t:'~20 cycles',c:'#51cf66'}], connects:[{to:'smem',arrow:'‚Üî',why:'DSMEM is a window into another SM\'s SMEM within the cluster'},{to:'bus',arrow:'‚Üî',why:'Cluster bus carries cross-SM DSMEM traffic'}] },
  async:     { name:'Async Copy (cp.async)', color:'#22d3ee', desc:'Ampere+ instruction that moves data from global to shared memory without occupying registers or stalling the warp. Like a mini-DMA per thread, enabling compute-memory overlap.', chips:[{t:'Ampere+',c:'#ffa94d'},{t:'bypass regs',c:'#51cf66'}], connects:[{to:'smem',arrow:'‚Üí',why:'Destination: deposits data directly into SMEM'},{to:'globalMem',arrow:'‚Üê',why:'Source: reads from global memory without touching registers'}] },
  bus:       { name:'Coherency Bus / Crossbar', color:'#f06595', desc:'The shared interconnect between all SMs and the L2. Carries read requests, data responses, and invalidation messages. Pascal uses a simple crossbar (L1 is read-only). Volta+ must broadcast INV messages when writes occur.', chips:[{t:'shared fabric',c:'#f06595'},{t:'broadcast INV',c:'#339af0'}], connects:[{to:'l1',arrow:'‚Üî',why:'Delivers RdReq/DATA/INV messages to each SM\'s L1'},{to:'l2',arrow:'‚Üî',why:'Connects all SMs to the shared L2 cache'}] },
  l2:        { name:'L2 Cache (unified)', color:'#ffa94d', desc:'Shared by all SMs ‚Äî the point of coherence. All cache lines must pass through L2. Ampere introduced 10√ó larger L2 (40 MB) with software-controlled persistence windows. Hopper: 50 MB.', chips:[{t:'~200 cycles',c:'#ffa94d'},{t:'unified',c:'#339af0'},{t:'coherence point',c:'#f06595'}], connects:[{to:'bus',arrow:'‚Üî',why:'Serves read/write requests from all SMs via the coherency bus'},{to:'globalMem',arrow:'‚Üî',why:'Evicts dirty lines down to DRAM; fetches missing lines up on miss'}] },
  l2Persist: { name:'L2 Persistence Window', color:'#ffa94d', desc:'Ampere+ feature. You can pin a set of addresses to always stay in L2. Useful for weights or lookup tables accessed repeatedly across many kernels. Set via cudaAccessPolicyWindow.', chips:[{t:'Ampere+',c:'#ffa94d'},{t:'software ctrl',c:'#51cf66'}], connects:[{to:'l2',arrow:'‚Üî',why:'A sub-region of the L2 pinned via CUDA API policy'},{to:'globalMem',arrow:'‚Üê',why:'Persistently caches frequently-read global data in L2'}] },
  globalMem: { name:'Global Memory Interface', color:'#339af0', desc:'The on-chip logic (memory controllers + NoC) that bridges L2 to physical DRAM. Handles address translation, ECC, and row/bank scheduling. Multiple controllers run in parallel for bandwidth.', chips:[{t:'memory ctrl',c:'#339af0'},{t:'multi-channel',c:'#845ef7'}], connects:[{to:'l2',arrow:'‚Üî',why:'Receives evictions from L2; returns fetched DRAM data to L2'},{to:'hbm',arrow:'‚Üî',why:'Issues actual read/write commands to HBM stacks'}] },
  hbm:       { name:'HBM / GDDR (DRAM)', color:'#845ef7', desc:'Off-chip high-bandwidth memory. HBM stacks dies vertically connected via micro-bumps. Hopper HBM3 = 3.35 TB/s. Slowest in the hierarchy but largest ‚Äî all GPU memory ultimately lives here.', chips:[{t:'~400 cycles',c:'#ff6b6b'},{t:'off-chip',c:'#845ef7'},{t:'largest',c:'#6b7094'}], connects:[{to:'globalMem',arrow:'‚Üî',why:'Memory controllers read/write HBM banks via wide parallel buses'}] },
  arbiter: {
    name: 'Atomic Arbiter',
    color: '#f59e0b',
    desc: 'Hardware serialization unit for atomic operations.',
    descHTML: `
<div class="arb-section">
  <div class="arb-section-title">What it does</div>
  <div class="arb-note">Every <code>atomicAdd</code>, <code>atomicCAS</code>, <code>atomicExch</code> etc. passes through this block. Without it, multiple SMs race to L2 and corrupt each other's read-modify-write. The arbiter serializes them with zero programmer effort.</div>
</div>

<div class="arb-section">
  <div class="arb-section-title">Full pipeline</div>
  <div class="arb-pipeline">
    <span class="arb-step amber">ATOM arrives</span><span class="arb-arrow">‚Üí</span>
    <span class="arb-step amber">SEQ#</span><span class="arb-arrow">‚Üí</span>
    <span class="arb-step amber">QUEUE</span><span class="arb-arrow">‚Üí</span>
    <span class="arb-step green">GRANT</span><span class="arb-arrow">‚Üí</span>
    <span class="arb-step blue">RMW@L2</span><span class="arb-arrow">‚Üí</span>
    <span class="arb-step orange">ACK</span><span class="arb-arrow">‚Üí</span>
    <span class="arb-step purple">ROB retire</span><span class="arb-arrow">‚Üí</span>
    <span class="arb-step green">DATA‚ÜíSM</span>
  </div>
</div>

<hr class="arb-divider">

<div class="arb-section">
  <div class="arb-section-title">‚ë† SEQ# tagging</div>
  <div class="arb-row">
    <span class="arb-row-label">What:</span>
    <span class="arb-row-val">Each incoming ATOM gets a monotonically increasing sequence number stamped on arrival. <span class="arb-tag amber">SEQ#000</span> <span class="arb-tag amber">SEQ#001</span> ‚Ä¶</span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">Why:</span>
    <span class="arb-row-val">L2 banks respond out-of-order. Without a SEQ#, we can't tell which result belongs to which request. The tag is the anchor for the ROB to re-order at the end.</span>
  </div>
</div>

<div class="arb-section">
  <div class="arb-section-title">‚ë° Incoming queue (hold up)</div>
  <div class="arb-row">
    <span class="arb-row-label">What:</span>
    <span class="arb-row-val">Up to <strong>6 requests</strong> wait here in arrival order. New arrivals beyond 6 cause back-pressure (the SM stalls).</span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">Policy:</span>
    <span class="arb-row-val"><strong>Round-robin grant</strong> ‚Äî front-of-queue SM gets exclusive access. One at a time, no exceptions.</span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">Cost:</span>
    <span class="arb-row-val">~2 cycles idle, up to ~32 cycles fully contended (8 SMs √ó ~4 cyc each). This is the serialization penalty you pay for correctness.</span>
  </div>
</div>

<div class="arb-section">
  <div class="arb-section-title green">‚ë¢ Grant</div>
  <div class="arb-row">
    <span class="arb-row-label">What:</span>
    <span class="arb-row-val">Arbiter sends a <span class="arb-tag green">GRANT</span> back to the winning SM. Only that SM may now proceed with the read-modify-write. All others wait in queue.</span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">Why:</span>
    <span class="arb-row-val">Mutual exclusion on the cache line. Without a grant, two SMs could both read the old value before either writes back ‚Äî classic lost-update bug.</span>
  </div>
</div>

<div class="arb-section">
  <div class="arb-section-title blue">‚ë£ RMW at L2</div>
  <div class="arb-row">
    <span class="arb-row-label">What:</span>
    <span class="arb-row-val">The granted SM dispatches <span class="arb-tag blue">ATOM</span> ‚Üí L2. L2 performs the Read-Modify-Write atomically: read old value, apply op (add/cas/exch), write new value, all in one locked step.</span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">Latency:</span>
    <span class="arb-row-val">~200 cycles round-trip to L2 for the RMW. This is why atomics are expensive ‚Äî you pay full L2 latency per operation, serialized.</span>
  </div>
</div>

<div class="arb-section">
  <div class="arb-section-title orange">‚ë§ ACK ‚Üê L2</div>
  <div class="arb-row">
    <span class="arb-row-label">What:</span>
    <span class="arb-row-val">L2 sends <span class="arb-tag orange">ACK#N</span> back to the arbiter with the result value and the original SEQ# tag.</span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">Out-of-order:</span>
    <span class="arb-row-val">Multiple L2 banks may complete in any order. <span class="arb-tag orange">ACK#5</span> might arrive before <span class="arb-tag orange">ACK#3</span> if they hit different banks. The ROB handles this.</span>
  </div>
</div>

<div class="arb-section">
  <div class="arb-section-title purple">‚ë• Hold Buffer (ROB)</div>
  <div class="arb-row">
    <span class="arb-row-label">What:</span>
    <span class="arb-row-val">Reorder Buffer. Holds all in-flight ACKs by SEQ#. Waits until the <em>next expected</em> SEQ# arrives before retiring ‚Äî ensures DATA is returned to SMs in the original request order.</span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">States:</span>
    <span class="arb-row-val">
      <span class="arb-tag amber">‚è≥ pending</span> ‚Äî dispatched to L2, ACK not yet back<br>
      <span class="arb-tag blue">‚ú¶ complete</span> ‚Äî ACK received, waiting for earlier SEQ#s to retire first<br>
      <span class="arb-tag purple">‚Ü© retiring</span> ‚Äî head-of-line, DATA being sent to SM now<br>
      <span class="arb-tag green">‚úì done</span> ‚Äî retired, DATA delivered
    </span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">Why order?</span>
    <span class="arb-row-val">The SM that issued atomicAdd expects the old value back. If we returned results out of order, SM1 might get SM3's result. ROB prevents this: you always get your own old value.</span>
  </div>
</div>

<hr class="arb-divider">
<div class="arb-note">Without this arbiter, atomics serialize inside L2 invisibly ‚Äî you get correctness but zero visibility into latency or contention. Apex exposes the full mechanism.</div>`,
    chips: [{t:'NEW: Apex',c:'#f59e0b'},{t:'seq-numbered',c:'#339af0'},{t:'ROB ordered',c:'#51cf66'}],
    connects: [
      {to:'bus',   arrow:'‚Üê', why:'Receives all atomic requests from SMs via the coherency bus'},
      {to:'l2',    arrow:'‚Üí', why:'Dispatches one granted atomic at a time down to L2 for RMW'},
      {to:'l2',    arrow:'‚Üê', why:'Receives ACK with result value back from L2 (possibly out of order)'},
      {to:'bus',   arrow:'‚Üí', why:'Returns DATA to originating SM after ROB retires in SEQ order'}
    ]
  },
  cohDir:    { name:'Coherency Directory', color:'#22d3ee', desc:'A hardware table tracking which SMs hold a copy of each cache line. When a write occurs, instead of broadcasting INV to all SMs (O(n) traffic), the directory sends INV only to the SMs listed as sharers ‚Äî O(sharers). At 256+ SMs this is a massive bus bandwidth saving. CPUs have used directories for decades; GPUs are still mostly broadcast-based.', chips:[{t:'NEW: Apex',c:'#22d3ee'},{t:'targeted INV',c:'#f06595'},{t:'O(sharers)',c:'#51cf66'}], connects:[{to:'l2',arrow:'‚Üî',why:'Directory lives alongside L2 ‚Äî each L2 set has an associated sharer vector'},{to:'bus',arrow:'‚Üí',why:'Sends targeted INV only to SMs in the sharer list'}] },
  warpScheduler:{ name:'Warp Scheduler', color:'#a78bfa', desc:'The SM sub-unit that decides which warp runs each clock cycle. When a warp stalls (waiting for L2 data, a dependency, or a barrier), the scheduler instantly switches to another ready warp. With enough resident warps, the stall is completely hidden by useful work from other warps ‚Äî this is GPU latency tolerance. In Apex this becomes an explicit visible block with per-warp stall reason tracking.', chips:[{t:'NEW: Apex',c:'#a78bfa'},{t:'per-SM',c:'#339af0'},{t:'latency hiding',c:'#51cf66'}], connects:[{to:'l1',arrow:'‚Üî',why:'When a warp misses L1, scheduler marks it stalled; when DATA arrives, marks it ready'},{to:'regs',arrow:'‚Üî',why:'Stalled warp context (registers, PC) is swapped out when another warp runs'}] },
};

var INSTRUCTION_INFO = {
  'LD.E':   { name:'LD.E  (global load)', color:'#ff6b6b',
    what:'Load from global memory into registers. The .E suffix = "extended addressing" (64-bit). Each thread in the warp loads from its own address ‚Äî if addresses are contiguous the hardware coalesces them into one wide transaction.',
    why:'You need this any time you read from a __device__ pointer or cudaMalloc\'d buffer. It\'s the bread-and-butter read path for all GPGPU work ‚Äî matrix rows, activation tensors, weight arrays, etc.' },
  'ST.E':   { name:'ST.E  (global store)', color:'#51cf66',
    what:'Store from registers to global memory. On Pascal, bypasses L1 entirely (write-through). On Volta+ it evicts the L1 line and writes to L2 (write-evict), then broadcasts INV to other SMs.',
    why:'Writing results back to global memory after a kernel computation ‚Äî output matrices, reduction results, feature maps. Write-evict keeps coherency cheap: only one SM "owns" a dirty line at a time.' },
  'LDS':    { name:'LDS  (load from shared)', color:'#51cf66',
    what:'Load from shared memory (SMEM) into registers. ~20 cycles ‚Äî far cheaper than global. Hardware checks 32 memory banks; accesses to the same bank by different threads in a warp are serialised (bank conflict).',
    why:'The classic CUDA optimization: load a tile from global into SMEM once, then all threads reuse it from LDS repeatedly. MatMul tiling, stencil kernels, and reductions all rely on this.' },
  'STS':    { name:'STS  (store to shared)', color:'#51cf66',
    what:'Store from registers to shared memory. Same 32-bank structure as LDS. Used to cooperatively build a shared tile that other threads in the block will then read via LDS.',
    why:'Tiling patterns: one thread loads from global, stores into SMEM with STS, then all threads read with LDS. Also used for warp-level reductions ‚Äî each thread stores its partial sum then reads neighbours.' },
  'ST.S':   { name:'ST.S  (store to shared, alt form)', color:'#51cf66',
    what:'Alternate encoding for shared memory store. Functionally equivalent to STS ‚Äî same 20-cycle latency, same 32-bank conflict rules.',
    why:'Same use cases as STS ‚Äî cooperative data staging, tiling, reductions. The assembler may emit either form.' },
  'RdReq':  { name:'RdReq  (read request packet)', color:'#ff6b6b',
    what:'Not an ISA instruction ‚Äî a cache coherency protocol message sent from an SM\'s L1 to the L2 on a cache miss. Carries the missed cache line address. The L2 either serves it or forwards it to DRAM.',
    why:'Every L1 cache miss generates one. High miss rates flood the coherency bus and stall warps waiting for data ‚Äî the root cause of memory-bound kernel performance.' },
  'INV':    { name:'INV  (invalidation message)', color:'#f06595',
    what:'Coherency protocol message broadcast from the L2 to all SMs after a write. Any SM holding a Shared or Modified copy of the written cache line must drop it (set to Invalid). Happens on every write in Volta+ write-evict policy.',
    why:'Essential for correctness in multi-SM workloads sharing the same address. Without invalidation, SM 0 could read a stale cached copy of data that SM 1 just wrote. The cost is bus bandwidth ‚Äî atomic-heavy kernels saturate the bus with INVs.' },
  'DATA':   { name:'DATA  (cache line fill)', color:'#ffa94d',
    what:'The response to an RdReq ‚Äî the actual 128-byte cache line payload travelling back from L2 (or DRAM) to the requesting SM\'s L1. On arrival, the L1 fills the line and transitions its state to Shared.',
    why:'This latency is what the GPU hides with warp switching (latency tolerance). If a warp stalls on DATA, the scheduler immediately runs another ready warp. More resident warps = more latency hiding.' },
  'WR':     { name:'WR  (write request)', color:'#51cf66',
    what:'Cache-level write packet flowing from L1 down to L2 on a write-evict event, or from L2 down to the memory controller. Carries both the address and dirty data payload.',
    why:'Part of the write-evict chain: thread writes to L1 ‚Üí L1 drops the dirty line ‚Üí WR packet carries it to L2. If L2 is also full, another WR goes all the way to DRAM. Write-heavy kernels generate a constant stream of these.' },
  'WB':     { name:'WB  (write-back)', color:'#ffa94d',
    what:'Write-Back ‚Äî a dirty L1 line is being evicted and its contents written back to L2. Different from a regular write in that it\'s triggered by cache capacity pressure, not the thread actively storing. Carries Modified ‚Üí Shared state transition.',
    why:'Happens automatically when the L1 is full and a new line must enter. Frequent write-backs indicate working sets larger than L1 ‚Äî a sign you should either reduce data reuse distances or tune the SMEM/L1 split.' },
  'EVICT':  { name:'EVICT  (L2 victim eviction)', color:'#339af0',
    what:'An L2 cache line is being evicted to DRAM because L2 is full. The victim line (chosen by LRU policy) travels through the NoC to the memory controller. Ampere\'s persistence window lets you protect chosen lines from eviction.',
    why:'L2 evictions to DRAM are slow (~400+ cycles). If your kernel constantly evicts from L2 it\'s DRAM-bandwidth-bound. Ampere\'s cudaAccessPolicyWindow lets you pin hot data (e.g., a weight matrix) to resist eviction.' },
  'STORE':  { name:'STORE  (DRAM write)', color:'#845ef7',
    what:'The final write command issued from a memory controller to an HBM/GDDR bank. At this point data leaves the on-chip world entirely. Row-activation (tRCD), column write (tCL), and precharge (tRP) timing all apply.',
    why:'DRAM writes are the slowest path in the hierarchy. You want kernels to rarely reach here ‚Äî maximize L2 residency and use cp.async or TMA to overlap DRAM reads with compute rather than blocking on them.' },
  'DSMEM':  { name:'DSMEM  (distributed shared memory)', color:'#22d3ee',
    what:'Hopper-only packet. An SM reads from another SM\'s shared memory within the same Thread Block Cluster. The request travels the cluster bus ‚Äî but stays entirely on-chip, never touching L2 or DRAM. ~20 cycle latency.',
    why:'Enables sub-L2 communication between cooperating SMs: e.g., overlapping tiles in FlashAttention-style kernels, or producer-consumer pipelines where one SM generates data another immediately consumes.' },
  'cp.async':{ name:'cp.async  (async global‚Üíshared copy)', color:'#22d3ee',
    what:'Ampere instruction. Initiates a DMA-style transfer from global memory directly into SMEM ‚Äî without allocating registers, without stalling the issuing warp. Multiple cp.async loads can be in flight simultaneously.',
    why:'The key to software pipelining (double-buffering) on Ampere+: issue cp.async for tile N+1 while computing on tile N. Completely hides DRAM latency. Critical for reaching peak FLOPS on matrix multiply kernels.' },
  'ATOM':   { name:'ATOM  (atomic request)', color:'#f59e0b',
    what:'An atomic operation packet (e.g. atomicAdd) leaving an SM and entering the Apex Arbiter. Carries: the target address, the operation type (ADD/CAS/MIN/MAX), the operand value, and the SM source ID. The arbiter stamps a SEQ# on it immediately.',
    why:'Atomics are the only safe way for concurrent threads to update shared memory without races. The cost is serialization ‚Äî all atomics to the same address queue through the arbiter one at a time. See the atomicAdd scenario to watch this unfold.' },
  'GRANT':  { name:'GRANT  (arbiter grant signal)', color:'#51cf66',
    what:'Apex Arbiter signal sent back to the SM whose ATOM request just reached the front of the queue. Tells the SM: "you now have exclusive access to this cache line ‚Äî proceed with the read-modify-write." The L2 cache line is locked until ACK is received.',
    why:'The grant/ack protocol prevents two SMs from simultaneously modifying the same address. Without it, atomicAdd would not be atomic ‚Äî two SMs could both read the value, both add to it, and one result would be silently lost.' },
  'ACK':    { name:'ACK  (atomic acknowledgement)', color:'#f59e0b',
    what:'Returned by L2 to the Arbiter after the atomic read-modify-write is complete. The arbiter logs this in the ROB under the original SEQ#, marks the slot done, and notifies the originating SM that the operation finished.',
    why:'The ACK closes the transaction loop. Until the arbiter receives ACK, the next SM in the queue cannot be granted access to that cache line address. High atomic contention means long chains of GRANT ‚Üí op ‚Üí ACK cycles.' },
  'SEQ':    { name:'SEQ#  (sequence number)', color:'#fbbf24',
    what:'A monotonically incrementing transaction ID stamped by the Apex Arbiter on every incoming ATOM request. Travels with the request all the way to L2 and back. The ROB uses it to match returning ACKs to the correct waiting SM.',
    why:'Without sequence numbers, returning data has no way to identify which SM asked for it ‚Äî especially when L2 bank conflicts cause some atomics to complete before earlier-numbered ones. The ROB uses SEQ# to restore order before retiring.' },
};

var ARCHS = {
  pascal: {
    name:'Pascal', gen:'SM 6.1', year:2016, color:'#51cf66', example:'GTX 1080 Ti',
    smLabel:'SM',
    intro:"The last generation before unified L1. Pascal keeps things simple ‚Äî L1 is read-only for global memory, so there's zero coherency overhead at L1. Writes go straight to L2. Great for understanding the baseline before things got complex.",
    perf:{ smCount:28, l1Size:24, smemSize:96, l2Size:4096, bw:484, flops:11.3, memType:'GDDR5X', vram:11, tdp:250, l1Latency:28, l2Latency:200, dramLatency:400 },
    blocks:{
      l1:{ label:'L1 (24KB)', desc:'Read-only texture/data cache. NOT coherent with global stores.', state:true },
      texCache:{ label:'TEX$', desc:'Separate texture cache, read-only, ~24KB.' },
      sharedMem:{ label:'SMEM (48‚Äì96KB)', desc:'Separate physical SRAM from L1. Configurable split.', state:false },
      l2:{ label:'L2 Cache (3‚Äì4MB)', desc:'Unified, coherent. Point of coherence for all SMs.', size:'3‚Äì4MB' },
      coherencyBus:{ label:'Crossbar', desc:'Simple crossbar ‚Äî minimal coherency traffic since L1 is read-only.' },
      globalMem:{ label:'Global Memory', desc:'GDDR5/GDDR5X memory interface.' },
      hbm:{ label:'GDDR5X', desc:'High-speed GDDR, ~480 GB/s on 1080 Ti.' },
    },
    writePolicy:'Write-through (L1 is read-only for globals)',
    coherency:'None at L1 ‚Äî L2 is sole coherence point',
    keyChange:null,
  },
  volta: {
    name:'Volta', gen:'SM 7.0', year:2017, color:'#339af0', example:'V100',
    smLabel:'SM',
    intro:"The big unification. Volta merged L1 and texture cache into a single 128KB SRAM that's also shared with SMEM. L1 now caches global writes too, which means coherency actually matters ‚Äî enter write-evict and invalidation.",
    perf:{ smCount:80, l1Size:128, smemSize:96, l2Size:6144, bw:900, flops:15.7, memType:'HBM2', vram:32, tdp:300, l1Latency:28, l2Latency:193, dramLatency:370 },
    blocks:{
      l1:{ label:'L1 + TEX (unified, 128KB)', desc:'L1 and texture cache merged.', state:true, changed:true },
      texCache:null,
      sharedMem:{ label:'SMEM (up to 96KB)', desc:'Shares the 128KB SRAM pool with L1.', changed:true },
      l2:{ label:'L2 Cache (6MB)', desc:'Larger L2. Write-evict policy from L1.', size:'6MB', changed:true },
      coherencyBus:{ label:'Coherency Bus', desc:'Now carries invalidation messages.' },
      globalMem:{ label:'Global Memory', desc:'HBM2 interface. 4 stacks.' },
      hbm:{ label:'HBM2', desc:'900 GB/s. Stacked DRAM.', changed:true },
    },
    writePolicy:'Write-evict (dirty L1 line dropped, write goes to L2)',
    coherency:'L1 invalidation via bus, L2 is coherence point',
    keyChange:'L1 + TEX unified, shared SRAM pool with SMEM, HBM2',
  },
  ampere: {
    name:'Ampere', gen:'SM 8.0', year:2020, color:'#ffa94d', example:'A100',
    smLabel:'SM',
    intro:"Ampere's headline: 10x larger L2 (40MB!) with software-controlled persistence, and async copy (cp.async) that moves data from global to shared memory without burning registers.",
    perf:{ smCount:108, l1Size:192, smemSize:164, l2Size:40960, bw:2039, flops:19.5, memType:'HBM2e', vram:80, tdp:400, l1Latency:33, l2Latency:200, dramLatency:400 },
    blocks:{
      l1:{ label:'L1 + TEX (192KB)', desc:'Larger unified L1/TEX cache.', state:true, changed:true },
      texCache:null,
      sharedMem:{ label:'SMEM (up to 164KB)', desc:'Larger SMEM. cp.async bypasses register file.', changed:true },
      asyncCopy:{ label:'ASYNC COPY', desc:'cp.async: DMA-like transfer from global to shared, bypassing registers.', isNew:true },
      l2:{ label:'L2 Cache (40MB)', desc:'Massive L2. Persistence controls via cudaAccessPolicyWindow.', size:'40MB', changed:true },
      l2Persist:{ label:'L2 PERSIST', desc:'Software-controlled L2 data persistence.', isNew:true },
      coherencyBus:{ label:'Coherency Bus', desc:'Same write-evict L1 coherency as Volta.' },
      globalMem:{ label:'Global Memory', desc:'HBM2e interface. 5 stacks.' },
      hbm:{ label:'HBM2e', desc:'2 TB/s. 80GB.', changed:true },
    },
    writePolicy:'Write-evict (same as Volta)',
    coherency:'L1 write-evict + invalidation, L2 persistence controls',
    keyChange:'Async copy (cp.async), 10√ó larger L2 with persistence',
  },
  hopper: {
    name:'Hopper', gen:'SM 9.0', year:2022, color:'#845ef7', example:'H100',
    smLabel:'SM',
    intro:"Hopper introduces TMA (Tensor Memory Accelerator) ‚Äî a hardware DMA engine for complex tensor addressing ‚Äî and DSMEM, where SMs in a cluster can directly read each other's shared memory.",
    perf:{ smCount:132, l1Size:256, smemSize:228, l2Size:51200, bw:3352, flops:66.9, memType:'HBM3', vram:80, tdp:700, l1Latency:33, l2Latency:200, dramLatency:380 },
    blocks:{
      l1:{ label:'L1 + TEX (256KB)', desc:'Even larger unified cache with TMA support.', state:true, changed:true },
      texCache:null,
      sharedMem:{ label:'SMEM (up to 228KB)', desc:'Largest SMEM. DSMEM for cross-SM shared memory access.', changed:true },
      dsmem:{ label:'DSMEM', desc:'Distributed Shared Memory. SMs within a cluster can directly access each other\'s shared memory.', isNew:true },
      tma:{ label:'TMA', desc:'Tensor Memory Accelerator. Hardware DMA for bulk data transfers with tensor-aware addressing.', isNew:true },
      asyncCopy:{ label:'ASYNC COPY', desc:'Enhanced from Ampere with TMA integration.' },
      l2:{ label:'L2 Cache (50MB)', desc:'Larger still with improved persistence controls.', size:'50MB', changed:true },
      l2Persist:{ label:'L2 PERSIST', desc:'Refined from Ampere with better granularity.' },
      coherencyBus:{ label:'Cluster Bus', desc:'New cluster-level interconnect for DSMEM.', changed:true },
      globalMem:{ label:'Global Memory', desc:'HBM3 interface.' },
      hbm:{ label:'HBM3', desc:'3.35 TB/s. 80GB.', changed:true },
    },
    writePolicy:'Write-evict + TMA bulk transfers',
    coherency:'Cluster-level DSMEM coherency + L2 global coherence',
    keyChange:'TMA engine, Distributed Shared Memory (DSMEM), HBM3',
  },
  apex: {
    name:'Apex', gen:'SM 10.0', year:2026, color:'#f59e0b', example:'Concept',
    smLabel:'SM',
    intro:"A forward-looking architecture exploring three unsolved problems in GPU memory design. The headline addition: a hardware <strong>Atomic Arbiter</strong> with a visible request queue, sequence-numbered transactions, and a Reorder Buffer (ROB) to handle out-of-order returns. Also features a Coherency Directory replacing broadcast INV with targeted per-SM invalidation. None of these exist in shipping silicon yet ‚Äî but the problems they solve are very real.",
    perf:{ smCount:144, l1Size:320, smemSize:256, l2Size:65536, bw:5000, flops:120, memType:'HBM4', vram:192, tdp:1000, l1Latency:25, l2Latency:160, dramLatency:350 },
    blocks:{
      l1:{ label:'L1 + TEX (320KB)', desc:'Enlarged unified L1 with lower latency predictor logic.', state:true, changed:true },
      texCache:null,
      sharedMem:{ label:'SMEM (up to 256KB)', desc:'Larger SMEM with hardware bank-conflict detection.', changed:true },
      warpScheduler:{ label:'WARP SCHED', desc:'Explicit warp scheduler sub-unit. Tracks stall reasons per warp ‚Äî memory, dependency, branch ‚Äî and uses them to pick the best next warp to run. Makes latency hiding observable.', isNew:true },
      arbiter:{ label:'ATOMIC ARBITER', desc:'Hardware arbiter serializing atomic operations. Assigns a sequence number to every atomic request, queues up to 6 pending ops, and grants them round-robin. A Reorder Buffer (ROB) holds returning data until it can be retired in order.', isNew:true },
      l2:{ label:'L2 Cache (64MB)', desc:'Larger L2 with per-address owner tracking for the coherency directory.', size:'64MB', changed:true },
      cohDir:{ label:'COHERENCY DIR', desc:'Directory replacing broadcast INV. Tracks which SMs hold a copy of each cache line. Writes only send INV to SMs that actually have a copy ‚Äî O(sharers) instead of O(all SMs). Critical for scaling to 256+ SM counts.', isNew:true },
      coherencyBus:{ label:'Targeted Inval. Bus', desc:'Bus now carries targeted (not broadcast) INV messages. Only SMs listed in the directory receive INV ‚Äî massive bandwidth saving at high SM counts.', changed:true },
      globalMem:{ label:'Global Memory', desc:'HBM4 interface. 8 stacks, 5 TB/s.' },
      hbm:{ label:'HBM4', desc:'5 TB/s. 192GB. Next-generation stacked DRAM.', changed:true },
    },
    writePolicy:'Write-evict + arbiter-serialized atomics',
    coherency:'Directory-based targeted INV + ROB-ordered atomic returns',
    keyChange:'Atomic Arbiter with ROB, Coherency Directory, Warp Scheduler',
  }
};

var currentArch = 'pascal';
var prevArch = null;
var stats = { hits:0, misses:0, inv:0, wb:0 };
var autoMode = true, autoTimer = 0;
var particles = [], flashEffects = [], stepTimers = [], bubbles = [];
var layout = {};

var NUM_LINES = 16;
var cacheState = [];

function initCacheState() {
  cacheState = [];
  var n = layout.sms ? layout.sms.length : 4;
  for (var i = 0; i < n; i++) {
    cacheState.push({
      l1:   new Array(NUM_LINES).fill(0),
      smem: new Array(NUM_LINES).fill(0),
    });
  }
}

function fillL1Random(smIdx, dirty) {
  if (!cacheState[smIdx]) return;
  var lines = cacheState[smIdx].l1;
  var count = 6 + Math.floor(Math.random() * 8);
  for (var i = 0; i < NUM_LINES; i++) {
    lines[i] = i < count ? (dirty ? 2 : 1) : 0;
  }
  for (var j = NUM_LINES - 1; j > 0; j--) {
    var k = Math.floor(Math.random() * (j + 1));
    var tmp = lines[j]; lines[j] = lines[k]; lines[k] = tmp;
  }
}

function setL1Dirty(smIdx) {
  if (!cacheState[smIdx]) return;
  var lines = cacheState[smIdx].l1;
  var filled = lines.filter(function(v){ return v > 0; }).length;
  if (filled < 4) { fillL1Random(smIdx, false); }
  var dirtied = 0;
  for (var i = 0; i < NUM_LINES && dirtied < 3; i++) {
    if (lines[i] === 1 && Math.random() > 0.5) { lines[i] = 2; dirtied++; }
  }
  if (dirtied === 0) { lines[Math.floor(Math.random()*NUM_LINES)] = 2; }
}

function invalidateL1(smIdx) {
  if (!cacheState[smIdx]) return;
  cacheState[smIdx].l1 = new Array(NUM_LINES).fill(0);
}

function writebackL1(smIdx) {
  if (!cacheState[smIdx]) return;
  var lines = cacheState[smIdx].l1;
  for (var i = 0; i < NUM_LINES; i++) { if (lines[i] === 2) lines[i] = 1; }
}

function fillSmem(smIdx) {
  if (!cacheState[smIdx]) return;
  var lines = cacheState[smIdx].smem;
  var count = 8 + Math.floor(Math.random() * 7);
  for (var i = 0; i < NUM_LINES; i++) lines[i] = i < count ? 1 : 0;
  for (var j = NUM_LINES - 1; j > 0; j--) {
    var kk = Math.floor(Math.random() * (j + 1));
    var tt = lines[j]; lines[j] = lines[kk]; lines[kk] = tt;
  }
}

function getCacheStats(smIdx, kind) {
  if (!cacheState[smIdx]) return { filled:0, dirty:0, empty:NUM_LINES };
  var arr = cacheState[smIdx][kind];
  var filled = 0, dirty = 0;
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === 1) filled++;
    else if (arr[i] === 2) { filled++; dirty++; }
  }
  return { filled: filled, dirty: dirty, empty: NUM_LINES - filled };
}

var hoveredBlock = null;
var selectedBlock = null;
var connLines = [];
var mouseX = 0, mouseY = 0;
var lastClientX = 0, lastClientY = 0;

// Phase names for display
var ARB_PHASES = {
  queued:    { label: 'QUEUED',    color: '#f59e0b', desc: 'Waiting in request queue for grant' },
  granted:   { label: 'GRANTED',   color: '#51cf66', desc: 'Grant issued ‚Äî SM has exclusive access' },
  rmw:       { label: 'RMW‚ÜíL2',   color: '#339af0', desc: 'Read-Modify-Write in progress at L2' },
  ack:       { label: 'ACK‚ÜêL2',   color: '#ffa94d', desc: 'Acknowledgement returning from L2' },
  retiring:  { label: 'RETIRING',  color: '#a78bfa', desc: 'ROB retiring ‚Äî data routing to SM' },
};
var hitRects = [];

function buildHitRects() {
  hitRects = [];
  for (var si = 0; si < layout.sms.length; si++) {
    var sm = layout.sms[si];
    for (var bi = 0; bi < sm.sub.length; bi++) {
      var b = sm.sub[bi];
      hitRects.push({ type: b.type, x: b.x, y: b.y, w: b.w, h: b.h, smIdx: si, label: b.label });
    }
  }
  if (layout.l2) hitRects.push({ type: 'l2', x: layout.l2.x, y: layout.l2.y, w: layout.l2.w, h: layout.l2.h });
  if (layout.l2Persist) hitRects.push({ type: 'l2Persist', x: layout.l2Persist.x, y: layout.l2Persist.y, w: layout.l2Persist.w, h: layout.l2Persist.h });
  if (layout.arbiter) hitRects.push({ type: 'arbiter', x: layout.arbiter.x, y: layout.arbiter.y, w: layout.arbiter.w, h: layout.arbiter.h });
  if (layout.cohDir) hitRects.push({ type: 'cohDir', x: layout.cohDir.x, y: layout.cohDir.y, w: layout.cohDir.w, h: layout.cohDir.h });
  if (layout.bus) hitRects.push({ type: 'bus', x: layout.bus.x1, y: layout.bus.y - 12, w: layout.bus.x2 - layout.bus.x1, h: 24 });
  if (layout.globalMem) hitRects.push({ type: 'globalMem', x: layout.globalMem.x, y: layout.globalMem.y, w: layout.globalMem.w, h: layout.globalMem.h });
  if (layout.hbm) hitRects.push({ type: 'hbm', x: layout.hbm.x, y: layout.hbm.y, w: layout.hbm.w, h: layout.hbm.h });
}

function hitTest(mx, my) {
  for (var i = hitRects.length - 1; i >= 0; i--) {
    var r = hitRects[i];
    if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) return r;
  }
  return null;
}

function getBlockCenter(type, smIdx) {
  if (type === 'l2') return { x: layout.l2.x + layout.l2.w/2, y: layout.l2.y + layout.l2.h/2 };
  if (type === 'l2Persist') return { x: layout.l2Persist.x + layout.l2Persist.w/2, y: layout.l2Persist.y + layout.l2Persist.h/2 };
  if (type === 'arbiter' && layout.arbiter) return { x: layout.arbiter.x + layout.arbiter.w/2, y: layout.arbiter.y + layout.arbiter.h/2 };
  if (type === 'cohDir' && layout.cohDir) return { x: layout.cohDir.x + layout.cohDir.w/2, y: layout.cohDir.y + layout.cohDir.h/2 };
  if (type === 'bus') return { x: (layout.bus.x1 + layout.bus.x2)/2, y: layout.bus.y };
  if (type === 'globalMem') return { x: layout.globalMem.x + layout.globalMem.w/2, y: layout.globalMem.y + layout.globalMem.h/2 };
  if (type === 'hbm') return { x: layout.hbm.x + layout.hbm.w/2, y: layout.hbm.y + layout.hbm.h/2 };
  var targetSmIdx = (smIdx !== undefined && smIdx !== null) ? smIdx : 0;
  for (var si = 0; si < layout.sms.length; si++) {
    var sm = layout.sms[si];
    for (var bi = 0; bi < sm.sub.length; bi++) {
      var b = sm.sub[bi];
      if (b.type === type && si === targetSmIdx) return { x: b.x + b.w/2, y: b.y + b.h/2 };
    }
  }
  for (var si2 = 0; si2 < layout.sms.length; si2++) {
    for (var bi2 = 0; bi2 < layout.sms[si2].sub.length; bi2++) {
      if (layout.sms[si2].sub[bi2].type === type) {
        var bb = layout.sms[si2].sub[bi2];
        return { x: bb.x + bb.w/2, y: bb.y + bb.h/2 };
      }
    }
  }
  return null;
}

function getBlockRect(type, smIdx) {
  for (var i = 0; i < hitRects.length; i++) {
    var r = hitRects[i];
    if (r.type === type && (smIdx === undefined || r.smIdx === smIdx)) return r;
  }
  return null;
}

var connLineAnim = 0;
var SM_LOCAL_TYPES = { regs:1, l1:1, texCache:1, smem:1, tma:1, dsmem:1, async:1 };

function buildConnLines(blockType, smIdx) {
  var info = BLOCK_INFO[blockType];
  if (!info || !info.connects) return;
  connLines = [];
  var from = getBlockCenter(blockType, smIdx);
  if (!from) return;
  for (var i = 0; i < info.connects.length; i++) {
    var conn = info.connects[i];
    var isGlobal = !SM_LOCAL_TYPES[conn.to];
    if (isGlobal) {
      var tc = getBlockCenter(conn.to, smIdx);
      if (tc) connLines.push({ from: from, to: tc, why: conn.why, arrow: conn.arrow, color: info.color });
    } else {
      var tc2 = getBlockCenter(conn.to, smIdx);
      if (tc2) connLines.push({ from: from, to: tc2, why: conn.why, arrow: conn.arrow, color: info.color });
    }
  }
  connLineAnim = 0;
}

canvas.addEventListener('mousemove', function(e) {
  var r = canvas.getBoundingClientRect();
  mouseX = e.clientX - r.left;
  mouseY = e.clientY - r.top;
  lastClientX = e.clientX;
  lastClientY = e.clientY;

  var pHit = hitTestParticleLabels(mouseX, mouseY);
  if (pHit && INSTRUCTION_INFO[pHit.key]) {
    showInstrTooltip(pHit.key, pHit.clientX, pHit.clientY - 20);
    hoveredBlock = null;
    hideTooltip();
    canvas.style.cursor = 'help';
    return;
  }
  hideInstrTooltip();

  var hit = hitTest(mouseX, mouseY);
  hoveredBlock = hit;
  canvas.style.cursor = hit ? 'pointer' : 'default';
  updateTooltip(hit, e.clientX, e.clientY);
});

canvas.addEventListener('mouseleave', function() {
  hoveredBlock = null;
  hideTooltip();
  hideInstrTooltip();
});

canvas.addEventListener('click', function(e) {
  var r = canvas.getBoundingClientRect();
  var mx = e.clientX - r.left;
  var my = e.clientY - r.top;
  var hit = hitTest(mx, my);
  if (hit) {
    if (selectedBlock && selectedBlock.type === hit.type && selectedBlock.smIdx === hit.smIdx) {
      clearSelection();
    } else {
      selectBlock(hit);
    }
  } else {
    clearSelection();
  }
});

function selectBlock(hit) {
  selectedBlock = hit;
  buildConnLines(hit.type, hit.smIdx);
  updateSelPanel(hit);
}

function clearSelection() {
  selectedBlock = null;
  connLines = [];
  document.getElementById('sel-panel').classList.remove('visible');
}

function updateSelPanel(hit) {
  var info = BLOCK_INFO[hit.type];
  if (!info) return;
  var panel = document.getElementById('sel-panel');
  panel.classList.add('visible');
  document.getElementById('sel-name').innerHTML = '<span style="color:' + info.color + '">' + info.name + '</span>';
  var descEl = document.getElementById('sel-desc');
  if (info.descHTML) {
    descEl.innerHTML = info.descHTML;
  } else {
    descEl.textContent = info.desc;
  }
  var connList = document.getElementById('conn-list');
  connList.innerHTML = '';
  if (!info.connects || info.connects.length === 0) {
    connList.innerHTML = '<div style="font-size:.75rem;color:var(--dim);padding:6px 0">No direct connections defined.</div>';
    return;
  }
  for (var i = 0; i < info.connects.length; i++) {
    var c = info.connects[i];
    var targetInfo = BLOCK_INFO[c.to] || {};
    var el = document.createElement('div');
    el.className = 'conn-item';
    el.innerHTML = '<span class="ci-arrow" style="color:' + (targetInfo.color||'#6b7094') + '">' + c.arrow + '</span><div class="ci-body"><span class="ci-target" style="color:' + (targetInfo.color||'#aaa') + '">' + (targetInfo.name || c.to) + '</span><span class="ci-why">' + c.why + '</span></div>';
    (function(connTo) {
      el.addEventListener('click', function(e) {
        e.stopPropagation();
        var targetHit = getBlockRect(connTo, hit.smIdx) || getBlockRect(connTo);
        if (targetHit) selectBlock(targetHit);
      });
    })(c.to);
    connList.appendChild(el);
  }
}

var tooltipEl = document.getElementById('block-tooltip');
var ttName = document.getElementById('tt-name');
var ttDot = document.getElementById('tt-dot');
var ttDesc = document.getElementById('tt-desc');
var ttMeta = document.getElementById('tt-meta');
var ttHint = document.getElementById('tt-hint');

var instrTooltipEl = null;
var instrHovered = null;

function getInstrEl() {
  if (!instrTooltipEl) instrTooltipEl = document.getElementById('instr-tooltip');
  return instrTooltipEl;
}

function showInstrTooltip(key, clientX, clientY) {
  var info = INSTRUCTION_INFO[key];
  if (!info) return;
  var el = getInstrEl();
  if (!el) return;
  if (instrHovered === key) { positionInstrTooltip(clientX, clientY); return; }
  instrHovered = key;
  document.getElementById('it-dot').style.background = info.color;
  el.style.borderColor = info.color + '40';
  document.getElementById('it-name').textContent = info.name;
  document.getElementById('it-what').textContent = info.what;
  document.getElementById('it-why').textContent = info.why;
  el.querySelector('.it-why-box').style.borderColor = info.color + '30';
  positionInstrTooltip(clientX, clientY);
  el.classList.add('visible');
}

function hideInstrTooltip() {
  instrHovered = null;
  var el = getInstrEl();
  if (el) el.classList.remove('visible');
}

function positionInstrTooltip(clientX, clientY) {
  var el = getInstrEl();
  if (!el) return;
  var tw = 320, th = 220;
  var vw = window.innerWidth, vh = window.innerHeight;
  var tx = clientX + 18;
  var ty = clientY - 24;
  if (tx + tw > vw - 10) tx = clientX - tw - 18;
  if (ty + th > vh - 10) ty = clientY - th + 10;
  if (ty < 8) ty = 8;
  el.style.left = tx + 'px';
  el.style.top  = ty + 'px';
}

var particleLabelRects = [];

function buildParticleLabelRects() {
  particleLabelRects = [];
  var cr = canvas.getBoundingClientRect();
  for (var i = 0; i < particles.length; i++) {
    var p = particles[i];
    if (!p.label || !p.alive) continue;
    var ppos = p._getPos ? p._getPos() : { x: p.from.x + (p.to.x - p.from.x) * (p.t||0), y: p.from.y + (p.to.y - p.from.y) * (p.t||0) };
    var cx2 = ppos.x, cy2 = ppos.y;
    var clientX = cr.left + cx2;
    var clientY = cr.top  + cy2;
    particleLabelRects.push({ key: p.label, cx: cx2, cy: cy2, clientX: clientX, clientY: clientY });
  }
}

function hitTestParticleLabels(mx, my) {
  var HIT_R = 36;
  for (var i = 0; i < particleLabelRects.length; i++) {
    var r = particleLabelRects[i];
    var dx = mx - r.cx;
    var dy = my - (r.cy - 12);
    if (dx*dx + dy*dy < HIT_R*HIT_R) return r;
  }
  return null;
}

function updateTooltip(hit, clientX, clientY) {
  if (!hit) { hideTooltip(); return; }
  var info = BLOCK_INFO[hit.type];
  if (!info) { hideTooltip(); return; }

  ttName.textContent = info.name;
  ttDot.style.background = info.color;
  tooltipEl.style.borderColor = info.color + '50';
  ttDesc.textContent = info.desc;

  var isCacheBlock = (hit.type === 'l1' || hit.type === 'smem') && hit.smIdx !== undefined;
  var isArbiterBlock = hit.type === 'arbiter';
  var isCohDirBlock = hit.type === 'cohDir';

  if (isArbiterBlock) {
    tooltipEl.classList.add('tt-wide');
    // Render rich arbiter state in tooltip
    var arbQ = arbiterState.queue;
    var arbROB = arbiterState.rob;
    var arbOps = arbiterState.activeOps;
    var arbGrants = arbiterState.recentGrants;
    var latFracTT = arbiterState.contentionLevel;
    var cycTT = Math.round(2 + latFracTT * 30);
    var statusTT = arbQ.length >= 4 ? 'SATURATED' : arbiterState.active ? 'ACTIVE' : 'IDLE';
    var statusColor = arbQ.length >= 4 ? '#ff6b6b' : arbiterState.active ? '#fbbf24' : '#4a5080';

    // ‚îÄ‚îÄ Live ops table ‚Äî what each in-flight op is doing RIGHT NOW ‚îÄ‚îÄ
    var liveOpsHtml = '';
    if (arbOps.length === 0) {
      liveOpsHtml = '<div style="color:#4a5080;font-size:.6rem;padding:2px 0">No ops in flight</div>';
    } else {
      for (var tao = 0; tao < Math.min(arbOps.length, 6); tao++) {
        var aop = arbOps[tao];
        var ph = ARB_PHASES[aop.phase] || ARB_PHASES.queued;
        var elapsed = Math.round((Date.now() - aop.phaseStart) / 10); // in ~cycles (10ms ‚âà 1 notional cycle)
        var phaseBar = '';
        // 5-step pipeline indicator
        var phases = ['queued','granted','rmw','ack','retiring'];
        var curPhaseIdx = phases.indexOf(aop.phase);
        for (var pp = 0; pp < phases.length; pp++) {
          var ppActive = pp === curPhaseIdx;
          var ppDone = pp < curPhaseIdx;
          var ppColor = ppDone ? '#51cf6660' : ppActive ? ph.color : '#2a2d3a';
          phaseBar += '<span style="display:inline-block;width:14px;height:4px;border-radius:2px;background:'+ppColor+';margin-right:2px"></span>';
        }
        liveOpsHtml +=
          '<div style="display:flex;align-items:center;gap:6px;padding:3px 0;border-bottom:1px solid #1e2030">' +
            '<span style="font-family:JetBrains Mono,monospace;font-size:.58rem;color:#f59e0b;min-width:28px">#'+aop.seq+'</span>' +
            '<span style="font-family:JetBrains Mono,monospace;font-size:.58rem;color:#e0e2ec;min-width:22px">SM'+aop.smIdx+'</span>' +
            '<span style="font-family:JetBrains Mono,monospace;font-size:.58rem;font-weight:700;color:'+ph.color+';min-width:64px">'+ph.label+'</span>' +
            '<span style="flex:1">'+phaseBar+'</span>' +
            '<span style="font-family:JetBrains Mono,monospace;font-size:.54rem;color:#6b7090">'+elapsed+'œÑ</span>' +
          '</div>';
      }
    }

    // ‚îÄ‚îÄ ROB slots ‚îÄ‚îÄ
    var robSlots = '';
    for (var trs = 0; trs < 6; trs++) {
      var tre = trs < arbROB.length ? arbROB[trs] : null;
      var rstate = tre ? tre.state : '';
      var rcls = 'tt-arb-rob-slot' + (rstate==='pending'?' pend':rstate==='complete'?' comp':rstate==='retiring'?' retr':rstate==='done'?' done':'');
      var robLabel = tre ? '#'+tre.seq : '‚Äî';
      robSlots += '<div class="'+rcls+'" title="'+rstate+'">'+robLabel+'</div>';
    }

    // ‚îÄ‚îÄ Queue slots ‚îÄ‚îÄ
    var qSlots = '';
    for (var tqs = 0; tqs < 6; tqs++) {
      var tqe = tqs < arbQ.length ? arbQ[tqs] : null;
      var cls = tqe ? 'tt-arb-slot occ' : 'tt-arb-slot';
      qSlots += '<div class="'+cls+'">'+(tqe ? '#'+tqe.seq : '‚Äî')+'</div>';
    }

    // ‚îÄ‚îÄ Grant log ‚îÄ‚îÄ
    var grantHtml = '';
    if (arbGrants.length === 0) {
      grantHtml = '<span style="color:#4a5080">No grants yet ‚Äî run atomicAdd scenario</span>';
    } else {
      for (var tgi = 0; tgi < Math.min(arbGrants.length, 3); tgi++) {
        var tge = arbGrants[tgi];
        grantHtml += '‚Üí <span class="gs">#'+tge.seq+'</span> retired in <span class="gc">'+tge.cycles+' cyc</span><br>';
      }
    }

    var latBarPct = Math.round(latFracTT * 100);
    var latColor = latFracTT > 0.6 ? '#ff6b6b' : latFracTT > 0.3 ? '#f59e0b' : '#51cf66';

    ttMeta.innerHTML =
      // Status header
      '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:5px">' +
        '<span style="font-family:JetBrains Mono,monospace;font-size:.58rem;color:#6b7090">STATUS</span>' +
        '<span style="font-family:JetBrains Mono,monospace;font-size:.64rem;font-weight:700;letter-spacing:.5px;color:'+statusColor+'">‚óè '+statusTT+'</span>' +
      '</div>' +
      // Live ops ‚Äî the star of the show
      '<div class="tt-arb-section">' +
        '<div class="tt-arb-label">Live In-Flight Operations <span style="float:right;color:#f59e0b">SEQ#'+String(arbiterState.seqCounter).padStart(3,'0')+'</span></div>' +
        liveOpsHtml +
      '</div>' +
      // Queue + ROB side by side
      '<div class="tt-arb-section" style="display:grid;grid-template-columns:1fr 1fr;gap:8px">' +
        '<div>' +
          '<div class="tt-arb-label">Wait Queue</div>' +
          '<div class="tt-arb-queue">'+qSlots+'</div>' +
        '</div>' +
        '<div>' +
          '<div class="tt-arb-label">ROB</div>' +
          '<div class="tt-arb-rob">'+robSlots+'</div>' +
        '</div>' +
      '</div>' +
      // Contention bar
      '<div class="tt-arb-section">' +
        '<div class="tt-arb-label">Bus Contention <span style="float:right;color:'+latColor+'">~'+cycTT+' cyc/grant</span></div>' +
        '<div class="tt-arb-bar-bg"><div class="tt-arb-bar-fill" style="width:'+latBarPct+'%"></div></div>' +
        '<div style="font-family:JetBrains Mono,monospace;font-size:.54rem;color:#4a5080;margin-top:2px">'+
          'Idle: 2 cyc ¬∑ Contended: up to 32 cyc' +
        '</div>' +
      '</div>' +
      // Grant log
      '<div class="tt-arb-section">' +
        '<div class="tt-arb-label">Recent Completions <span style="float:right;color:#6b7090">'+arbiterState.grantCount+' total</span></div>' +
        '<div class="tt-arb-grant-log">'+grantHtml+'</div>' +
      '</div>';
    ttHint.style.display = 'none';
    positionTooltip(clientX, clientY);
    tooltipEl.classList.add('visible');
    return;
  } else {
    tooltipEl.classList.remove('tt-wide');
  }

  if (isCacheBlock) {
    ttMeta.innerHTML =
      '<div style="margin-bottom:2px">' +
        '<div style="display:flex;align-items:center;gap:6px;margin-bottom:5px">' +
          '<span style="font-family:JetBrains Mono,monospace;font-size:.6rem;color:#9095b0;text-transform:uppercase;letter-spacing:1px">Cache Lines</span>' +
          '<span id="tt-fill-label" style="font-family:JetBrains Mono,monospace;font-size:.68rem;font-weight:700;color:'+info.color+'"></span>' +
          '<span id="tt-dirty-label" style="font-family:JetBrains Mono,monospace;font-size:.62rem;color:#51cf66"></span>' +
        '</div>' +
        '<div id="tt-line-grid" style="display:flex;gap:2px;height:10px;margin-bottom:5px"></div>' +
        '<div id="tt-state-label" style="font-size:.66rem;font-family:JetBrains Mono,monospace"></div>' +
      '</div>';
    refreshTooltipCacheData(hit, info);
  } else {
    ttMeta.innerHTML = '';
    if (info.chips) {
      for (var i = 0; i < info.chips.length; i++) {
        var chip = info.chips[i];
        var span = document.createElement('span');
        span.className = 'tt-chip';
        span.style.background = chip.c + '20';
        span.style.color = chip.c;
        span.textContent = chip.t;
        ttMeta.appendChild(span);
      }
    }
  }

  ttHint.style.display = (selectedBlock && selectedBlock.type === hit.type) ? 'none' : 'flex';
  positionTooltip(clientX, clientY);
  tooltipEl.classList.add('visible');
}

function refreshTooltipCacheData(hit, info) {
  if (!hit) return;
  var inf = info || BLOCK_INFO[hit.type];
  if (!inf) return;
  var kind = hit.type === 'l1' ? 'l1' : 'smem';
  if (hit.type !== 'l1' && hit.type !== 'smem') return;

  var cs = getCacheStats(hit.smIdx, kind);
  var arr = cacheState[hit.smIdx] ? cacheState[hit.smIdx][kind] : [];

  var fillLbl = document.getElementById('tt-fill-label');
  if (fillLbl) fillLbl.textContent = cs.filled + '/' + NUM_LINES + ' filled';

  var dirtyLbl = document.getElementById('tt-dirty-label');
  if (dirtyLbl) dirtyLbl.textContent = cs.dirty > 0 ? cs.dirty + ' dirty' : '';

  var grid = document.getElementById('tt-line-grid');
  if (grid) {
    if (grid.children.length !== NUM_LINES) {
      grid.innerHTML = '';
      for (var li = 0; li < NUM_LINES; li++) {
        var sq = document.createElement('div');
        sq.style.cssText = 'flex:1;border-radius:2px;transition:background .12s';
        grid.appendChild(sq);
      }
    }
    for (var li2 = 0; li2 < NUM_LINES; li2++) {
      var lv = arr[li2] || 0;
      var lc;
      if (lv === 2)      lc = '#51cf66';
      else if (lv === 1) lc = hit.type === 'l1' ? inf.color + 'cc' : '#51cf6688';
      else               lc = '#1e2030';
      grid.children[li2].style.background = lc;
    }
  }

  var stateLbl = document.getElementById('tt-state-label');
  if (stateLbl && hit.type === 'l1') {
    var l1b = null;
    if (layout.sms[hit.smIdx]) {
      for (var bi = 0; bi < layout.sms[hit.smIdx].sub.length; bi++) {
        if (layout.sms[hit.smIdx].sub[bi].type === 'l1') { l1b = layout.sms[hit.smIdx].sub[bi]; break; }
      }
    }
    var st = l1b ? l1b.state : 'invalid';
    var stateLabel, stateColor;
    if (st === 'modified')      { stateLabel = '‚óè Modified ‚Äî has dirty data';  stateColor = '#51cf66'; }
    else if (st === 'shared')   { stateLabel = '‚óè Shared ‚Äî clean copy';        stateColor = '#5ab0f8'; }
    else                        { stateLabel = '‚óè Invalid ‚Äî empty';            stateColor = '#6b7090'; }
    stateLbl.style.color = stateColor;
    stateLbl.textContent = stateLabel;
  } else if (stateLbl && hit.type === 'smem') {
    var smFilled = cs.filled;
    stateLbl.style.color = smFilled > 0 ? '#6ee09a' : '#6b7090';
    stateLbl.textContent = smFilled > 0 ? '‚óè Active ‚Äî ' + smFilled + ' slots used' : '‚óè Empty ‚Äî no data loaded';
  }
}

function positionTooltip(clientX, clientY) {
  var vizRect = canvas.parentElement.getBoundingClientRect();
  var tx = clientX - vizRect.left + 14;
  var ty = clientY - vizRect.top - 12;
  var tw = 250, th = 160;
  if (tx + tw > vizRect.width - 10)  tx = clientX - vizRect.left - tw - 14;
  if (ty + th > vizRect.height - 10) ty = clientY - vizRect.top - th - 12;
  if (ty < 4) ty = 4;
  tooltipEl.style.left = tx + 'px';
  tooltipEl.style.top  = ty + 'px';
}

function hideTooltip() {
  tooltipEl.classList.remove('visible');
}

function bubble(x, y, text, color, opts) {
  var o = opts || {};
  bubbles.push({ x:x, y:y-8, text:text, sub:o.sub||null, color:color, bg:(o.bg||color.slice(0,7))+'18', age:0, life:o.life||1.9, rise:o.rise||18, wobble:Math.random()*6 });
}

function updateDiffBanner() {
  var banner = document.getElementById('diff-banner');
  if (!prevArch || prevArch === currentArch) { banner.classList.remove('visible'); return; }
  var prev = ARCHS[prevArch], curr = ARCHS[currentArch];
  var parts = [];
  for (var k in curr.blocks) {
    var v = curr.blocks[k]; if (!v) continue;
    var prevBlock = prev.blocks[k];
    if (!prevBlock && v) parts.push('<span class="new-tag">+ ' + v.label + '</span>');
    else if (prevBlock && v.changed) parts.push('<span class="changed-tag">‚Üë ' + v.label + '</span>');
  }
  for (var k2 in prev.blocks) {
    var v2 = prev.blocks[k2]; if (!v2) continue;
    if (!curr.blocks[k2] || curr.blocks[k2] === null) parts.push('<span class="removed-tag">' + v2.label + '</span>');
  }
  if (curr.keyChange) parts.push('<br><span style="color:var(--dim)">Key: ' + curr.keyChange + '</span>');
  if (parts.length) {
    banner.innerHTML = '<strong style="color:' + curr.color + '">' + prev.name + ' ‚Üí ' + curr.name + ':</strong> ' + parts.join(' ¬∑ ');
    banner.classList.add('visible');
  } else { banner.classList.remove('visible'); }
}

function updateKeyCard() {
  var arch = ARCHS[currentArch];
  var prev = prevArch ? ARCHS[prevArch] : null;
  var html = '<h3>Diagram Key ‚Äî ' + arch.name + ' <span style="color:' + arch.color + ';font-weight:600">' + arch.example + '</span></h3>';
  var items = [
    { key:'l1', color:'var(--l1)', meta:'per-SM' },
    { key:'texCache', color:'#e599f7', meta:'per-SM' },
    { key:'sharedMem', color:'var(--smem)', meta:'per-SM' },
    { key:'warpScheduler', color:'#a78bfa', meta:'per-SM' },
    { key:'dsmem', color:'var(--new-block)', meta:'cluster' },
    { key:'tma', color:'var(--new-block)', meta:'per-SM' },
    { key:'asyncCopy', color:'var(--new-block)', meta:'engine' },
    { key:'arbiter', color:'#f59e0b', meta:'atomic ctrl' },
    { key:'cohDir', color:'#22d3ee', meta:'dir-based' },
    { key:'coherencyBus', color:'var(--coherency)', meta:'fabric' },
    { key:'l2', color:'var(--l2)', meta:'unified' },
    { key:'l2Persist', color:'var(--l2)', meta:'L2 ctrl' },
    { key:'globalMem', color:'var(--global)', meta:'interface' },
    { key:'hbm', color:'var(--dram)', meta:'off-chip' },
  ];
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    var block = arch.blocks[item.key];
    if (!block) continue;
    var badge = '';
    if (block.isNew) badge = '<span class="acc-badge-new">NEW</span>';
    else if (block.changed && prev) badge = '<span class="acc-badge-changed">CHANGED</span>';
    html += '<div class="acc-item" onclick="this.classList.toggle(\'open\')"><div class="acc-head"><div class="acc-dot" style="background:' + item.color + '"></div><span class="acc-title">' + block.label + badge + '</span><span class="acc-meta">' + item.meta + '</span><span class="acc-chev">‚ñ∏</span></div><div class="acc-body"><p>' + block.desc + '</p></div></div>';
  }
  html += '<div style="margin-top:10px;padding-top:8px;border-top:1px solid var(--border);font-size:.72rem;color:var(--dim)"><strong style="color:var(--text)">Write policy:</strong> ' + arch.writePolicy + '<br><strong style="color:var(--text)">Coherency:</strong> ' + arch.coherency + '</div>';
  document.getElementById('key-card').innerHTML = html;
}

function switchArch(arch) {
  if (arch === currentArch) return;
  prevArch = currentArch;
  currentArch = arch;
  var tabs = document.querySelectorAll('.arch-tab');
  for (var i = 0; i < tabs.length; i++) { tabs[i].classList.toggle('active', tabs[i].dataset.arch === arch); }
  clearSelection();
  resetAll(true);
  buildLayout();
  updateDiffBanner();
  updateKeyCard();
  updateArchIntro();
  logEvent('Switched to ' + ARCHS[arch].name + ' (' + ARCHS[arch].gen + ')', ARCHS[arch].color);
}

function updateArchIntro() {
  var arch = ARCHS[currentArch];
  document.getElementById('arch-intro').innerHTML = '<div class="arch-intro-badge" style="background:' + arch.color + '20;color:' + arch.color + '">' + arch.name + ' ¬∑ ' + arch.example + '</div><div class="arch-intro-text">' + arch.intro + '</div>';
}

function buildLayout() {
  if (!W || !H) return;
  var cx = W/2;
  var mob = W < 500;
  var arch = ARCHS[currentArch];
  var smCount = mob ? 2 : (currentArch === 'hopper' ? 4 : (currentArch === 'pascal' ? 3 : (currentArch === 'apex' ? 4 : 4)));
  var margin = mob ? 12 : 30;
  var usable = W - margin*2;
  var smGap = mob ? 12 : 20;
  var smW = Math.min(110, (usable - (smCount-1)*smGap)/smCount);
  var smSubBlocks = 2;
  if (arch.blocks.texCache) smSubBlocks++;
  if (arch.blocks.tma) smSubBlocks++;
  if (arch.blocks.dsmem) smSubBlocks++;
  if (arch.blocks.asyncCopy && arch.blocks.asyncCopy.isNew) smSubBlocks++;
  if (arch.blocks.warpScheduler) smSubBlocks++;
  var smH = mob ? (80+smSubBlocks*18) : (90+smSubBlocks*22);
  var totalSmW = smCount*smW + (smCount-1)*smGap;
  var smStartX = cx - totalSmW/2;
  var smY = mob ? 16 : 30;

  layout.sms = [];
  for (var i = 0; i < smCount; i++) {
    var x = smStartX + i*(smW+smGap);
    var subY = smY + (mob ? 32 : 38);
    var subH = mob ? 18 : 22;
    var subPad = mob ? 4 : 5;
    var sub = [];
    sub.push({ type:'regs', x:x+6, y:subY, w:smW-12, h:6 });
    subY += 10;
    if (arch.blocks.texCache) {
      sub.push({ type:'texCache', x:x+6, y:subY, w:smW-12, h:subH, label:'TEX$' });
      subY += subH+subPad;
    }
    sub.push({ type:'l1', x:x+6, y:subY, w:smW-12, h:subH, label:arch.blocks.l1.label.split('(')[0].trim(), state:'invalid' });
    var l1Ref = sub[sub.length-1];
    subY += subH+subPad;
    sub.push({ type:'smem', x:x+6, y:subY, w:smW-12, h:subH, label:'SMEM' });
    subY += subH+subPad;
    if (arch.blocks.tma) {
      sub.push({ type:'tma', x:x+6, y:subY, w:smW-12, h:subH, label:'TMA' });
      subY += subH+subPad;
    }
    if (arch.blocks.dsmem) {
      sub.push({ type:'dsmem', x:x+6, y:subY, w:smW-12, h:subH, label:'DSMEM' });
      subY += subH+subPad;
    }
    if (arch.blocks.asyncCopy && (currentArch === 'ampere' || currentArch === 'hopper')) {
      sub.push({ type:'async', x:x+6, y:subY, w:smW-12, h:14, label:'cp.async' });
      subY += 14+subPad;
    }
    if (arch.blocks.warpScheduler) {
      sub.push({ type:'warpScheduler', x:x+6, y:subY, w:smW-12, h:subH, label:'WARP SCHED' });
      subY += subH+subPad;
    }
    var actualH = Math.max(smH, subY-smY+8);
    layout.sms.push({ x:x, y:smY, w:smW, h:actualH, label:arch.smLabel+' '+i, sub:sub, l1:l1Ref });
  }

  var maxSmBottom = 0;
  for (var j = 0; j < layout.sms.length; j++) { maxSmBottom = Math.max(maxSmBottom, layout.sms[j].y+layout.sms[j].h); }

  if (currentArch === 'hopper' && smCount > 1) {
    layout.cluster = { x1:smStartX-6, x2:smStartX+totalSmW+6, y1:smY-8, y2:maxSmBottom+8 };
  } else { layout.cluster = null; }

  var busY = maxSmBottom + (mob ? 30 : 40);
  layout.bus = { y:busY, x1:smStartX-15, x2:smStartX+totalSmW+15, label:currentArch==='hopper' ? 'CLUSTER BUS + COHERENCY' : (currentArch==='pascal' ? 'CROSSBAR' : 'COHERENCY BUS') };

  var l2W = Math.min(totalSmW*0.85, usable*0.78);
  var l2Y = busY + (mob ? 35 : 45);
  var l2H = mob ? 42 : 52;
  layout.l2 = { x:cx-l2W/2, y:l2Y, w:l2W, h:l2H };
  layout.l2Persist = (currentArch==='ampere'||currentArch==='hopper') ? { x:cx-l2W/2+6, y:l2Y+l2H-12, w:l2W-12, h:8 } : null;

  // Shared vars needed by both Apex and non-Apex paths
  var gmH = mob ? 52 : 62;
  var mcCount = mob ? 2 : (currentArch==='pascal' ? 3 : 4);
  var mcW = mob ? 36 : 44;

  // Apex-specific: Arbiter is a FULL-WIDTH block between bus and L2
  // cohDir is a sub-region INSIDE L2 (right portion)
  if (currentArch === 'apex') {
    var arbH = mob ? 56 : 68;
    var arbGap = mob ? 52 : 72;  // big gap so ACK travel is clearly visible
    // Arbiter and L2 span the full usable width on Apex
    var apexW = Math.min(usable * 0.92, totalSmW * 1.02);
    var apexX = cx - apexW/2;
    var newL2Y = l2Y + arbH + arbGap;
    layout.arbiter = { x: apexX, y: l2Y, w: apexW, h: arbH };
    // Shift l2 down to make room
    layout.l2 = { x: apexX, y: newL2Y, w: apexW, h: l2H };
    // cohDir is a sub-region inside l2 (right 35%)
    var cdW = Math.round(apexW * 0.35);
    layout.cohDir = { x: apexX + apexW - cdW - 6, y: newL2Y + 6, w: cdW, h: l2H - 12 };
    // Shift everything below l2 down too
    var cbY2 = newL2Y + l2H + (mob ? 22 : 30);
    layout.crossbar = { y: cbY2, x1: apexX-8, x2: apexX+apexW+8 };
    var gmY2 = cbY2 + (mob ? 28 : 38);
    var gmW2 = apexW;
    layout.globalMem = { x: apexX, y: gmY2, w: gmW2, h: gmH };
    var mcGap3 = (gmW2 - mcCount*mcW)/(mcCount+1);
    layout.mcs = [];
    for (var mi2 = 0; mi2 < mcCount; mi2++) {
      layout.mcs.push({ x: layout.globalMem.x+mcGap3+mi2*(mcW+mcGap3), y: gmY2+24, w: mcW, h: 14 });
    }
    var hbmY2 = gmY2 + gmH + (mob ? 16 : 22);
    var hbmW2 = gmW2*0.88;
    layout.hbm = { x: cx-hbmW2/2, y: hbmY2, w: hbmW2, h: mob ? 34 : 42, label: ARCHS[currentArch].blocks.hbm.label };
  } else {
    // Non-Apex: no arbiter, standard layout
    layout.arbiter = null;
    layout.cohDir = null;

    var cbY = l2Y+l2H+(mob ? 22 : 30);
    layout.crossbar = { y:cbY, x1:cx-l2W/2-8, x2:cx+l2W/2+8 };

    var gmW = Math.min(totalSmW*0.85, usable*0.82);
    var gmY = cbY + (mob ? 28 : 38);
    layout.globalMem = { x:cx-gmW/2, y:gmY, w:gmW, h:gmH };

    var mcGap2 = (gmW - mcCount*mcW)/(mcCount+1);
    layout.mcs = [];
    for (var mi = 0; mi < mcCount; mi++) {
      layout.mcs.push({ x:layout.globalMem.x+mcGap2+mi*(mcW+mcGap2), y:gmY+24, w:mcW, h:14 });
    }

    var hbmY = gmY+gmH+(mob ? 16 : 22);
    var hbmW = gmW*0.88;
    layout.hbm = { x:cx-hbmW/2, y:hbmY, w:hbmW, h:mob ? 34 : 42, label:ARCHS[currentArch].blocks.hbm.label };
  }

  buildHitRects();
  initCacheState();
}

function bezierPoint(p0, cp1, cp2, p1, t) {
  var mt = 1 - t;
  return {
    x: mt*mt*mt*p0.x + 3*mt*mt*t*cp1.x + 3*mt*t*t*cp2.x + t*t*t*p1.x,
    y: mt*mt*mt*p0.y + 3*mt*mt*t*cp1.y + 3*mt*t*t*cp2.y + t*t*t*p1.y,
  };
}

function drawConnLines(time) {
  if (connLines.length === 0) return;
  connLineAnim += 0.022;
  for (var i = 0; i < connLines.length; i++) {
    var cl = connLines[i];
    var dx = cl.to.x - cl.from.x;
    var dy = cl.to.y - cl.from.y;
    var dist = Math.sqrt(dx*dx + dy*dy);

    var isVertical = Math.abs(dy) > Math.abs(dx);
    var bow = Math.min(dist * 0.35, 60) * (i % 2 === 0 ? 1 : -1);
    var cp1, cp2;
    if (isVertical) {
      cp1 = { x: cl.from.x + bow, y: cl.from.y + dy * 0.3 };
      cp2 = { x: cl.to.x + bow,   y: cl.to.y   - dy * 0.3 };
    } else {
      cp1 = { x: cl.from.x + dx * 0.3, y: cl.from.y + bow };
      cp2 = { x: cl.to.x   - dx * 0.3, y: cl.to.y   + bow };
    }

    var alpha = 0.55 + Math.sin(connLineAnim * 2.5 + i * 1.2) * 0.2;
    var colorHex = cl.color + Math.round(alpha * 255).toString(16).padStart(2,'0');

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(cl.from.x, cl.from.y);
    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, cl.to.x, cl.to.y);
    ctx.strokeStyle = cl.color + '18';
    ctx.lineWidth = 7;
    ctx.setLineDash([]);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(cl.from.x, cl.from.y);
    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, cl.to.x, cl.to.y);
    ctx.strokeStyle = colorHex;
    ctx.lineWidth = 1.8;
    ctx.setLineDash([7, 5]);
    ctx.lineDashOffset = -connLineAnim * 28;
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.beginPath(); ctx.arc(cl.from.x, cl.from.y, 3.5, 0, Math.PI*2);
    ctx.fillStyle = cl.color; ctx.fill();
    ctx.beginPath(); ctx.arc(cl.from.x, cl.from.y, 6, 0, Math.PI*2);
    ctx.fillStyle = cl.color + '30'; ctx.fill();

    var tip  = bezierPoint({x:cl.from.x,y:cl.from.y}, cp1, cp2, {x:cl.to.x,y:cl.to.y}, 0.98);
    var tang = bezierPoint({x:cl.from.x,y:cl.from.y}, cp1, cp2, {x:cl.to.x,y:cl.to.y}, 0.93);
    var angle = Math.atan2(cl.to.y - tang.y, cl.to.x - tang.x);
    ctx.translate(cl.to.x, cl.to.y);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-9, -4.5);
    ctx.lineTo(-9, 4.5);
    ctx.closePath();
    ctx.fillStyle = cl.color + 'dd';
    ctx.fill();

    var travelT = (connLineAnim * 0.55 + i * 0.28) % 1.0;
    ctx.restore();
    var tp = bezierPoint({x:cl.from.x,y:cl.from.y}, cp1, cp2, {x:cl.to.x,y:cl.to.y}, travelT);
    ctx.beginPath(); ctx.arc(tp.x, tp.y, 4, 0, Math.PI*2);
    ctx.fillStyle = cl.color; ctx.fill();
    ctx.beginPath(); ctx.arc(tp.x, tp.y, 8, 0, Math.PI*2);
    ctx.fillStyle = cl.color + '28'; ctx.fill();
  }
}

function drawHoverHighlight() {
  if (!hoveredBlock) return;
  var r = hoveredBlock;
  ctx.save();
  rrect(r.x-3, r.y-3, r.w+6, r.h+6, 6);
  var info = BLOCK_INFO[r.type];
  var hcolor = info ? info.color : '#ffffff';
  ctx.strokeStyle = hcolor + 'cc';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.fillStyle = hcolor + '10';
  ctx.fill();
  ctx.restore();
}

function drawSelectionHighlight() {
  if (!selectedBlock) return;
  var r = selectedBlock;
  ctx.save();
  rrect(r.x-4, r.y-4, r.w+8, r.h+8, 7);
  var info = BLOCK_INFO[r.type];
  var scolor = info ? info.color : '#ffffff';
  var pulse = 0.6 + Math.sin(Date.now()/300) * 0.4;
  ctx.strokeStyle = scolor + Math.round(pulse * 255).toString(16).padStart(2,'0');
  ctx.lineWidth = 2.5;
  ctx.stroke();
  ctx.fillStyle = scolor + '15';
  ctx.fill();
  ctx.restore();
}

function drawFrame(time) {
  if (!initialized || !layout.sms) { requestAnimationFrame(drawFrame); return; }
  
  // ‚îÄ‚îÄ Pause: freeze animation but keep RAF running for tooltip responsiveness ‚îÄ‚îÄ
  if (paused) {
    // Still draw the static frame so hovering works, but don't advance time
    // Just redraw without updating dt-dependent state
    drawStaticFrame();
    requestAnimationFrame(drawFrame);
    return;
  }

  var dt = Math.min((time - lastTime)/1000, 0.05);
  lastTime = time;
  drawAnimatedFrame(dt, time);
  requestAnimationFrame(drawFrame);
}

function drawStaticFrame() {
  ctx.clearRect(0, 0, W, H);
  drawSceneContent(0, performance.now());
  if (hoveredBlock && (hoveredBlock.type === 'l1' || hoveredBlock.type === 'smem')) {
    refreshTooltipCacheData(hoveredBlock, BLOCK_INFO[hoveredBlock.type]);
  }
}

function drawAnimatedFrame(dt, time) {
  ctx.clearRect(0, 0, W, H);
  drawSceneContent(dt, time);

  // Live tooltip refresh for cache blocks
  if (hoveredBlock && (hoveredBlock.type === 'l1' || hoveredBlock.type === 'smem')) {
    refreshTooltipCacheData(hoveredBlock, BLOCK_INFO[hoveredBlock.type]);
  }
  // Live tooltip refresh for arbiter (state changes while hovered)
  if (hoveredBlock && hoveredBlock.type === 'arbiter' && tooltipEl.classList.contains('visible')) {
    updateTooltip(hoveredBlock, lastClientX, lastClientY);
  }

  if (autoMode) {
    autoTimer+=dt;
    if (autoTimer>2.8) {
      autoTimer=0;
      var ops = currentArch === 'apex'
        ? ['read','write','invalidate','writeback','shared','atomic']
        : ['read','write','invalidate','writeback','shared'];
      triggerScenario(ops[Math.floor(Math.random()*ops.length)]);
    }
  }
}

function drawSceneContent(dt, time) {
  var arch = ARCHS[currentArch];
  var mob = W < 500;
  var fs = mob ? 0.88 : 1;
  var FONT_SM_LABEL  = Math.max(10, 10*fs);
  var FONT_SM_WARP   = Math.max(7,  7*fs);
  var FONT_BLOCK_LG  = Math.max(8,  8*fs);
  var FONT_BLOCK_SM  = Math.max(7.5, 7.5*fs);
  var FONT_BLOCK_XS  = Math.max(7,  7*fs);
  var FONT_L2        = Math.max(11, 11*fs);
  var FONT_LABEL_MED = Math.max(10, 10*fs);
  var FONT_LABEL_SM  = Math.max(7,  7*fs);
  var FONT_HBM       = Math.max(11, 11*fs);

  if (layout.cluster) {
    var c = layout.cluster;
    ctx.setLineDash([4,4]);
    rrect(c.x1, c.y1, c.x2-c.x1, c.y2-c.y1, 10);
    ctx.strokeStyle = arch.color+'40'; ctx.lineWidth=1.5; ctx.stroke();
    ctx.setLineDash([]);
    ctx.font='bold '+Math.max(8,8*fs)+'px "JetBrains Mono"';
    ctx.fillStyle=arch.color+'90'; ctx.textAlign='center';
    ctx.fillText('THREAD BLOCK CLUSTER', (c.x1+c.x2)/2, c.y1-2);
  }

  for (var si = 0; si < layout.sms.length; si++) {
    var sm = layout.sms[si];
    rrect(sm.x, sm.y, sm.w, sm.h, 7);
    ctx.fillStyle='#0f1118'; ctx.fill();
    ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1; ctx.stroke();
    ctx.font='700 '+FONT_SM_LABEL+'px "Outfit"';
    ctx.fillStyle='#e8eaf6'; ctx.textAlign='center';
    ctx.fillText(sm.label, sm.x+sm.w/2, sm.y+14*fs);
    ctx.font='400 '+FONT_SM_WARP+'px "JetBrains Mono"';
    ctx.fillStyle='#8890b0';
    ctx.fillText('Warps ‚ñ∏‚ñ∏‚ñ∏', sm.x+sm.w/2, sm.y+24*fs);

    for (var bi = 0; bi < sm.sub.length; bi++) {
      var b = sm.sub[bi];
      if (b.type === 'regs') {
        var barC = Math.max(4, Math.floor(b.w/10));
        for (var rj = 0; rj < barC; rj++) {
          ctx.fillStyle='hsl(220,30%,'+(19+Math.sin(Date.now()/800+rj+si)*3)+'%)';
          ctx.fillRect(b.x+rj*(b.w/barC), b.y, b.w/barC-1.5, b.h);
        }
        continue;
      }
      rrect(b.x, b.y, b.w, b.h, 3);
      if (b.type === 'l1' && b.state) {
        var stColors = { modified:'#51cf66', shared:'#339af0', invalid:'#6b7090' };
        var sc = stColors[b.state]||'#6b7090';
        ctx.fillStyle = b.state === 'invalid' ? '#6b709018' : sc+'22'; ctx.fill();
        ctx.strokeStyle = b.state === 'invalid' ? '#5a5e78' : sc; ctx.lineWidth=1.5; ctx.stroke();

        var csm2 = cacheState[si];
        if (csm2) {
          var lines2 = csm2.l1;
          var gx = b.x + 4, gw = b.w - 8;
          var slotW = gw / NUM_LINES;
          var gy = b.y + b.h - 6;
          for (var li = 0; li < NUM_LINES; li++) {
            var lv = lines2[li];
            var lc = lv === 2 ? '#51cf66' : (lv === 1 ? (b.state==='shared'?'#339af0':'#51cf6688') : '#2a2d3a');
            ctx.fillStyle = lc;
            ctx.fillRect(gx + li*slotW + 0.5, gy, slotW - 1, 4);
          }
        }

        ctx.font='600 '+FONT_BLOCK_LG+'px "JetBrains Mono"';
        ctx.fillStyle = b.state === 'invalid' ? '#9095b0' : sc;
        ctx.textAlign='center';
        ctx.fillText(b.label+' ['+b.state.charAt(0).toUpperCase()+']', b.x+b.w/2, b.y+b.h/2+1);
      } else {
        var cBg, cBr, cLbl;
        if (b.type==='texCache')             { cBg='#e599f712'; cBr='#e599f760'; cLbl='#e599f7'; }
        else if (b.type==='tma')             { cBg='#22d3ee12'; cBr='#22d3ee70'; cLbl='#22d3ee'; }
        else if (b.type==='dsmem')           { cBg='#22d3ee10'; cBr='#22d3ee60'; cLbl='#22d3ee'; }
        else if (b.type==='async')           { cBg='#22d3ee0a'; cBr='#22d3ee45'; cLbl='#6de8f0'; }
        else if (b.type==='warpScheduler')   { cBg='#a78bfa12'; cBr='#a78bfa60'; cLbl='#c4b5fd'; }
        else /* smem */                      { cBg='#51cf660a'; cBr='#51cf6660'; cLbl='#6ee09a'; }
        ctx.fillStyle=cBg; ctx.fill();
        ctx.strokeStyle=cBr; ctx.lineWidth=1; ctx.stroke();

        if (b.type === 'smem') {
          var csm3 = cacheState[si];
          if (csm3) {
            var slines = csm3.smem;
            var sgx = b.x + 4, sgw = b.w - 8;
            var sslotW = sgw / NUM_LINES;
            var sgy = b.y + b.h - 5;
            for (var sli2 = 0; sli2 < NUM_LINES; sli2++) {
              ctx.fillStyle = slines[sli2] === 1 ? '#51cf6680' : '#1e2030';
              ctx.fillRect(sgx + sli2*sslotW + 0.5, sgy, sslotW - 1, 3);
            }
          }
        }

        var lblFs = (b.type==='async') ? FONT_BLOCK_XS : FONT_BLOCK_SM;
        ctx.font='600 '+lblFs+'px "JetBrains Mono"';
        ctx.fillStyle=cLbl; ctx.textAlign='center';
        ctx.fillText(b.label, b.x+b.w/2, b.y+b.h/2+1);
      }
    }
  }

  drawHoverHighlight();
  drawSelectionHighlight();
  drawConnLines(time);

  // ‚îÄ‚îÄ Draw Apex arbiter (full-width block) and cohDir (L2 sub-region) ‚îÄ‚îÄ
  if (currentArch === 'apex' && layout.arbiter) {
    var arb = layout.arbiter;
    var arbTime2 = Date.now();
    var arbPulse = Math.sin(arbTime2/600) * 0.3 + 0.7;
    var isHovArb = hoveredBlock && hoveredBlock.type === 'arbiter';
    var latFrac = Math.min(arbiterState.contentionLevel, 1);
    var arbColor = latFrac > 0.6 ? '#ff6b6b' : '#f59e0b';

    // Main block
    rrect(arb.x, arb.y, arb.w, arb.h, 8);
    ctx.fillStyle = isHovArb ? '#f59e0b18' : '#f59e0b0c'; ctx.fill();
    ctx.strokeStyle = arbColor + Math.round(arbPulse * (isHovArb ? 230 : 160)).toString(16).padStart(2,'0');
    ctx.lineWidth = isHovArb ? 2 : 1.5; ctx.stroke();

    if (arbiterState.active) {
      ctx.save(); ctx.shadowColor = '#f59e0b'; ctx.shadowBlur = 14;
      rrect(arb.x, arb.y, arb.w, arb.h, 8);
      ctx.strokeStyle = '#f59e0b25'; ctx.lineWidth = 3; ctx.stroke();
      ctx.restore();
    }

    // Header strip
    ctx.fillStyle = '#f59e0b16';
    rrect(arb.x+1, arb.y+1, arb.w-2, 17, 7); ctx.fill();

    ctx.font = '700 8.5px "JetBrains Mono"'; ctx.fillStyle = '#f59e0b'; ctx.textAlign = 'left';
    ctx.fillText('‚öñ ATOMIC ARBITER', arb.x + 12, arb.y + 13);
    var statusText = arbiterState.queue.length >= 4 ? 'SATURATED' : arbiterState.active ? 'ACTIVE' : 'IDLE';
    var statusColor = arbiterState.queue.length >= 4 ? '#ff6b6b' : arbiterState.active ? '#fbbf24' : '#4a5080';
    ctx.font = '600 7px "JetBrains Mono"'; ctx.fillStyle = statusColor; ctx.textAlign = 'right';
    ctx.fillText('‚óè ' + statusText, arb.x + arb.w - 12, arb.y + 13);

    // ‚îÄ‚îÄ Layout: divide arbiter into left (QUEUE) and right (HOLD BUFFER / ROB) ‚îÄ‚îÄ
    var divX = arb.x + arb.w * 0.48;  // vertical divider x
    var innerY = arb.y + 21;
    var slotH2 = 15, slotGap2 = 4;

    // Divider line
    ctx.strokeStyle = '#f59e0b20'; ctx.lineWidth = 1;
    ctx.setLineDash([3,3]);
    ctx.beginPath(); ctx.moveTo(divX, arb.y + 18); ctx.lineTo(divX, arb.y + arb.h - 6); ctx.stroke();
    ctx.setLineDash([]);

    // ‚îÄ‚îÄ LEFT: INCOMING QUEUE ‚îÄ‚îÄ
    var qLabelX = arb.x + 12;
    ctx.font = '600 6px "JetBrains Mono"'; ctx.fillStyle = '#f59e0b60'; ctx.textAlign = 'left';
    ctx.fillText('INCOMING QUEUE', qLabelX, innerY + 7);
    var qSlotW2 = 24;
    var qSlotStartX = qLabelX;
    var qSlotY = innerY + 11;
    var maxQSlots = Math.floor((divX - qLabelX - 12) / (qSlotW2 + slotGap2));
    maxQSlots = Math.min(maxQSlots, 6);
    for (var qs2 = 0; qs2 < maxQSlots; qs2++) {
      var sx2 = qSlotStartX + qs2 * (qSlotW2 + slotGap2);
      var qe2 = qs2 < arbiterState.queue.length ? arbiterState.queue[qs2] : null;
      ctx.fillStyle = qe2 ? '#f59e0b22' : '#141620';
      ctx.strokeStyle = qe2 ? '#f59e0baa' : '#252840'; ctx.lineWidth = qe2 ? 1.1 : 0.7;
      rrect(sx2, qSlotY, qSlotW2, slotH2, 3); ctx.fill(); ctx.stroke();
      ctx.font = '700 6px "JetBrains Mono"'; ctx.textAlign = 'center';
      ctx.fillStyle = qe2 ? '#fbbf24' : '#2a2d45';
      ctx.fillText(qe2 ? '#'+qe2.seq : '‚Äî', sx2 + qSlotW2/2, qSlotY + 10);
      // SM label below slot
      if (qe2) {
        ctx.font = '500 5px "JetBrains Mono"'; ctx.fillStyle = '#f59e0b60';
        ctx.fillText('SM'+qe2.smIdx, sx2 + qSlotW2/2, qSlotY + slotH2 + 6);
      }
    }

    // Queue depth indicator
    var qBotY = qSlotY + slotH2 + 11;
    ctx.font = '500 6px "JetBrains Mono"'; ctx.fillStyle = '#f59e0b50'; ctx.textAlign = 'left';
    ctx.fillText('SEQ#' + String(arbiterState.seqCounter).padStart(3,'0'), qLabelX, qBotY);

    // ‚îÄ‚îÄ RIGHT: HOLD BUFFER (ROB) ‚îÄ‚îÄ
    var robLabelX = divX + 10;
    ctx.font = '600 6px "JetBrains Mono"'; ctx.fillStyle = '#a78bfa90'; ctx.textAlign = 'left';
    ctx.fillText('HOLD BUFFER  (ROB)', robLabelX, innerY + 7);
    var robSlotW2 = Math.floor((arb.x + arb.w - robLabelX - 12) / 6) - slotGap2;
    robSlotW2 = Math.max(robSlotW2, 18);
    var robSlotY = innerY + 11;
    for (var rs2 = 0; rs2 < 6; rs2++) {
      var rx3 = robLabelX + rs2 * (robSlotW2 + slotGap2);
      if (rx3 + robSlotW2 > arb.x + arb.w - 8) break;
      var robE2 = rs2 < arbiterState.rob.length ? arbiterState.rob[rs2] : null;
      var rBg2 = '#141620', rBr2 = '#252840', rTxt2 = '#2a2d45';
      var rIcon = '';
      if (robE2) {
        if (robE2.state === 'pending')   { rBg2='#f59e0b18'; rBr2='#f59e0b70'; rTxt2='#f59e0b'; rIcon='‚è≥'; }
        if (robE2.state === 'complete')  { rBg2='#339af020'; rBr2='#339af090'; rTxt2='#339af0'; rIcon='‚ú¶'; } // ACK back, waiting for head
        if (robE2.state === 'retiring')  { rBg2='#a78bfa20'; rBr2='#a78bfa80'; rTxt2='#a78bfa'; rIcon='‚Ü©'; } // head-of-line, being retired
        if (robE2.state === 'done')      { rBg2='#51cf6620'; rBr2='#51cf6680'; rTxt2='#51cf66'; rIcon='‚úì'; } // retired, DATA sent
      }
      ctx.fillStyle = rBg2; ctx.strokeStyle = rBr2; ctx.lineWidth = robE2 ? 1.1 : 0.7;
      rrect(rx3, robSlotY, robSlotW2, slotH2, 3); ctx.fill(); ctx.stroke();
      ctx.font = '700 5.5px "JetBrains Mono"'; ctx.textAlign = 'center';
      ctx.fillStyle = rTxt2;
      ctx.fillText(robE2 ? '#'+robE2.seq : '‚Äî', rx3 + robSlotW2/2, robSlotY + 7);
      if (robE2) {
        ctx.font = '500 5px "JetBrains Mono"'; ctx.fillStyle = rTxt2 + '90';
        ctx.fillText(rIcon, rx3 + robSlotW2/2, robSlotY + 13);
      }
    }

    // ROB state legend
    var robBotY = robSlotY + slotH2 + 11;
    ctx.font = '500 5.5px "JetBrains Mono"'; ctx.textAlign = 'left';
    ctx.fillStyle = '#f59e0b60'; ctx.fillText('‚è≥ pending', robLabelX, robBotY);
    ctx.fillStyle = '#339af060'; ctx.fillText('‚ú¶ complete', robLabelX + 52, robBotY);
    ctx.fillStyle = '#a78bfa60'; ctx.fillText('‚Ü© retiring', robLabelX + 110, robBotY);
    ctx.fillStyle = '#51cf6660'; ctx.fillText('‚úì done', robLabelX + 162, robBotY);

    // ‚îÄ‚îÄ LEFT GUTTER ANNOTATION (side panel, left of arbiter) ‚îÄ‚îÄ
    var gutterX = arb.x - 8;
    var gutterW = Math.max(gutterX - 10, 0);
    if (gutterW > 40) {
      var gx = 8, gw = gutterX - 12;
      var gArbY = arb.y + 4;
      ctx.font = '500 5.5px "JetBrains Mono"'; ctx.fillStyle = '#f59e0b40'; ctx.textAlign = 'right';
      ctx.fillText('SERIALIZES', gx + gw, gArbY + 8);
      ctx.fillText('ATOMICS', gx + gw, gArbY + 16);
      ctx.fillStyle = '#f59e0b25'; ctx.textAlign = 'right';
      ctx.fillText('SEQ# tags', gx + gw, gArbY + 26);
      ctx.fillText('ROB order', gx + gw, gArbY + 34);
      // Contention bar
      var gbY = gArbY + 42;
      ctx.font = '500 5px "JetBrains Mono"'; ctx.fillStyle = '#f59e0b40'; ctx.textAlign = 'right';
      ctx.fillText('contention', gx + gw, gbY);
      ctx.fillStyle = '#141620';
      ctx.fillRect(gx + gw - 36, gbY + 2, 36, 4);
      if (latFrac > 0) {
        var gGrad = ctx.createLinearGradient(gx + gw - 36, 0, gx + gw, 0);
        gGrad.addColorStop(0, '#51cf66'); gGrad.addColorStop(0.5, '#f59e0b'); gGrad.addColorStop(1, '#ff6b6b');
        ctx.fillStyle = gGrad;
        ctx.fillRect(gx + gw - 36, gbY + 2, 36 * latFrac, 4);
      }
      ctx.font = '600 5.5px "JetBrains Mono"'; ctx.fillStyle = '#f59e0b'; ctx.textAlign = 'right';
      var cycEst3 = Math.round(2 + latFrac * 30);
      ctx.fillText('~'+cycEst3+'cyc', gx + gw, gbY + 14);
    }

    // ‚îÄ‚îÄ RIGHT GUTTER ANNOTATION (side panel, right of arbiter) ‚îÄ‚îÄ
    var rGutterX = arb.x + arb.w + 8;
    var rGutterW = W - rGutterX - 8;
    if (rGutterW > 40) {
      var rgx = rGutterX + 4;
      var rgArbY = arb.y + 4;
      ctx.font = '500 5.5px "JetBrains Mono"'; ctx.fillStyle = '#f59e0b40'; ctx.textAlign = 'left';
      ctx.fillText('GRANT policy:', rgx, rgArbY + 8);
      ctx.fillStyle = '#f59e0b25';
      ctx.fillText('round-robin', rgx, rgArbY + 17);
      ctx.fillText('1 at a time', rgx, rgArbY + 26);
      ctx.font = '500 5px "JetBrains Mono"';
      ctx.fillStyle = '#f59e0b20';
      ctx.fillText('Granted: '+arbiterState.grantCount, rgx, rgArbY + 37);
    }
  }

  // ‚îÄ‚îÄ cohDir drawn as sub-region INSIDE L2 block ‚îÄ‚îÄ
  if (currentArch === 'apex' && layout.cohDir) {
    var cd = layout.cohDir;
    var isHovCd = hoveredBlock && hoveredBlock.type === 'cohDir';
    var cdPulse = Math.sin(Date.now()/900) * 0.2 + 0.8;
    rrect(cd.x, cd.y, cd.w, cd.h, 5);
    ctx.fillStyle = isHovCd ? '#22d3ee18' : '#22d3ee0a'; ctx.fill();
    ctx.strokeStyle = '#22d3ee' + Math.round(cdPulse * (isHovCd ? 200 : 100)).toString(16).padStart(2,'0');
    ctx.lineWidth = isHovCd ? 1.5 : 0.8; ctx.stroke();
    ctx.font = '700 6.5px "JetBrains Mono"'; ctx.fillStyle = '#22d3ee'; ctx.textAlign = 'center';
    ctx.fillText('COH. DIR', cd.x + cd.w/2, cd.y + 10);
    var cdRowH = 5, cdRowGap = 2, cdRows = 3, cdBitCount = 4;
    for (var dr2 = 0; dr2 < cdRows; dr2++) {
      var ry2 = cd.y + 15 + dr2 * (cdRowH + cdRowGap);
      var cdBitW = (cd.w - 14) / cdBitCount;
      for (var db2 = 0; db2 < cdBitCount; db2++) {
        var hasSharer = (dr2 * 7 + db2 * 3 + Math.floor(Date.now()/2000)) % 3 !== 0;
        ctx.fillStyle = hasSharer ? '#22d3ee35' : '#1a1c28';
        ctx.strokeStyle = '#22d3ee30'; ctx.lineWidth = 0.5;
        ctx.fillRect(cd.x + 7 + db2*cdBitW, ry2, cdBitW-1, cdRowH);
      }
    }
    ctx.font = '500 5.5px "JetBrains Mono"'; ctx.fillStyle = '#22d3ee50'; ctx.textAlign = 'center';
    ctx.fillText('targeted', cd.x + cd.w/2, cd.y + cd.h - 3);

    // ‚îÄ‚îÄ L2 RIGHT GUTTER: bandwidth and state info ‚îÄ‚îÄ
    var l2 = layout.l2;
    var l2RGutX = l2.x + l2.w + 8;
    var l2RGutW = W - l2RGutX - 8;
    if (l2RGutW > 40) {
      var l2gx = l2RGutX + 4;
      var l2gY = l2.y + 4;
      ctx.font = '500 5.5px "JetBrains Mono"'; ctx.fillStyle = '#ffa94d40'; ctx.textAlign = 'left';
      ctx.fillText('L2: 64MB', l2gx, l2gY + 8);
      ctx.fillText('unified', l2gx, l2gY + 17);
      ctx.fillStyle = '#22d3ee30';
      ctx.fillText('coh. point', l2gx, l2gY + 28);
    }
    // ‚îÄ‚îÄ L2 LEFT GUTTER: RMW annotation ‚îÄ‚îÄ
    var l2LGutW2 = l2.x - 12;
    if (l2LGutW2 > 40) {
      ctx.font = '500 5.5px "JetBrains Mono"'; ctx.fillStyle = '#ffa94d40'; ctx.textAlign = 'right';
      ctx.fillText('RMW here', l2.x - 8, l2.y + 10);
      ctx.fillStyle = '#ffa94d20';
      ctx.fillText('~200 cyc', l2.x - 8, l2.y + 20);
    }
  }

  for (var ci = 0; ci < layout.sms.length; ci++) {
    var csm = layout.sms[ci];
    ctx.beginPath(); ctx.moveTo(csm.x+csm.w/2, csm.y+csm.h);
    ctx.lineTo(csm.x+csm.w/2, layout.bus.y);
    ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1; ctx.stroke();
  }

  if (currentArch==='hopper' && layout.sms.length>1) {
    var dsPulse = Math.sin(Date.now()/500)*0.3+0.5;
    for (var di = 0; di < layout.sms.length-1; di++) {
      var dsA=null, dsB=null;
      for (var ds1=0;ds1<layout.sms[di].sub.length;ds1++) { if(layout.sms[di].sub[ds1].type==='dsmem') dsA=layout.sms[di].sub[ds1]; }
      for (var ds2=0;ds2<layout.sms[di+1].sub.length;ds2++) { if(layout.sms[di+1].sub[ds2].type==='dsmem') dsB=layout.sms[di+1].sub[ds2]; }
      if (dsA&&dsB) {
        ctx.beginPath(); ctx.moveTo(dsA.x+dsA.w, dsA.y+dsA.h/2);
        ctx.lineTo(dsB.x, dsB.y+dsB.h/2);
        ctx.strokeStyle='rgba(34,211,238,'+(dsPulse*0.5)+')';
        ctx.lineWidth=1.5; ctx.setLineDash([3,3]); ctx.stroke(); ctx.setLineDash([]);
      }
    }
  }

  var bus = layout.bus;
  var busPulse = Math.sin(Date.now()/400)*0.3+0.5;
  ctx.setLineDash([5,3]);
  ctx.beginPath(); ctx.moveTo(bus.x1, bus.y); ctx.lineTo(bus.x2, bus.y);
  ctx.strokeStyle='#f0659550'; ctx.lineWidth=2; ctx.stroke(); ctx.setLineDash([]);
  ctx.beginPath(); ctx.moveTo(bus.x1, bus.y); ctx.lineTo(bus.x2, bus.y);
  ctx.strokeStyle='rgba(240,101,149,'+(busPulse*0.15)+')'; ctx.lineWidth=8; ctx.stroke();
  ctx.font='600 '+Math.max(8,8*fs)+'px "JetBrains Mono"';
  ctx.fillStyle='#f06595e0'; ctx.textAlign='center';
  ctx.fillText(bus.label, (bus.x1+bus.x2)/2, bus.y-9);

  ctx.beginPath(); ctx.moveTo(W/2, bus.y); ctx.lineTo(W/2, layout.l2.y);
  ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1.5; ctx.stroke();

  var l2 = layout.l2;
  rrect(l2.x, l2.y, l2.w, l2.h, 7);
  ctx.fillStyle='#1a1408'; ctx.fill();
  ctx.strokeStyle='#ffa94d60'; ctx.lineWidth=1.5; ctx.stroke();
  ctx.font='700 '+Math.max(11,11*fs)+'px "Outfit"';
  ctx.fillStyle='#ffb55a'; ctx.textAlign='center';
  ctx.fillText(arch.blocks.l2.label, l2.x+l2.w/2, l2.y+18*fs);
  var slices = mob ? 8 : 12;
  var slW = (l2.w-20)/slices;
  for (var sli=0;sli<slices;sli++) {
    ctx.fillStyle='hsl(32,40%,'+(15+Math.sin(Date.now()/600+sli*.5)*5)+'%)';
    ctx.fillRect(l2.x+10+sli*slW, l2.y+24*fs, slW-2, 10*fs);
  }

  if (layout.l2Persist) {
    var p = layout.l2Persist;
    rrect(p.x,p.y,p.w,p.h,2);
    var grad = ctx.createLinearGradient(p.x,0,p.x+p.w,0);
    grad.addColorStop(0,'#ffa94d35'); grad.addColorStop(0.6,'#ffa94d18'); grad.addColorStop(1,'#ffa94d05');
    ctx.fillStyle=grad; ctx.fill();
    ctx.strokeStyle='#ffa94d35'; ctx.lineWidth=.5; ctx.stroke();
    ctx.font='600 '+Math.max(6,6*fs)+'px "JetBrains Mono"';
    ctx.fillStyle='#ffa94da0'; ctx.textAlign='center';
    ctx.fillText('PERSIST WINDOW', p.x+p.w/2, p.y+p.h/2+2);
  }

  ctx.beginPath(); ctx.moveTo(W/2,l2.y+l2.h); ctx.lineTo(W/2,layout.crossbar.y);
  ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1.5; ctx.stroke();

  var cb = layout.crossbar;
  ctx.setLineDash([3,3]);
  ctx.beginPath(); ctx.moveTo(cb.x1,cb.y); ctx.lineTo(cb.x2,cb.y);
  ctx.strokeStyle='#339af038'; ctx.lineWidth=1.5; ctx.stroke(); ctx.setLineDash([]);
  ctx.font='600 '+Math.max(7.5,7.5*fs)+'px "JetBrains Mono"';
  ctx.fillStyle='#339af0c0'; ctx.textAlign='center';
  ctx.fillText('MEMORY CROSSBAR / NoC', (cb.x1+cb.x2)/2, cb.y-6);

  ctx.beginPath(); ctx.moveTo(W/2,cb.y); ctx.lineTo(W/2,layout.globalMem.y);
  ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1.5; ctx.stroke();

  var gm = layout.globalMem;
  rrect(gm.x,gm.y,gm.w,gm.h,7);
  ctx.fillStyle='#0d1320'; ctx.fill();
  ctx.strokeStyle='#339af050'; ctx.lineWidth=1.5; ctx.stroke();
  ctx.font='700 '+Math.max(10,10*fs)+'px "Outfit"';
  ctx.fillStyle='#5ab0f8'; ctx.textAlign='center';
  ctx.fillText('Global Memory Interface', gm.x+gm.w/2, gm.y+14);
  for (var mci=0;mci<layout.mcs.length;mci++) {
    var mc=layout.mcs[mci];
    ctx.fillStyle='hsl(210,50%,'+(14+Math.sin(Date.now()/500+mci)*3)+'%)';
    ctx.fillRect(mc.x,mc.y,mc.w,mc.h);
    ctx.font='600 '+Math.max(6.5,6.5*fs)+'px "JetBrains Mono"';
    ctx.fillStyle='#339af090'; ctx.textAlign='center';
    ctx.fillText('MC'+mci, mc.x+mc.w/2, mc.y+mc.h/2+2.5);
  }
  ctx.font='500 '+Math.max(6.5,6.5*fs)+'px "JetBrains Mono"';
  ctx.fillStyle='#8890a8'; ctx.textAlign='center';
  ctx.fillText('MC ‚Üí '+arch.blocks.hbm.label, gm.x+gm.w/2, gm.y+gm.h-5);

  ctx.beginPath(); ctx.moveTo(W/2,gm.y+gm.h); ctx.lineTo(W/2,layout.hbm.y);
  ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1.5; ctx.stroke();

  var hbm = layout.hbm;
  rrect(hbm.x,hbm.y,hbm.w,hbm.h,7);
  ctx.fillStyle='#0d0a18'; ctx.fill();
  ctx.strokeStyle='#845ef740'; ctx.lineWidth=1.5; ctx.stroke();
  ctx.font='700 '+Math.max(11,11*fs)+'px "Outfit"';
  ctx.fillStyle='#a07af8'; ctx.textAlign='center';
  ctx.fillText(hbm.label, hbm.x+hbm.w/2, hbm.y+16*fs);
  var hbmStacks = mob ? 4 : 6;
  var hstW = (hbm.w-30)/hbmStacks;
  for (var hi=0;hi<hbmStacks;hi++) {
    for (var hl=0;hl<3;hl++) {
      ctx.fillStyle='hsl(260,40%,'+(12+hl*3+Math.sin(Date.now()/700+hi+hl)*2)+'%)';
      ctx.fillRect(hbm.x+15+hi*hstW, hbm.y+22*fs+hl*3.5, hstW-4, 3);
    }
  }

  // Flash effects (skip advancement if paused)
  flashEffects = flashEffects.filter(function(f) {
    if (!paused) f.t+=0.02;
    if (f.t>=f.dur) return false;
    rrect(f.x-2,f.y-2,f.w+4,f.h+4,5);
    ctx.strokeStyle=f.c+Math.round((1-f.t/f.dur)*0.3*255).toString(16).padStart(2,'0');
    ctx.lineWidth=2; ctx.stroke();
    return true;
  });

  // Bubbles (skip advancement if paused)
  bubbles = bubbles.filter(function(b) {
    if (!paused) b.age+=dt;
    if (b.age>b.life) return false;
    var progress=b.age/b.life;
    var fadeIn=Math.min(b.age/0.15,1);
    var fadeOut=progress>0.7?1-(progress-0.7)/0.3:1;
    var alpha=fadeIn*fadeOut;
    var bx=b.x+Math.sin(b.age*1.5+b.wobble)*3;
    var by=b.y-b.age*b.rise;
    var scale=0.8+fadeIn*0.2;

    var isHovered = false;
    if (hoveredBlock) {
      var hr = hoveredBlock;
      if (b.x >= hr.x - 10 && b.x <= hr.x + hr.w + 10 &&
          b.y >= hr.y - 20 && b.y <= hr.y + hr.h + 20) {
        isHovered = true;
      }
    }
    var boostScale = isHovered ? 1.45 : 1.0;
    var boostAlpha = isHovered ? Math.min(alpha * 1.25, 1) : alpha;

    ctx.save();
    ctx.globalAlpha=boostAlpha;

    var fs2 = Math.max(8, 8*scale*boostScale);
    var subFs = Math.max(6.5, 6.5*scale*boostScale);
    ctx.font='700 '+fs2+'px "JetBrains Mono"';
    var tw = ctx.measureText(b.text).width + 14;
    var subTw = 0;
    if (b.sub) {
      ctx.font='500 '+subFs+'px "JetBrains Mono"';
      subTw = ctx.measureText(b.sub).width + 14;
    }
    var boxW = Math.max(tw, subTw);
    var lineH = fs2 + 3;
    var bh = b.sub ? (lineH + subFs + 7) : (lineH + 4);

    rrect(bx-boxW/2, by-bh/2-1, boxW, bh, 5);
    ctx.fillStyle = isHovered ? b.color + '28' : b.bg; ctx.fill();
    ctx.strokeStyle = isHovered ? b.color + 'cc' : b.color + '70';
    ctx.lineWidth = isHovered ? 1.8 : 1; ctx.stroke();

    if (isHovered) {
      rrect(bx-boxW/2-3, by-bh/2-4, boxW+6, bh+6, 7);
      ctx.strokeStyle = b.color + '30';
      ctx.lineWidth = 4; ctx.stroke();
    }

    if (progress<0.35) {
      ctx.beginPath();
      ctx.moveTo(bx-3, by+bh/2-1);
      ctx.lineTo(bx, by+bh/2+5);
      ctx.lineTo(bx+3, by+bh/2-1);
      ctx.closePath(); ctx.fillStyle = isHovered ? b.color + '28' : b.bg; ctx.fill();
    }

    ctx.font='700 '+fs2+'px "JetBrains Mono"';
    ctx.fillStyle=b.color;
    ctx.textAlign='center';
    var textY = b.sub ? (by - bh/2 + fs2 + 3) : (by + fs2/2 - 1);
    ctx.fillText(b.text, bx, textY);

    if (b.sub) {
      ctx.font='500 '+subFs+'px "JetBrains Mono"';
      ctx.fillStyle = isHovered ? b.color + 'cc' : b.color + '99';
      ctx.fillText(b.sub, bx, textY + subFs + 2);
    }
    ctx.restore();
    return true;
  });

  // Particles (skip advancement if paused)
  if (!paused) {
    particles.forEach(function(p) { p.update(dt); p.draw(ctx); });
    particles = particles.filter(function(p) { return p.alive; });
  } else {
    // Still draw particles frozen in place
    particles.forEach(function(p) { p.draw(ctx); });
  }

  buildParticleLabelRects();

  // Paused indicator is shown in the HTML badge only ‚Äî no canvas overlay needed
}

var lastTime=0;

// Particle ‚Äî supports waypoint routing so particles travel along logical wire paths
// Usage: new Particle(from, to, color, label, speed, onDone)
//   OR:  new Particle(from, to, color, label, speed, onDone, {waypoints:[{x,y}, ...]})
// Waypoints are intermediate stops; particle chains through them automatically.
function Particle(from, to, color, label, speed, onDone, opts) {
  this.color=color; this.label=label||''; this.speed=speed||2; this.alive=true; this.onDone=onDone;
  this.trail=[];
  // Build segment list from waypoints
  var pts = [{x:from.x,y:from.y}];
  if (opts && opts.waypoints) { for (var wi=0;wi<opts.waypoints.length;wi++) pts.push(opts.waypoints[wi]); }
  pts.push({x:to.x,y:to.y});
  this.pts = pts;
  this.segIdx = 0;  // current segment index
  this.segT = 0;    // progress within current segment [0..1]
  // Compute segment lengths for proportional speed
  this.segLens = [];
  this.totalLen = 0;
  for (var si=0;si<pts.length-1;si++) {
    var dx=pts[si+1].x-pts[si].x, dy=pts[si+1].y-pts[si].y;
    var len=Math.sqrt(dx*dx+dy*dy)||1;
    this.segLens.push(len); this.totalLen+=len;
  }
  this.from={x:from.x,y:from.y}; this.to={x:to.x,y:to.y}; // kept for compat
  // passthrough callbacks: {t:0..1, fn:function} ‚Äî fire when particle crosses that fraction of total path
  this.passthroughs = opts && opts.passthroughs ? opts.passthroughs : [];
  this._ptFired = [];
  for (var pi=0;pi<this.passthroughs.length;pi++) this._ptFired.push(false);
  // compute elapsed fraction
  this._frac = 0;
}
Particle.prototype._getPos = function() {
  var pts=this.pts, segIdx=this.segIdx, segT=this.segT;
  if (segIdx>=pts.length-1) return {x:pts[pts.length-1].x,y:pts[pts.length-1].y};
  var a=pts[segIdx], b=pts[segIdx+1];
  return {x:a.x+(b.x-a.x)*segT, y:a.y+(b.y-a.y)*segT};
};
Particle.prototype.update = function(dt) {
  var step = (this.speed*dt*60)/Math.max(this.segLens[this.segIdx]||1,1);
  this.segT += step;
  // Advance through segments
  while (this.segT >= 1 && this.segIdx < this.pts.length-2) {
    this.segT -= 1; this.segIdx++;
    // Recompute step rate for new segment
  }
  if (this.segIdx >= this.pts.length-2 && this.segT >= 1) {
    this.segT=1; this.alive=false; if (this.onDone) this.onDone(); return;
  }
  // Compute overall fraction for passthrough callbacks
  var elapsed=0;
  for (var si=0;si<this.segIdx;si++) elapsed+=this.segLens[si];
  elapsed+=this.segLens[this.segIdx]*this.segT;
  this._frac = elapsed/this.totalLen;
  // Fire passthroughs
  for (var pi=0;pi<this.passthroughs.length;pi++) {
    if (!this._ptFired[pi] && this._frac >= this.passthroughs[pi].t) {
      this._ptFired[pi]=true;
      this.passthroughs[pi].fn();
    }
  }
  var pos=this._getPos();
  this.trail.push({x:pos.x,y:pos.y}); if(this.trail.length>18) this.trail.shift();
};
Particle.prototype.draw = function(ctx) {
  for (var i=0;i<this.trail.length;i++) {
    var p=this.trail[i], a=(1-i/this.trail.length)*0.5, r=2.5-i/this.trail.length*1.5;
    ctx.beginPath(); ctx.arc(p.x,p.y,Math.max(r,.5),0,Math.PI*2);
    ctx.fillStyle=this.color+Math.round(a*255).toString(16).padStart(2,'0'); ctx.fill();
  }
  var pos=this._getPos();
  var cx=pos.x, cy=pos.y;
  ctx.beginPath(); ctx.arc(cx,cy,4,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill();
  ctx.beginPath(); ctx.arc(cx,cy,7,0,Math.PI*2); ctx.fillStyle=this.color+'28'; ctx.fill();
  if (this.label) {
    var hasInfo = !!INSTRUCTION_INFO[this.label];
    var lFont = (hasInfo ? '700' : '500') + ' 9px "JetBrains Mono"';
    ctx.font = lFont;
    var lw = ctx.measureText(this.label).width;
    var lx = cx, ly = cy - 12;
    if (hasInfo) {
      var pw = lw + 10, ph = 13;
      rrect(lx - pw/2, ly - ph + 3, pw, ph, 3);
      ctx.fillStyle = this.color + '28'; ctx.fill();
      ctx.strokeStyle = this.color + '70'; ctx.lineWidth = 0.8; ctx.stroke();
    }
    ctx.font = lFont; ctx.fillStyle = this.color; ctx.textAlign = 'center';
    ctx.fillText(this.label, lx, ly);
  }
};

// Convenience: spawn a particle that routes through waypoints automatically
function spawnParticle(from, to, color, label, speed, onDone, waypoints, passthroughs) {
  var opts = {};
  if (waypoints && waypoints.length) opts.waypoints = waypoints;
  if (passthroughs && passthroughs.length) opts.passthroughs = passthroughs;
  var p = new Particle(from, to, color, label, speed, onDone, opts);
  particles.push(p);
  return p;
}

function l1Pos(i) { var l1=layout.sms[i].l1; return {x:l1.x+l1.w/2,y:l1.y+l1.h/2}; }
function busP(i) { var s=layout.sms[i]; return {x:s.x+s.w/2,y:layout.bus.y}; }
function l2Top() { return {x:layout.l2.x+layout.l2.w/2,y:layout.l2.y}; }
function l2Bot() { return {x:layout.l2.x+layout.l2.w/2,y:layout.l2.y+layout.l2.h}; }
function cbP() { return {x:W/2,y:layout.crossbar.y}; }
function gmTop() { return {x:layout.globalMem.x+layout.globalMem.w/2,y:layout.globalMem.y}; }
function gmBot() { return {x:layout.globalMem.x+layout.globalMem.w/2,y:layout.globalMem.y+layout.globalMem.h}; }
function hbmTop() { return {x:layout.hbm.x+layout.hbm.w/2,y:layout.hbm.y}; }
function flash(b,c) { flashEffects.push({x:b.x,y:b.y,w:b.w,h:b.h,c:c,t:0,dur:.5}); }

function getExplanation(type) {
  var arch = currentArch;
  var e = {
    read:{ title:'L1 Read Miss ‚Üí L2 Fetch', color:'#ff6b6b',
      steps:[
        {text:'<strong>Warp issues load</strong> ‚Äî global memory read.', micro:'LD.E Rx, [addr]', delay:0},
        {text:'<strong>L1 tag lookup: MISS</strong>', micro:'Tag compare ‚Üí miss', delay:700},
        {text:'<strong>Request to L2</strong>', micro:'RdReq ‚Üí Bus ‚Üí L2', delay:1500},
        {text:'<strong>L2 hit</strong> ‚Äî data read from L2.', micro:'L2 '+ARCHS[arch].blocks.l2.size+' slice lookup', delay:2500},
        {text:'<strong>Data returns</strong> ‚Äî cache line fills L1.', micro:'DATA ‚Üí SM L1 fill', delay:3300},
        {text:'<strong>L1 ‚Üí Shared</strong>', micro:'State: Invalid ‚Üí Shared', delay:4000},
      ], summary: arch==='pascal' ? 'Pascal L1 is read-only for globals.' : 'Standard read miss path.'
    },
    write:{ title: arch==='pascal' ? 'SM Write ‚Üí Direct to L2' : 'SM Write ‚Üí Invalidate Others', color:'#51cf66',
      steps: arch==='pascal' ? [
        {text:'<strong>Warp issues store</strong>', micro:'ST.E [addr], Rx', delay:0},
        {text:'<strong>L1 bypassed</strong> ‚Äî write goes directly to L2.', micro:'Write-through: skip L1', delay:500},
        {text:'<strong>L2 absorbs write</strong>', micro:'L2 SRAM write', delay:1200},
        {text:'<strong>No invalidation needed</strong>', micro:'No INV broadcast', delay:1800},
      ] : [
        {text:'<strong>Warp issues store</strong>', micro:'ST.E [addr], Rx', delay:0},
        {text:'<strong>L1 ‚Üí Modified</strong> ‚Äî write-evict policy.', micro:'Write-evict: L1 drop + L2 write', delay:500},
        {text:'<strong>Invalidation broadcast</strong>', micro:'INV ‚Üí all SMs via bus', delay:1200},
        {text:'<strong>Remote L1s invalidated</strong>', micro:'Other SMs: * ‚Üí Invalid', delay:2000},
        {text:'<strong>Coherency restored</strong>', micro:'Single-writer invariant', delay:2800},
      ], summary: arch==='pascal' ? 'Pascal: L1 read-only, writes go to L2.' : 'Write-evict: L1 line dropped, L2 gets the write.'
    },
    invalidate:{ title:'Broadcast Invalidation', color:'#f06595',
      steps:[
        {text:'<strong>Coherency event</strong>', micro:'SM write or host DMA', delay:0},
        {text:'<strong>Bus broadcasts INV</strong>', micro:'INV(addr) ‚Üí all SMs', delay:600},
        {text:'<strong>L1 tags probed</strong>', micro:'Parallel tag lookup', delay:1200},
        {text:'<strong>All copies dropped</strong>', micro:'All: * ‚Üí Invalid', delay:2200},
      ], summary:'Broadcast invalidation scales linearly with SM count.'
    },
    writeback:{ title:'Write-Back ‚Üí L2 ‚Üí '+ARCHS[currentArch].blocks.hbm.label, color:'#ffa94d',
      steps:[
        {text:'<strong>L1 eviction</strong> ‚Äî dirty line needs to leave L1.', micro:'Capacity eviction or flush', delay:0},
        {text:'<strong>Data ‚Üí L2</strong>', micro:'WB+DATA ‚Üí L2 slice', delay:800},
        {text:'<strong>L2 absorbs</strong>', micro:'L2 write', delay:1800},
        {text:'<strong>L2 eviction</strong> ‚Äî if full, victim evicted to DRAM.', micro:'LRU victim ‚Üí NoC ‚Üí MC', delay:3000},
        {text:'<strong>'+ARCHS[arch].blocks.hbm.label+' write</strong>', micro:'MC ‚Üí bank write', delay:4000},
        {text:'<strong>Stored in '+ARCHS[arch].blocks.hbm.label+'</strong>', micro:'~400+ cycles total', delay:4800},
      ], summary:'Full eviction cascade: L1‚ÜíL2‚ÜíMC‚ÜíDRAM.'
    },
    shared:{ title: currentArch==='hopper' ? 'Shared Mem + DSMEM' : 'Shared Memory Access', color:'#51cf66',
      steps: currentArch==='hopper' ? [
        {text:'<strong>Thread accesses __shared__</strong>', micro:'LDS Rx, [smem_addr]', delay:0},
        {text:'<strong>Direct SRAM access</strong> ‚Äî no coherency. 32 banks.', micro:'~20 cycles', delay:500},
        {text:'<strong>DSMEM option</strong> ‚Äî access other SMs\' shared memory.', micro:'dst_sm.smem[addr]', delay:1200},
        {text:'<strong>Cluster-local</strong> ‚Äî DSMEM at SMEM latency.', micro:'~20 cycles cross-SM', delay:1800},
      ] : [
        {text:'<strong>Thread accesses __shared__</strong>', micro:'LDS Rx, [smem_addr]', delay:0},
        {text:'<strong>Direct SRAM access</strong> ‚Äî no coherency.', micro:'~20 cycles, 32 banks', delay:500},
        {text:'<strong>Bank conflict check</strong>', micro:'Best: 1 cycle. Worst: 32-way', delay:1100},
        {text:'<strong>SM-local only</strong> ‚Äî no bus traffic.', micro:'Scope: CTA local', delay:1600},
      ], summary: currentArch==='hopper' ? 'DSMEM enables cross-SM shared memory within a cluster.' : 'Shared memory sidesteps coherency by being SM-private.'
    },
    atomic:{ title: currentArch==='apex' ? '‚öõ atomicAdd ‚Üí Apex Arbiter (SEQ# + ROB)' : '‚öõ atomicAdd ‚Üí Raw L2 Serialization', color:'#f59e0b',
      steps: currentArch==='apex' ? [
        {text:'<strong>All SMs issue atomicAdd</strong> simultaneously', micro:'ATOM ‚Üí coherency bus', delay:0},
        {text:'<strong>ATOM packets hit the Arbiter</strong> ‚Äî each gets a SEQ#', micro:'Arbiter: seq++ per request', delay:500},
        {text:'<strong>Arbiter queues requests</strong> ‚Äî up to 6 deep', micro:'Round-robin grant policy', delay:1100},
        {text:'<strong>GRANT fires</strong> to front-of-queue SM', micro:'GRANT ‚Üí SM: exclusive access', delay:1800},
        {text:'<strong>SM does read-modify-write</strong> on L2', micro:'ATOM ‚Üí L2 RMW ‚Üí ACK', delay:2600},
        {text:'<strong>ACK returns ‚Üí ROB retires</strong> in SEQ order', micro:'ROB: #N retired ‚Üí next SM', delay:3400},
        {text:'<strong>DATA sent back</strong> to originating SM', micro:'DATA#N ‚Üí SM L1', delay:4200},
      ] : [
        {text:'<strong>All SMs issue atomicAdd</strong> simultaneously', micro:'ATOM ‚Üí bus (no coordination)', delay:0},
        {text:'<strong>All ATOM packets race for L2</strong>', micro:'L2 serializes them internally', delay:600},
        {text:'<strong>L2 locks the cache line</strong> for each ATOM', micro:'One SM at a time ‚Äî slow', delay:1400},
        {text:'<strong>DATA returns</strong> to each SM in turn', micro:'No ROB ‚Äî order not guaranteed', delay:2400},
        {text:'<strong>On Apex</strong>: an explicit Arbiter would handle this cleanly', micro:'SEQ# + ROB = ordered, visible', delay:3200},
      ],
      summary: currentArch==='apex'
        ? 'Arbiter: SEQ# tags enable ROB ordering. Contention meter shows cost of serialization.'
        : 'Without an arbiter, atomics serialize hidden inside L2 ‚Äî no visibility, high latency. Switch to Apex to see the full arbiter system.'
    }
  };
  return e[type];
}

function showExplanation(type) {
  var exp = getExplanation(type); if (!exp) return;
  stepTimers.forEach(function(t){clearTimeout(t);}); stepTimers=[];
  var titleEl=document.getElementById('explainer-title');
  titleEl.innerHTML='<span class="dot" style="background:'+exp.color+'"></span> '+exp.title;
  titleEl.style.color=exp.color;
  var listEl=document.getElementById('step-list'); listEl.innerHTML='';
  var sumEl=document.getElementById('explainer-summary'); sumEl.textContent=''; sumEl.classList.remove('visible');
  exp.steps.forEach(function(s,i) {
    var li=document.createElement('li');
    var microText = s.micro;
    var microHtml = microText.replace(/\b(LD\.E|ST\.E|LDS|STS|ST\.S|RdReq|INV|DATA|WR|WB|EVICT|STORE|DSMEM|cp\.async)\b/g, function(m) {
      return '<span class="micro-instr" data-instr="'+m+'" style="cursor:help;text-decoration:underline dotted;text-decoration-color:rgba(255,255,255,0.3)">'+m+'</span>';
    });
    li.innerHTML='<span class="step-num" style="background:'+exp.color+'20;color:'+exp.color+'">'+(i+1)+'</span><span class="step-text">'+s.text+'<span class="micro">'+microHtml+'</span></span>';
    listEl.appendChild(li);
    stepTimers.push(setTimeout(function() {
      var actives=listEl.querySelectorAll('li.active');
      for(var k=0;k<actives.length;k++){actives[k].classList.remove('active');actives[k].classList.add('past');}
      li.classList.add('visible','active');
    }, s.delay));
  });
  stepTimers.push(setTimeout(function() {
    sumEl.textContent=exp.summary; sumEl.classList.add('visible');
    var actives=listEl.querySelectorAll('li.active');
    for(var k=0;k<actives.length;k++){actives[k].classList.remove('active');actives[k].classList.add('past');}
  }, exp.steps[exp.steps.length-1].delay+1000));
}

function logEvent(msg, color) {
  var log=document.getElementById('event-log');
  var e=document.createElement('div'); e.className='log-entry';
  e.innerHTML='<span class="tag" style="background:'+color+'30;color:'+color+'">'+new Date().toLocaleTimeString().slice(0,8)+'</span> '+msg;
  log.prepend(e); if(log.children.length>40) log.lastChild.remove();
}

function updateStats() {
  document.getElementById('stat-hits').textContent=stats.hits;
  document.getElementById('stat-misses').textContent=stats.misses;
  document.getElementById('stat-inv').textContent=stats.inv;
  document.getElementById('stat-wb').textContent=stats.wb;
}

function triggerScenario(type) {
  // If paused, unpause first so the animation plays
  if (paused) {
    togglePause();
  }

  var si=Math.floor(Math.random()*layout.sms.length);
  showExplanation(type);
  var sm=layout.sms[si];

  switch(type) {
    case 'read':
      sm.l1.state='invalid'; invalidateL1(si); stats.misses++;
      logEvent('SM'+si+': L1 read miss ‚Üí L2','#ff6b6b');
      bubble(l1Pos(si).x,l1Pos(si).y,'cache miss','#ff6b6b',{sub:'not in L1'});
      particles.push(new Particle(l1Pos(si),busP(si),'#ff6b6b','RdReq',2,function(){
        bubble(busP(si).x,busP(si).y,'going to L2','#ff6b6b',{life:1.4,sub:'fetch from below'});
        spawnPassthrough(si,'#ff6b6b','RdReq',2.5,function(){
          stats.hits++; logEvent('L2: Hit ‚Üí data returning','#ffa94d');
          bubble(l2Top().x,l2Top().y,'L2 found it','#51cf66',{life:1.5,sub:'data ready'});
          particles.push(new Particle(l2Top(),busP(si),'#ffa94d','DATA',2,function(){
            particles.push(new Particle(busP(si),l1Pos(si),'#ffa94d','DATA',2,function(){
              sm.l1.state='shared'; fillL1Random(si, false); flash(sm.l1,'#339af0');
              bubble(l1Pos(si).x,l1Pos(si).y,'line cached','#339af0',{life:1.6,sub:'now Shared'});
              logEvent('SM'+si+': L1 ‚Üí Shared','#339af0');
            }));
          }));
        });
      }));
      break;
    case 'write':
      if (currentArch==='pascal') {
        logEvent('SM'+si+': Write ‚Üí L2 (L1 bypassed)','#51cf66');
        stats.hits++;
        bubble(l1Pos(si).x,l1Pos(si).y,'write bypass','#51cf66',{sub:'L1 skipped'});
        particles.push(new Particle(l1Pos(si),busP(si),'#51cf66','WR',2,function(){
          bubble(busP(si).x,busP(si).y,'skip L1','#8890a8',{life:1.2,sub:'straight to L2'});
          spawnPassthrough(si,'#51cf66','WR',2.5,function(){
            flash(layout.l2,'#ffa94d');
            bubble(l2Top().x,l2Top().y,'L2 updated','#ffa94d',{life:1.5,sub:'write absorbed'});
            logEvent('L2: Write absorbed','#ffa94d');
          });
        }));
      } else {
        sm.l1.state='modified'; setL1Dirty(si); stats.hits++;
        logEvent('SM'+si+': Write ‚Üí Modified + invalidate','#51cf66');
        flash(sm.l1,'#51cf66');
        bubble(l1Pos(si).x,l1Pos(si).y,'line dirty','#51cf66',{sub:'now Modified'});
        for (var wi=0;wi<layout.sms.length;wi++) {
          if (wi!==si && layout.sms[wi].l1.state!=='invalid') {
            (function(idx){
              setTimeout(function(){
                particles.push(new Particle(busP(si),busP(idx),'#f06595','INV',3,function(){
                  layout.sms[idx].l1.state='invalid'; invalidateL1(idx); stats.inv++;
                  flash(layout.sms[idx].l1,'#f06595');
                  bubble(l1Pos(idx).x,l1Pos(idx).y,'copy stale','#f06595',{life:1.3,sub:'lines cleared'});
                  logEvent('SM'+idx+': Invalidated','#f06595');
                  updateStats();
                }));
              }, idx*150);
            })(wi);
          }
        }
      }
      break;
    case 'invalidate':
      stats.inv++;
      logEvent('Broadcast INV','#f06595');
      bubble((layout.bus.x1+layout.bus.x2)/2,layout.bus.y,'broadcast flush','#f06595',{sub:'all SMs notified'});
      for (var ii=0;ii<layout.sms.length;ii++) {
        (function(idx){
          setTimeout(function(){
            var from={x:(layout.bus.x1+layout.bus.x2)/2,y:layout.bus.y};
            particles.push(new Particle(from,busP(idx),'#f06595','INV',3,function(){
              particles.push(new Particle(busP(idx),l1Pos(idx),'#f06595','INV',2,function(){
                layout.sms[idx].l1.state='invalid'; invalidateL1(idx);
                flash(layout.sms[idx].l1,'#f06595');
                bubble(l1Pos(idx).x,l1Pos(idx).y,'all cleared','#f06595',{life:1.2,sub:'lines dropped'});
              }));
            }));
          }, idx*180);
        })(ii);
      }
      break;
    case 'writeback':
      sm.l1.state='modified'; setL1Dirty(si); stats.wb++;
      logEvent('SM'+si+': Write-back ‚Üí L2','#ffa94d');
      bubble(l1Pos(si).x,l1Pos(si).y,'dirty evict','#ffa94d',{sub:'must flush out'});
      particles.push(new Particle(l1Pos(si),busP(si),'#ffa94d','WB',2,function(){
        spawnPassthrough(si,'#ffa94d','WB',2.5,function(){
          flash(layout.l2,'#ffa94d'); sm.l1.state='shared'; writebackL1(si);
          bubble(l2Top().x,l2Top().y,'L2 absorbed','#ffa94d',{life:1.4,sub:'dirty ‚Üí L2'});
          logEvent('L2: Write-back received','#ffa94d');
          setTimeout(function(){
            bubble(l2Bot().x,l2Bot().y,'L2 evicting','#339af0',{life:1.3,sub:'victim to DRAM'});
            particles.push(new Particle(l2Bot(),cbP(),'#339af0','EVICT',2,function(){
              particles.push(new Particle(cbP(),gmTop(),'#339af0','WR',2,function(){
                flash(layout.globalMem,'#339af0');
                bubble(gmTop().x,gmTop().y,'queued MC','#339af0',{life:1.2,sub:'scheduling write'});
                particles.push(new Particle(gmBot(),hbmTop(),'#845ef7','STORE',1.5,function(){
                  flash(layout.hbm,'#845ef7');
                  bubble(hbmTop().x,hbmTop().y,'persisted','#845ef7',{life:1.5,sub:'written to DRAM'});
                  logEvent(ARCHS[currentArch].blocks.hbm.label+': Stored','#845ef7');
                }));
              }));
            }));
          },500);
        });
      }));
      break;
    case 'shared':
      var smemBlock=null;
      for(var sbi=0;sbi<sm.sub.length;sbi++){if(sm.sub[sbi].type==='smem')smemBlock=sm.sub[sbi];}
      if(!smemBlock) break;
      logEvent('SM'+si+': SMEM access','#51cf66');
      flash(smemBlock,'#51cf66'); stats.hits++;
      fillSmem(si);
      bubble(sm.x+sm.w/2,sm.y+14,'no coherency','#51cf66',{sub:'SM-private scratchpad'});
      var regsBlock=null;
      for(var ri=0;ri<sm.sub.length;ri++){if(sm.sub[ri].type==='regs')regsBlock=sm.sub[ri];}
      var sfrom={x:sm.x+sm.w/2,y:regsBlock?regsBlock.y+3:sm.y+40};
      particles.push(new Particle(sfrom,{x:smemBlock.x+smemBlock.w/2,y:smemBlock.y+smemBlock.h/2},'#51cf66','ST.S',1.5,function(){
        bubble(smemBlock.x+smemBlock.w/2,smemBlock.y,'~20 cycles','#51cf66',{life:1.4,sub:'fast SRAM hit'});
      }));
      if (currentArch==='hopper'&&layout.sms.length>1) {
        var other=(si+1)%layout.sms.length;
        var otherDsmem=null, myDsmem=null;
        for(var od=0;od<layout.sms[other].sub.length;od++){if(layout.sms[other].sub[od].type==='dsmem')otherDsmem=layout.sms[other].sub[od];}
        for(var md=0;md<sm.sub.length;md++){if(sm.sub[md].type==='dsmem')myDsmem=sm.sub[md];}
        if(otherDsmem&&myDsmem){
          setTimeout(function(){
            logEvent('SM'+si+' ‚Üí SM'+other+': DSMEM read','#22d3ee');
            bubble(myDsmem.x+myDsmem.w/2,myDsmem.y,'peer read','#22d3ee',{sub:'cross-SM memory'});
            particles.push(new Particle(
              {x:myDsmem.x+myDsmem.w/2,y:myDsmem.y+myDsmem.h/2},
              {x:otherDsmem.x+otherDsmem.w/2,y:otherDsmem.y+otherDsmem.h/2},
              '#22d3ee','DSMEM',2,function(){
                flash(otherDsmem,'#22d3ee');
                bubble(otherDsmem.x+otherDsmem.w/2,otherDsmem.y,'cluster hit','#22d3ee',{life:1.4,sub:'no bus needed'});
              }
            ));
          },800);
        }
      }
      break;
    case 'atomic':
      triggerAtomic();
      return;
  }
  updateStats();
}

function toggleAuto() {
  autoMode=!autoMode;
  document.getElementById('btn-auto').classList.toggle('active',autoMode);
}

function resetAll(silent) {
  particles=[]; flashEffects=[]; bubbles=[];
  stats={hits:0,misses:0,inv:0,wb:0}; updateStats();
  for(var ri=0;ri<layout.sms.length;ri++){layout.sms[ri].l1.state='invalid';}
  initCacheState();
  document.getElementById('event-log').innerHTML='';
  stepTimers.forEach(function(t){clearTimeout(t);}); stepTimers=[];
  document.getElementById('explainer-title').innerHTML='<span class="dot" style="background:#6b7094"></span> Click a scenario or wait for auto...';
  document.getElementById('explainer-title').style.color='#6b7094';
  document.getElementById('step-list').innerHTML='';
  var s=document.getElementById('explainer-summary'); s.textContent=''; s.classList.remove('visible');
  autoTimer=0;
  // Also unpause on reset
  if (paused) togglePause();
  resetArbiter();
  if(!silent) logEvent('Reset ‚Äî all caches invalidated','#6b7094');
}

function buildInstrChips() {
  var container = document.getElementById('instr-chips');
  if (!container) return;
  container.innerHTML = '';
  var keys = Object.keys(INSTRUCTION_INFO);
  keys.forEach(function(key) {
    var info = INSTRUCTION_INFO[key];
    var chip = document.createElement('span');
    chip.className = 'instr-chip';
    chip.textContent = key;
    chip.style.background = info.color + '18';
    chip.style.color = info.color;
    chip.style.borderColor = info.color + '50';
    chip.addEventListener('mouseenter', function(e) {
      showInstrTooltip(key, e.clientX, e.clientY);
    });
    chip.addEventListener('mousemove', function(e) {
      positionInstrTooltip(e.clientX, e.clientY);
    });
    chip.addEventListener('mouseleave', function() {
      hideInstrTooltip();
    });
    container.appendChild(chip);
  });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// APEX ARBITER STATE SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
var arbiterState = {
  seqCounter: 0,
  queue: [],       // pending requests waiting for grant (arrival order = grant order)
  rob: [],         // reorder buffer: [{seq, smIdx, state:'pending'|'complete'|'retiring'|'done'}]
  activeOps: [],   // [{seq, smIdx, phase, phaseName, phaseStart}] ‚Äî live phase tracking
  grantCount: 0,
  contentionLevel: 0,
  recentGrants: [],
  active: false,
};


function resetArbiter() {
  arbiterState.seqCounter = 0;
  arbiterState.queue = [];
  arbiterState.rob = [];
  arbiterState.activeOps = [];
  arbiterState.grantCount = 0;
  arbiterState.contentionLevel = 0;
  arbiterState.recentGrants = [];
  arbiterState.active = false;
  updateArbiterDom();
}

function arbiterEnqueue(smIdx, type) {
  if (currentArch !== 'apex') return -1;
  var seq = arbiterState.seqCounter++;
  // Queue: FIFO ‚Äî grant order matches arrival order
  arbiterState.queue.push({ seq: seq, smIdx: smIdx, type: type || 'ATOM' });
  // ROB: one slot per in-flight op, state starts 'pending' until ACK returns from L2
  arbiterState.rob.push({ seq: seq, smIdx: smIdx, state: 'pending' });
  arbiterState.activeOps.push({ seq: seq, smIdx: smIdx, phase: 'queued', phaseName: ARB_PHASES.queued.label, phaseStart: Date.now() });
  arbiterState.contentionLevel = Math.min(1, arbiterState.queue.length / 6);
  arbiterState.active = true;
  updateArbiterDom();
  return seq;
}

function arbiterGrant(seq) {
  if (currentArch !== 'apex') return;
  // Remove from queue ‚Äî grant issued, SM can now do RMW
  var qEntry = null;
  for (var qi = 0; qi < arbiterState.queue.length; qi++) {
    if (arbiterState.queue[qi].seq === seq) { qEntry = arbiterState.queue[qi]; break; }
  }
  arbiterState.queue = arbiterState.queue.filter(function(e){ return e.seq !== seq; });
  // ROB slot stays 'pending' ‚Äî it only moves to 'complete' when ACK returns from L2
  // (do NOT mark 'returning' here ‚Äî that was wrong)
  for (var ao = 0; ao < arbiterState.activeOps.length; ao++) {
    if (arbiterState.activeOps[ao].seq === seq) {
      arbiterState.activeOps[ao].phase = 'granted';
      arbiterState.activeOps[ao].phaseName = ARB_PHASES.granted.label;
      arbiterState.activeOps[ao].phaseStart = Date.now();
      break;
    }
  }
  arbiterState.grantCount++;
  arbiterState.contentionLevel = Math.min(1, arbiterState.queue.length / 6);
  var cycles = Math.round(2 + arbiterState.queue.length * 8 + Math.random() * 6);
  arbiterState.recentGrants.unshift({ seq: seq, cycles: cycles });
  if (arbiterState.recentGrants.length > 4) arbiterState.recentGrants.pop();
  updateArbiterDom();
}

// Called when ACK physically arrives back from L2 for a given SEQ#
// Marks ROB slot 'complete' but does NOT send DATA yet ‚Äî that waits for in-order retirement
// Returns a callback that the caller should invoke to actually send DATA when retirement is allowed
function arbiterAckFromL2(seq, onRetired) {
  if (currentArch !== 'apex') { if (onRetired) onRetired(); return; }
  // Mark ROB slot as complete (ACK received, result in hand)
  for (var ri = 0; ri < arbiterState.rob.length; ri++) {
    if (arbiterState.rob[ri].seq === seq) {
      arbiterState.rob[ri].state = 'complete';
      arbiterState.rob[ri].onRetired = onRetired;
      break;
    }
  }
  // Phase: ack ‚Üí retiring (waiting for head-of-line)
  for (var ao = 0; ao < arbiterState.activeOps.length; ao++) {
    if (arbiterState.activeOps[ao].seq === seq) {
      arbiterState.activeOps[ao].phase = 'retiring';
      arbiterState.activeOps[ao].phaseName = ARB_PHASES.retiring.label;
      arbiterState.activeOps[ao].phaseStart = Date.now();
      break;
    }
  }
  updateArbiterDom();
  // Try to drain ROB from the head ‚Äî retire any contiguous run of 'complete' entries
  arbiterTryRetire();
}

// Drain ROB head: retire all consecutive 'complete' entries in SEQ order
// This is the actual reordering ‚Äî if #3 finishes before #2, it waits here
function arbiterTryRetire() {
  var changed = true;
  while (changed) {
    changed = false;
    if (arbiterState.rob.length === 0) break;
    var head = arbiterState.rob[0];
    // Skip entries already done (being cleaned up by setTimeout ‚Äî not yet filtered out)
    if (head.state === 'done') {
      // Can't retire next until this is removed ‚Äî re-check after cleanup delay
      setTimeout(arbiterTryRetire, 650);
      break;
    }
    if (head.state === 'complete') {
      head.state = 'done';
      updateArbiterDom();
      var cb = head.onRetired;
      (function(entry) {
        setTimeout(function() {
          arbiterState.rob = arbiterState.rob.filter(function(e){ return e.seq !== entry.seq; });
          arbiterState.activeOps = arbiterState.activeOps.filter(function(e){ return e.seq !== entry.seq; });
          if (arbiterState.queue.length === 0 && arbiterState.rob.length === 0) {
            arbiterState.active = false;
            arbiterState.contentionLevel = 0;
          }
          updateArbiterDom();
          // Re-run retire loop now that this 'done' entry is gone ‚Äî unblocks waiting entries
          arbiterTryRetire();
        }, 600);
      })(head);
      if (cb) cb();
      changed = true;
    }
    // 'pending' = ACK not back yet ‚Äî stop, arbiterAckFromL2 will call us again when ready
  }
}

// Legacy wrapper kept for any remaining call sites
function arbiterRetire(seq) {
  // No-op ‚Äî retirement now handled by arbiterAckFromL2 + arbiterTryRetire
}

function updateArbiterDom() {
  // State-only update ‚Äî rendering is done entirely on canvas
  // Nothing to update in DOM since we removed the arbiter panel
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LATENCY ANNOTATION TOASTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// APEX HELPERS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function arbiterPos() {
  if (!layout.arbiter) return l2Top();
  return { x: layout.arbiter.x + layout.arbiter.w/2, y: layout.arbiter.y + layout.arbiter.h/2 };
}
function arbiterBot() {
  if (!layout.arbiter) return l2Top();
  return { x: layout.arbiter.x + layout.arbiter.w/2, y: layout.arbiter.y + layout.arbiter.h };
}
function arbiterTop() {
  if (!layout.arbiter) return l2Top();
  return { x: layout.arbiter.x + layout.arbiter.w/2, y: layout.arbiter.y };
}
// Point on the coherency bus directly above arbiter centre ‚Äî waypoint for routed particles
function arbiterBusEntry() {
  if (!layout.arbiter || !layout.bus) return arbiterTop();
  return { x: layout.arbiter.x + layout.arbiter.w/2, y: layout.bus.y };
}
// Route a particle through the bus correctly:
// from l1 ‚Üí busP(smIdx) ‚Üí arbiterBusEntry ‚Üí arbiterTop (two right-angle turns, no diagonals)
function spawnRoutedToArbiter(smIdx, color, label, speed, onArrival) {
  var fromPos  = l1Pos(smIdx);
  var busJunct = busP(smIdx);
  var busAbove = arbiterBusEntry();
  var dest     = arbiterTop();
  // leg 1: L1 ‚Üí bus junction (vertical up)
  particles.push(new Particle(fromPos, busJunct, color, label, speed, function() {
    // leg 2: bus junction ‚Üí arbiter bus entry (horizontal along bus)
    particles.push(new Particle(busJunct, busAbove, color, label, speed * 1.1, function() {
      // leg 3: bus entry ‚Üí arbiter top (vertical down)
      particles.push(new Particle(busAbove, dest, color, label, speed, function() {
        if (onArrival) onArrival();
      }));
    }));
  }));
}
// Route a GRANT signal from arbiter back to SM ‚Äî stops at bus junction (warp scheduler receives it)
// GRANT is a control signal, not data ‚Äî it doesn't go into L1
function spawnGrantToSM(smIdx, onArrival) {
  var fromPos  = arbiterTop();
  var busAbove = arbiterBusEntry();
  var busJunct = busP(smIdx);
  particles.push(new Particle(fromPos, busAbove, '#51cf66', 'GRANT', 2.8, function() {
    particles.push(new Particle(busAbove, busJunct, '#51cf66', 'GRANT', 3.0, function() {
      if (onArrival) onArrival();
    }));
  }));
}
// Route from arbiter back to SM via bus (DATA goes all the way to L1)
function spawnRoutedFromArbiter(smIdx, color, label, speed, onArrival) {
  var fromPos  = arbiterTop();
  var busAbove = arbiterBusEntry();
  var busJunct = busP(smIdx);
  var dest     = l1Pos(smIdx);
  particles.push(new Particle(fromPos, busAbove, color, label, speed, function() {
    particles.push(new Particle(busAbove, busJunct, color, label, speed * 1.1, function() {
      particles.push(new Particle(busJunct, dest, color, label, speed, function() {
        if (onArrival) onArrival();
      }));
    }));
  }));
}
// Passthrough: flash arbiter briefly when a non-atomic op crosses it on Apex
// Shows a dim pulse and a small label ‚Äî particles routed through it as a waypoint
function spawnPassthrough(smIdx, color, label, speed, onArrival) {
  if (currentArch !== 'apex' || !layout.arbiter) {
    // Non-Apex: go straight bus ‚Üí L2 as before
    particles.push(new Particle(busP(smIdx), l2Top(), color, label, speed, onArrival));
    return;
  }
  var busJunct  = busP(smIdx);
  var busAbove  = arbiterBusEntry();
  var arbEntry  = arbiterTop();
  var arbExit   = arbiterBot();
  var l2dest    = l2Top();
  // leg 1: bus junction ‚Üí bus-above-arbiter (horizontal)
  particles.push(new Particle(busJunct, busAbove, color, label, speed * 1.1, function() {
    // leg 2: bus above ‚Üí arbiter top (enter arbiter ‚Äî vertical down)
    particles.push(new Particle(busAbove, arbEntry, color, label, speed, function() {
      // Passthrough pulse on arbiter
      flashEffects.push({ x:layout.arbiter.x, y:layout.arbiter.y, w:layout.arbiter.w, h:layout.arbiter.h,
        c: color, t:0, dur:0.35 });
      // leg 3: arbiter top ‚Üí arbiter bottom (pass through ‚Äî very short, vertical)
      particles.push(new Particle(arbEntry, arbExit, color, 'PASS', speed * 1.5, function() {
        // leg 4: arbiter bottom ‚Üí L2 top (exit to L2)
        particles.push(new Particle(arbExit, l2dest, color, label, speed, function() {
          if (onArrival) onArrival();
        }));
      }));
    }));
  }));
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ATOMIC SCENARIO
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function triggerAtomic() {
  if (paused) togglePause();
  var smCount2 = layout.sms.length;
  var isApex = currentArch === 'apex';
  showExplanation('atomic');

  if (isApex) {
    logEvent('atomicAdd: ' + smCount2 + ' SMs ‚Üí Arbiter', '#f59e0b');
    bubble((layout.bus.x1+layout.bus.x2)/2, layout.bus.y-12, 'atomic storm', '#f59e0b', { sub: smCount2+' reqs inbound', life:2.0 });

    // Reset arbiter for a clean scenario each time atomicAdd is triggered
    resetArbiter();

    // Track which SEQs have been enqueued so grants fire only after real enqueue
    // enqueuedSeqs[seq] = smIdx, filled as particles physically arrive
    var enqueuedSeqs = {};
    var enqueuedCount = 0;
    var grantQueue = []; // pending grant requests waiting for enqueue
    // grantInFlight: true while a grant's RMW is traversing the arbiter block (legs 1-3).
    // Enforces arbiter serialization ‚Äî only one RMW may be inside the arbiter at a time.
    var grantInFlight = false;

    // Try to process the next pending grant ‚Äî called on enqueue or when previous leg3 completes
    function tryNextGrant() {
      if (grantInFlight) return;           // previous RMW still in arbiter block, wait
      if (grantQueue.length === 0) return;
      var next = grantQueue[0];
      if (enqueuedSeqs[next.seq] === undefined) return; // not yet arrived at arbiter, wait
      grantInFlight = true;
      grantQueue.shift();
      issueGrant(next.seq, next.smIdx, next.onGrantComplete);
    }

    function issueGrant(seq, smIdx, onGrantComplete) {
      arbiterGrant(seq);
      logEvent('ARBITER: GRANT SEQ#'+seq+' ‚Üí SM'+smIdx, '#51cf66');
      if (bubbles.length <= 6)
        bubble(layout.arbiter.x + layout.arbiter.w * 0.78, arbiterPos().y - 10,
          'GRANT#'+seq, '#51cf66', { sub:'SM'+smIdx, life:1.0 });

      spawnGrantToSM(smIdx, function() {
        (function(capturedSeq, capturedIdx) {
          for (var pa = 0; pa < arbiterState.activeOps.length; pa++) {
            if (arbiterState.activeOps[pa].seq === capturedSeq) {
              arbiterState.activeOps[pa].phase = 'rmw';
              arbiterState.activeOps[pa].phaseName = ARB_PHASES.rmw.label;
              arbiterState.activeOps[pa].phaseStart = Date.now();
              break;
            }
          }
          var smBusJunct = busP(capturedIdx);
          var busAbove   = arbiterBusEntry();
          var arbEntry   = arbiterTop();
          var arbExit    = arbiterBot();
          var l2dest     = l2Top();
          particles.push(new Particle(smBusJunct, busAbove, '#f59e0b', 'RMW', 2.5, function() {
            particles.push(new Particle(busAbove, arbEntry, '#f59e0b', 'RMW', 2.2, function() {
              particles.push(new Particle(arbEntry, arbExit, '#f59e0b', 'ATOM', 2.0, function() {
                grantInFlight = false;                  // RMW through arbiter, next grant can proceed
                if (onGrantComplete) onGrantComplete();
                particles.push(new Particle(arbExit, l2dest, '#f59e0b', 'ATOM', 2.0, function() {
                  flash(layout.l2, '#f59e0b');
                  logEvent('L2: RMW SEQ#'+capturedSeq+' complete', '#ffa94d');
                  for (var pb = 0; pb < arbiterState.activeOps.length; pb++) {
                    if (arbiterState.activeOps[pb].seq === capturedSeq) {
                      arbiterState.activeOps[pb].phase = 'ack';
                      arbiterState.activeOps[pb].phaseName = ARB_PHASES.ack.label;
                      arbiterState.activeOps[pb].phaseStart = Date.now();
                      break;
                    }
                  }
                  // L2 jitter: random extra latency models different bank response times
                  // This causes ACKs to return out of order ‚Üí ROB reordering is visible
                  var l2Jitter = Math.random() * 500;
                  setTimeout(function() {
                    particles.push(new Particle(l2Top(), arbExit, '#ffa94d', 'ACK#'+capturedSeq, 2.0, function() {
                      flash(layout.arbiter, '#ffa94d');
                      if (bubbles.length <= 6)
                        bubble(arbiterPos().x, layout.arbiter.y + layout.arbiter.h + 8,
                          'ACK#'+capturedSeq, '#ffa94d', { sub:'‚Üí ROB', life:0.9 });
                      arbiterAckFromL2(capturedSeq, function() {
                        logEvent('ROB: SEQ#'+capturedSeq+' retired ‚Üí DATA‚ÜíSM'+capturedIdx, '#a78bfa');
                        if (bubbles.length <= 5)
                          bubble(layout.arbiter.x + layout.arbiter.w * 0.5,
                            layout.arbiter.y + layout.arbiter.h + 8,
                            'SEQ#'+capturedSeq+' retired', '#a78bfa', { sub:'in order', life:1.0 });
                        spawnRoutedFromArbiter(capturedIdx, '#ffa94d', 'DATA', 2.2, function() {
                          layout.sms[capturedIdx].l1.state = 'modified';
                          setL1Dirty(capturedIdx);
                          flash(layout.sms[capturedIdx].l1, '#f59e0b');
                          stats.hits++; updateStats();
                        });
                      });
                    }));
                  }, l2Jitter);
                }));
              }));
            }));
          }));
        })(seq, smIdx);
      });
    }

    // Phase 1: all SMs send ATOM, enqueue on arrival, queue grants in FIFO order
    for (var ai = 0; ai < smCount2; ai++) {
      (function(idx) {
        setTimeout(function() {
          stats.misses++;
          if (bubbles.length > 6) bubbles.splice(0, bubbles.length - 6);
          bubble(l1Pos(idx).x, l1Pos(idx).y, 'atomicAdd', '#f59e0b', { sub:'‚Üí bus', life:1.0 });
          spawnRoutedToArbiter(idx, '#f59e0b', 'ATOM', 2.5, function() {
            var seq = arbiterEnqueue(idx, 'ATOM');
            enqueuedSeqs[seq] = idx;
            enqueuedCount++;
            logEvent('SM'+idx+': ATOM arrived ‚Üí SEQ#'+seq, '#f59e0b');
            flash(layout.arbiter, '#f59e0b');
            if (bubbles.length <= 6)
              bubble(layout.arbiter.x + layout.arbiter.w * 0.22, arbiterPos().y - 8,
                'SEQ#'+seq, '#f59e0b', { sub:'queued', life:0.9 });

            // Queue a grant for this SEQ in FIFO order ‚Äî will fire once enqueued
            // The grant for SEQ N fires only after SEQ N-1's RMW has entered the arbiter
            // (onGrantComplete callback chains to next grant)
            var grantEntry = { seq: seq, smIdx: idx, onGrantComplete: null };
            // Wire up chain: this grant's onComplete triggers next grant attempt
            grantEntry.onGrantComplete = function() {
              tryNextGrant();
            };
            grantQueue.push(grantEntry);

            // If this is the first enqueue, or all previous were already enqueued, try now
            if (grantQueue[0] && grantQueue[0].seq === seq) {
              tryNextGrant();
            }
          });
        }, idx * 220);
      })(ai);
    }
  } else {
    // Non-Apex: raw bus contention, no arbiter coordination
    logEvent('atomicAdd: raw bus contention (no arbiter)', '#f59e0b');
    bubble((layout.bus.x1+layout.bus.x2)/2, layout.bus.y, 'no arbiter!', '#ff6b6b', { sub:'serialized at L2 (slow)', life:2.2 });
    for (var ri = 0; ri < smCount2; ri++) {
      (function(idx2) {
        setTimeout(function() {
          stats.misses++;
          bubble(l1Pos(idx2).x, l1Pos(idx2).y, 'atomicAdd', '#f59e0b', { sub:'racing for bus', life:1.4 });
          particles.push(new Particle(l1Pos(idx2), busP(idx2), '#f59e0b', 'ATOM', 2.5, function() {
            particles.push(new Particle(busP(idx2), l2Top(), '#f59e0b', 'ATOM', 2.5, function() {
              flash(layout.l2, '#f59e0b');
              logEvent('L2: atomic locked (SM'+idx2+')', '#ffa94d');
              setTimeout(function() {
                particles.push(new Particle(l2Top(), busP(idx2), '#ffa94d', 'DATA', 2, function() {
                  particles.push(new Particle(busP(idx2), l1Pos(idx2), '#ffa94d', 'DATA', 2, function() {
                    layout.sms[idx2].l1.state = 'modified'; setL1Dirty(idx2);
                    flash(layout.sms[idx2].l1, '#f59e0b');
                    stats.hits++; updateStats();
                  }));
                }));
              }, idx2 * 380);
            }));
          }));
        }, idx2 * 130);
      })(ri);
    }
  }
  updateStats();
}


function startApp() {
  resize();
  if (!W || !H) { requestAnimationFrame(startApp); return; }
  buildLayout();
  initialized = true;
  updateKeyCard();
  updateArchIntro();
  buildInstrChips();
  lastTime = performance.now();
  requestAnimationFrame(drawFrame);
}
requestAnimationFrame(startApp);

var explainerEl = document.getElementById('step-list');
explainerEl.addEventListener('mousemove', function(e) {
  var target = e.target.closest('.micro-instr');
  if (target) {
    var key = target.getAttribute('data-instr');
    showInstrTooltip(key, e.clientX, e.clientY);
  } else {
    hideInstrTooltip();
  }
});
explainerEl.addEventListener('mouseleave', function() { hideInstrTooltip(); });
</script>
</body>
</html>
