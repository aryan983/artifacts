<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GPU Cache Coherency ‚Äî Architecture Explorer</title>
<style>
/* System font stack ‚Äî no external requests, works in preview */
:root {
  --bg: #0a0b0f; --surface: #12141a; --surface2: #1a1d26;
  --border: #2a2d3a; --text: #e0e2ec; --dim: #6b7094;
  --l1: #ff6b6b; --l2: #ffa94d; --smem: #51cf66;
  --global: #339af0; --dram: #845ef7; --coherency: #f06595;
  --new-block: #22d3ee; --changed: #facc15;
}
* { margin:0; padding:0; box-sizing:border-box; }
body { background:var(--bg); color:var(--text); font-family:'Outfit','Inter','Segoe UI',system-ui,sans-serif; min-height:100vh; overflow-x:hidden; }
.grain { position:fixed; inset:0; pointer-events:none; z-index:999; opacity:.03;
  background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E"); }

header { text-align:center; padding:20px 16px 10px; }
header h1 { font-size:clamp(1.6rem,3.5vw,2.6rem); font-weight:800; letter-spacing:-1px;
background:linear-gradient(135deg,#ff6b6b,#ffa94d,#51cf66,#339af0,#845ef7);
-webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text; }
header p { color:var(--dim); font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; font-size:.75rem; margin-top:4px; letter-spacing:2px; text-transform:uppercase; }

.arch-tabs { display:flex; justify-content:center; gap:0; padding:10px 16px 6px; flex-wrap:wrap; }
.arch-tab {
background:var(--surface); border:1px solid var(--border); color:var(--dim);
font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; font-size:.7rem; padding:8px 14px;
cursor:pointer; transition:all .2s; letter-spacing:.3px; position:relative;
border-right:none;
}
.arch-tab:first-child { border-radius:6px 0 0 6px; }
.arch-tab:last-child { border-radius:0 6px 6px 0; border-right:1px solid var(--border); }
.arch-tab:hover { color:var(--text); background:var(--surface2); }
.arch-tab.active { background:var(--surface2); color:#fff; border-color:var(--accent-color,var(--global)); }
.arch-tab.active::after { content:''; position:absolute; bottom:-1px; left:10%; right:10%; height:2px; background:var(--accent-color,var(--global)); border-radius:1px; }
.arch-tab .tab-gen { display:block; font-size:.55rem; color:var(--dim); margin-top:2px; font-weight:400; }
.arch-tab.active .tab-gen { color:var(--accent-color,var(--global)); }

.diff-banner {
max-width:1200px; margin:6px auto 0; padding:8px 14px;
background:var(--surface); border:1px solid var(--border); border-radius:8px;
font-size:.75rem; line-height:1.5; display:none; text-align:center;
}
.diff-banner.visible { display:block; }
.diff-banner .new-tag { color:var(--new-block); font-weight:600; }
.diff-banner .changed-tag { color:var(--changed); font-weight:600; }
.diff-banner .removed-tag { color:#ff6b6b; font-weight:600; text-decoration:line-through; }

.controls { display:flex; justify-content:center; gap:12px; padding:12px 20px; flex-wrap:wrap; }
.controls button {
background:var(--surface2); border:1px solid var(--border); color:var(--text);
font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; font-size:.75rem; padding:8px 16px;
border-radius:6px; cursor:pointer; transition:all .2s; letter-spacing:.5px;
position:relative;
}
.controls button:hover { border-color:var(--coherency); color:#fff; }
.controls button.active { background:var(--coherency); border-color:var(--coherency); color:#fff; }
.controls button.reset-btn { background:transparent; border-color:#ff6b6b50; color:#ff6b6b; }
.controls button.reset-btn:hover { background:#ff6b6b20; border-color:#ff6b6b; }

/* ‚îÄ‚îÄ Pause button ‚îÄ‚îÄ */
.controls button.pause-btn {
  background:transparent; border-color:#845ef760; color:#845ef7;
}
.controls button.pause-btn:hover { background:#845ef720; border-color:#845ef7; color:#c0a8ff; }
.controls button.pause-btn.active { background:#845ef7; border-color:#845ef7; color:#fff; }

/* ‚îÄ‚îÄ Atomic button ‚îÄ‚îÄ */
.controls button.atomic-btn {
  background: transparent; border-color: #f59e0b60; color: #f59e0b;
}
.controls button.atomic-btn:hover { background:#f59e0b18; border-color:#f59e0b; color:#fbbf24; }
.controls button.atomic-btn.apex-only { display:none; }
.controls button.cp-async-btn {
  background: transparent; border-color: #22d3ee50; color: #22d3ee;
}
.controls button.cp-async-btn:hover { background:#22d3ee15; border-color:#22d3ee; color:#67e8f9; }
.controls button.tma-btn {
  background: transparent; border-color: #22d3ee50; color: #22d3ee;
}
.controls button.tma-btn:hover { background:#22d3ee15; border-color:#22d3ee; color:#67e8f9; }

/* ‚îÄ‚îÄ Rich block info panel (arbiter etc.) ‚îÄ‚îÄ */
.arb-section { margin-bottom: 10px; }
.arb-section-title {
  font-family: 'JetBrains Mono', monospace; font-size: .6rem;
  text-transform: uppercase; letter-spacing: 1.5px;
  color: #f59e0b; margin-bottom: 5px; padding-bottom: 3px;
  border-bottom: 1px solid #f59e0b22;
}
.arb-section-title.green { color: #51cf66; border-bottom-color: #51cf6622; }
.arb-section-title.blue  { color: #339af0; border-bottom-color: #339af022; }
.arb-section-title.purple{ color: #a78bfa; border-bottom-color: #a78bfa22; }
.arb-section-title.pink  { color: #ffa94d; border-bottom-color: #ffa94d22; }
.arb-pipeline {
  display: flex; align-items: center; gap: 0; margin: 6px 0 8px;
  font-family: 'JetBrains Mono', monospace; font-size: .58rem;
}
.arb-step {
  background: #1a1d26; border: 1px solid #2a2d3a; border-radius: 4px;
  padding: 3px 6px; color: #aaa; white-space: nowrap; position: relative;
}
.arb-step.amber { border-color: #f59e0b50; color: #f59e0b; background: #f59e0b0a; }
.arb-step.green { border-color: #51cf6650; color: #51cf66; background: #51cf660a; }
.arb-step.blue  { border-color: #339af050; color: #339af0; background: #339af00a; }
.arb-step.orange{ border-color: #ffa94d50; color: #ffa94d; background: #ffa94d0a; }
.arb-step.purple{ border-color: #a78bfa50; color: #a78bfa; background: #a78bfa0a; }
.arb-arrow { color: #3a3d55; font-size: .65rem; padding: 0 2px; }
.arb-row { display: flex; gap: 6px; margin-bottom: 4px; font-size: .73rem; line-height: 1.5; }
.arb-row-label {
  font-family: 'JetBrains Mono', monospace; font-size: .6rem;
  color: #f59e0b; min-width: 60px; flex-shrink: 0; padding-top: 1px;
}
.arb-row-val { color: #c0c4d8; flex: 1; }
.arb-note { font-size: .7rem; color: #6b7094; line-height: 1.55; margin-bottom: 6px; font-style: italic; }
.arb-tag {
  display: inline-block; font-family: 'JetBrains Mono', monospace;
  font-size: .55rem; padding: 1px 5px; border-radius: 3px; margin: 1px 2px;
  border: 1px solid; vertical-align: middle;
}
.arb-tag.amber { color: #f59e0b; border-color: #f59e0b50; background: #f59e0b10; }
.arb-tag.green { color: #51cf66; border-color: #51cf6650; background: #51cf6610; }
.arb-tag.blue  { color: #339af0; border-color: #339af050; background: #339af010; }
.arb-tag.purple{ color: #a78bfa; border-color: #a78bfa50; background: #a78bfa10; }
.arb-tag.orange{ color: #ffa94d; border-color: #ffa94d50; background: #ffa94d10; }
.arb-divider { border: none; border-top: 1px solid #1e2030; margin: 8px 0; }
.tt-wide {
  max-width: 380px !important;
  min-width: 340px !important;
}
.tt-arb-section {
  margin-top: 8px;
  padding-top: 7px;
  border-top: 1px solid var(--border);
}
.tt-arb-label {
  font-family: 'JetBrains Mono', monospace;
  font-size: .56rem;
  color: #6b7090;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 4px;
}
.tt-arb-queue {
  display: flex;
  gap: 3px;
  flex-wrap: wrap;
  margin-bottom: 3px;
}
.tt-arb-slot {
  width: 26px; height: 18px;
  border-radius: 3px;
  background: #1e2030;
  border: 1px solid #2a2d3a;
  font-family: 'JetBrains Mono', monospace;
  font-size: .56rem;
  display: flex; align-items: center; justify-content: center;
  color: #6b7090;
  transition: all .2s;
}
.tt-arb-slot.occ { background:#f59e0b22; border-color:#f59e0b80; color:#fbbf24; }
.tt-arb-slot.ret { background:#339af022; border-color:#339af080; color:#339af0; }
.tt-arb-slot.don { background:#51cf6622; border-color:#51cf6680; color:#51cf66; }
.tt-arb-rob {
  display: flex;
  gap: 3px;
  margin-bottom: 3px;
}
.tt-arb-rob-slot {
  flex: 1;
  height: 16px;
  border-radius: 3px;
  background: #1e2030;
  border: 1px solid #2a2d3a;
  font-family: 'JetBrains Mono', monospace;
  font-size: .5rem;
  display: flex; align-items: center; justify-content: center;
  color: #6b7090;
}
.tt-arb-rob-slot.pend { background:#f59e0b18; border-color:#f59e0b50; color:#f59e0b; }
.tt-arb-rob-slot.comp { background:#339af018; border-color:#339af050; color:#339af0; }
.tt-arb-rob-slot.retr { background:#a78bfa18; border-color:#a78bfa50; color:#a78bfa; }
.tt-arb-rob-slot.done { background:#51cf6618; border-color:#51cf6650; color:#51cf66; }
.tt-arb-bar-bg {
  height: 5px; border-radius: 3px; background: #1e2030;
  overflow: hidden; margin: 3px 0;
}
.tt-arb-bar-fill {
  height: 100%; border-radius: 3px;
  background: linear-gradient(90deg, #51cf66, #f59e0b, #ff6b6b);
  transition: width .3s;
}
.tt-arb-grant-log {
  font-family: 'JetBrains Mono', monospace;
  font-size: .58rem;
  color: #6b7090;
  line-height: 1.7;
}
.tt-arb-grant-log .gs { color: #f59e0b; }
.tt-arb-grant-log .gc { color: #e0e2ec; }

/* ‚îÄ‚îÄ Latency badge on blocks ‚îÄ‚îÄ */
.lat-badge {
  position: absolute;
  pointer-events: none;
  z-index: 25;
  font-family: 'JetBrains Mono', monospace;
  font-size: .58rem;
  font-weight: 700;
  padding: 2px 7px;
  border-radius: 4px;
  border: 1px solid currentColor;
  opacity: 0;
  transition: opacity .2s;
  white-space: nowrap;
}
.lat-badge.visible { opacity: 1; }
.paused-badge.visible { display:block; }

/* ‚îÄ‚îÄ Scenario tooltip ‚îÄ‚îÄ */
#scenario-tooltip {
  position:fixed; pointer-events:none; z-index:300;
  background:#090b12; border:1px solid var(--border);
  border-radius:12px; padding:14px 16px; max-width:290px; min-width:220px;
  box-shadow:0 14px 44px rgba(0,0,0,.9);
  opacity:0; transition:opacity .15s, transform .15s;
  transform:translateY(6px);
  font-size:.75rem; line-height:1.6;
}
#scenario-tooltip.visible { opacity:1; transform:translateY(0); }
#scenario-tooltip .st-title {
  font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; font-weight:700; font-size:.82rem;
  margin-bottom:8px; display:flex; align-items:center; gap:8px;
}
#scenario-tooltip .st-dot { width:8px; height:8px; border-radius:2px; flex-shrink:0; }
#scenario-tooltip .st-desc { color:#c8cce0; font-size:.75rem; line-height:1.55; margin-bottom:8px; }
#scenario-tooltip .st-detail {
  background:#0f1520; border:1px solid #339af020; border-radius:7px;
  padding:8px 10px;
}
#scenario-tooltip .st-detail-label {
  font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; font-size:.55rem; font-weight:700;
  text-transform:uppercase; letter-spacing:1.5px; color:#339af099; margin-bottom:3px;
}
#scenario-tooltip .st-detail-text { color:#90c8f0; font-size:.72rem; line-height:1.5; }

.main-container { display:flex; gap:24px; padding:12px 20px; max-width:1400px; margin:0 auto; align-items:flex-start; }
.viz-area { flex:1; min-width:0; position:relative; }
canvas { width:100%; height:720px; background:var(--surface); border-radius:12px; border:1px solid var(--border); display:block; cursor:default; }
@media(max-width:500px){ canvas { height:640px; } .viz-area { max-width:none; } }

/* ‚îÄ‚îÄ Tooltip ‚îÄ‚îÄ */
#block-tooltip {
  position:absolute; pointer-events:none; z-index:100;
  background:#0d0f16; border:1px solid var(--border);
  border-radius:10px; padding:11px 14px; max-width:240px;
  box-shadow: 0 8px 32px rgba(0,0,0,.7);
  opacity:0; transition:opacity .15s;
  font-size:.75rem; line-height:1.55;
}
#block-tooltip.visible { opacity:1; }
#block-tooltip .tt-title { font-weight:700; font-size:.85rem; margin-bottom:6px; display:flex; align-items:center; gap:7px; }
#block-tooltip .tt-dot { width:9px; height:9px; border-radius:3px; flex-shrink:0; }
#block-tooltip .tt-desc { color:var(--dim); margin-bottom:7px; }
#block-tooltip .tt-meta { display:flex; flex-wrap:wrap; gap:5px; }
#block-tooltip .tt-chip {
  font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; font-size:.6rem; font-weight:600;
  padding:2px 7px; border-radius:4px;
}
#block-tooltip .tt-hint {
  margin-top:8px; padding-top:6px; border-top:1px solid var(--border);
  font-size:.65rem; color:#6b7094; font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace;
  display:flex; align-items:center; gap:5px;
}
#block-tooltip .tt-hint::before { content:'‚óâ'; font-size:.7rem; }

/* ‚îÄ‚îÄ Instruction tooltip ‚îÄ‚îÄ */
#instr-tooltip {
  position:fixed; pointer-events:none; z-index:200;
  background:#080a10; border:1px solid var(--border);
  border-radius:12px; padding:14px 16px; max-width:310px; min-width:240px;
  box-shadow: 0 12px 40px rgba(0,0,0,.85);
  opacity:0; transition:opacity .15s, transform .15s;
  transform:translateY(4px);
  font-size:.75rem; line-height:1.6;
}
#instr-tooltip.visible { opacity:1; transform:translateY(0); }
#instr-tooltip .it-name {
  font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; font-weight:700; font-size:.82rem;
  margin-bottom:8px; display:flex; align-items:center; gap:8px;
}
#instr-tooltip .it-dot { width:8px; height:8px; border-radius:2px; flex-shrink:0; }
#instr-tooltip .it-section { margin-bottom:8px; }
#instr-tooltip .it-label {
  font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; font-size:.55rem; font-weight:700;
  text-transform:uppercase; letter-spacing:1.5px; color:#6b7094; margin-bottom:3px;
}
#instr-tooltip .it-text { color:#c8cce0; font-size:.74rem; line-height:1.55; }
#instr-tooltip .it-why-box {
  background:#0f1a12; border:1px solid #51cf6625; border-radius:7px;
  padding:8px 10px; margin-top:6px;
}
#instr-tooltip .it-why-box .it-label { color:#51cf6699; }
#instr-tooltip .it-why-box .it-text { color:#a0dbb0; }

/* ‚îÄ‚îÄ Selection panel ‚îÄ‚îÄ */
#sel-panel {
  background:var(--surface); border:1px solid var(--border); border-radius:10px;
  padding:14px; display:none; margin-top:12px;
}
#sel-panel { max-height: 70vh; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #2a2d3a transparent; }
#sel-panel.visible { display:block; }
#sel-panel h4 { font-size:.65rem; font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; text-transform:uppercase; letter-spacing:2px; color:var(--dim); margin-bottom:10px; }
#sel-panel .sel-name { font-weight:700; font-size:.95rem; margin-bottom:6px; }
#sel-panel .sel-desc { font-size:.78rem; color:var(--dim); line-height:1.55; margin-bottom:10px; }
#sel-panel .sel-connections { }
#sel-panel .sel-connections h5 { font-size:.6rem; font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; text-transform:uppercase; letter-spacing:1.5px; color:var(--dim); margin-bottom:7px; }
#sel-panel .conn-list { display:flex; flex-direction:column; gap:5px; }
#sel-panel .conn-item {
  display:flex; align-items:flex-start; gap:8px; padding:7px 10px;
  background:var(--bg); border-radius:6px; border:1px solid var(--border);
  font-size:.75rem; line-height:1.45; cursor:pointer; transition:border-color .15s;
}
#sel-panel .conn-item:hover { border-color: #4a4d5a; }
#sel-panel .conn-item .ci-arrow { font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; font-size:.7rem; flex-shrink:0; margin-top:1px; }
#sel-panel .conn-item .ci-body { flex:1; }
#sel-panel .conn-item .ci-target { font-weight:600; }
#sel-panel .conn-item .ci-why { color:var(--dim); font-size:.7rem; display:block; }
#sel-panel .close-btn { float:right; font-size:.7rem; color:var(--dim); cursor:pointer; font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; padding:2px 6px; border:1px solid var(--border); border-radius:4px; }
#sel-panel .close-btn:hover { color:var(--text); }

.info-panel { width:360px; flex-shrink:0; display:flex; flex-direction:column; gap:12px; }
.info-card { background:var(--surface); border:1px solid var(--border); border-radius:10px; padding:14px; }
.info-card h3 { font-size:.65rem; font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; text-transform:uppercase; letter-spacing:2px; color:var(--dim); margin-bottom:10px; }

/* Instruction reference chips */
.instr-section { margin-top:0; }
.instr-chips { display:flex; flex-wrap:wrap; gap:8px; }
.instr-chip {
  font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; font-size:.72rem; font-weight:700;
  padding:5px 11px; border-radius:6px; cursor:pointer;
  border:1px solid transparent; transition:all .15s;
  user-select:none;
}
.instr-chip:hover { transform:translateY(-1px); box-shadow:0 4px 14px rgba(0,0,0,.4); }

.bottom-section { max-width:1200px; margin:0 auto; padding:0 20px 30px; }
.bottom-grid { display:grid; grid-template-columns:1fr 1fr; gap:16px; }

@media(min-width:1101px) {
.perf-bars { height:32px; }
.perf-bar-val { font-size:.58rem; }
.perf-label { min-width:70px; font-size:.75rem; }
}

.acc-item { border-bottom:1px solid var(--border); }
.acc-item:last-child { border-bottom:none; }
.acc-head { display:flex; align-items:center; gap:8px; padding:8px 0; cursor:pointer; user-select:none; -webkit-user-select:none; }
.acc-head:active { opacity:.7; }
.acc-dot { width:8px; height:8px; border-radius:3px; flex-shrink:0; }
.acc-title { flex:1; font-weight:600; font-size:.8rem; }
.acc-meta { font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; font-size:.6rem; color:var(--dim); }
.acc-chev { font-size:.65rem; color:var(--dim); transition:transform .25s; }
.acc-item.open .acc-chev { transform:rotate(90deg); }
.acc-body { max-height:0; overflow:hidden; transition:max-height .3s,padding .3s; padding:0 0 0 16px; }
.acc-item.open .acc-body { max-height:350px; padding:0 0 8px 16px; }
.acc-body p { font-size:.75rem; line-height:1.5; color:var(--dim); margin:0; }
.acc-body p strong { color:var(--text); }
.acc-badge-new { font-size:.55rem; background:var(--new-block); color:#000; padding:1px 5px; border-radius:3px; font-weight:700; margin-left:4px; }
.acc-badge-changed { font-size:.55rem; background:var(--changed); color:#000; padding:1px 5px; border-radius:3px; font-weight:700; margin-left:4px; }

.stats-grid { display:grid; grid-template-columns:1fr 1fr; gap:6px; }
.stat-item { background:var(--bg); border-radius:6px; padding:8px; text-align:center; }
.stat-value { font-size:1.3rem; font-weight:700; font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; }
.stat-label { font-size:.6rem; color:var(--dim); text-transform:uppercase; letter-spacing:1px; margin-top:1px; }

.state-row { display:flex; align-items:center; gap:8px; margin-bottom:6px; font-size:.8rem; }
.state-dot { width:8px; height:8px; border-radius:50%; flex-shrink:0; }
.state-label { font-weight:600; min-width:70px; }
.state-desc { color:var(--dim); font-size:.73rem; }

.explainer { position:relative; overflow:hidden; min-height:100px; max-height:400px; }
.explainer::before { content:''; position:absolute; top:0; left:0; right:0; height:3px;
background:linear-gradient(90deg,var(--l1),var(--l2),var(--smem),var(--global),var(--dram)); border-radius:10px 10px 0 0; opacity:.6; }
.explainer-title { font-weight:700; font-size:.95rem; margin-bottom:8px; display:flex; align-items:center; gap:8px; }
.explainer-title .dot { width:8px; height:8px; border-radius:50%; animation:pulse-dot 1.5s ease-in-out infinite; }
@keyframes pulse-dot { 0%,100%{opacity:.5;transform:scale(1)} 50%{opacity:1;transform:scale(1.3)} }
.step-list { list-style:none; max-height:220px; overflow-y:auto; overscroll-behavior:contain; scrollbar-width:thin; scrollbar-color:var(--border) transparent; }
.step-list::-webkit-scrollbar{width:4px} .step-list::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px}
.step-list li { display:flex; align-items:flex-start; gap:8px; padding:5px 0; font-size:.78rem; line-height:1.4; opacity:0; transform:translateX(-6px); transition:opacity .4s,transform .4s; }
.step-list li.visible { opacity:1; transform:translateX(0); }
.step-list li.active { opacity:1; transform:translateX(0); }
.step-list li.past { opacity:.4; }
.step-num { font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; font-size:.65rem; font-weight:600; min-width:18px; height:18px; display:flex; align-items:center; justify-content:center; border-radius:4px; flex-shrink:0; }
.step-text { flex:1; }
.step-text .micro { display:block; font-size:.68rem; color:var(--dim); font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; margin-top:1px; }
.explainer-summary { margin-top:8px; padding-top:8px; border-top:1px solid var(--border); font-size:.73rem; color:var(--dim); font-style:italic; opacity:0; transition:opacity .5s; }
.explainer-summary.visible { opacity:1; }

.event-log { max-height:160px; overflow-y:auto; overscroll-behavior:contain; scrollbar-width:thin; scrollbar-color:var(--border) transparent; }
.event-log::-webkit-scrollbar{width:4px} .event-log::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px}
.log-entry { font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; font-size:.65rem; padding:3px 0; border-bottom:1px solid rgba(42,45,58,.5); color:var(--dim); animation:fadeIn .3s; }
.log-entry .tag { display:inline-block; padding:1px 5px; border-radius:3px; font-size:.6rem; margin-right:3px; }
@keyframes fadeIn { from{opacity:0;transform:translateY(-4px)} to{opacity:1;transform:translateY(0)} }

.arch-intro { max-width:1200px; margin:6px auto 0; padding:0 20px; }
.arch-intro-inner {
background:var(--surface); border:1px solid var(--border); border-radius:10px;
padding:14px 16px; display:flex; gap:14px; align-items:flex-start;
}
.arch-intro-badge {
font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; font-size:.6rem; font-weight:700;
padding:4px 10px; border-radius:5px; white-space:nowrap; flex-shrink:0; margin-top:2px;
}
.arch-intro-text { font-size:.8rem; line-height:1.55; color:var(--dim); }
.arch-intro-text strong { color:var(--text); }
.arch-intro-delta { font-size:.78rem; line-height:1.5; color:var(--dim); margin-top:5px; padding:5px 10px; border-left:2px solid #f59e0b40; background:#f59e0b08; border-radius:0 4px 4px 0; }
.arch-intro-delta strong { color:var(--text); }

.easy-card { border-left:3px solid var(--smem); }
.easy-card h3 span { color:var(--smem); font-size:.6rem; margin-left:6px; font-weight:400; }
.easy-q { padding:8px 0; border-bottom:1px solid var(--border); cursor:pointer; user-select:none; -webkit-user-select:none; }
.easy-q:last-child { border-bottom:none; }
.easy-q:active { opacity:.7; }
.easy-head { display:flex; align-items:center; gap:8px; }
.easy-emoji { font-size:1rem; flex-shrink:0; width:22px; text-align:center; }
.easy-title { flex:1; font-weight:600; font-size:.82rem; }
.easy-chev { font-size:.65rem; color:var(--dim); transition:transform .25s; }
.easy-q.open .easy-chev { transform:rotate(90deg); }
.easy-body { max-height:0; overflow:hidden; transition:max-height .3s,padding .3s; padding:0 0 0 30px; }
.easy-q.open .easy-body { max-height:500px; padding:4px 0 6px 30px; }
.easy-body p { font-size:.78rem; line-height:1.6; color:var(--dim); margin:0 0 6px; }
.easy-body p strong { color:var(--text); }
.easy-body .analogy { font-style:italic; color:var(--smem); font-size:.73rem; }

.perf-card h3 { margin-bottom:12px; }
.perf-row { display:flex; align-items:center; gap:8px; margin-bottom:8px; }
.perf-label { font-size:.7rem; font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; color:var(--dim); min-width:65px; flex-shrink:0; }
.perf-bars { flex:1; display:flex; gap:2px; height:28px; align-items:flex-end; }
.perf-bar {
flex:1; border-radius:2px 2px 0 0; position:relative; min-height:2px;
transition:height .4s ease; display:flex; align-items:flex-end; justify-content:center;
}
.perf-bar-val {
font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; font-size:.5rem; font-weight:600;
position:absolute; top:-12px; width:100%; text-align:center; white-space:nowrap;
}
.perf-bar.active { outline:1px solid #fff3; outline-offset:1px; }
.perf-legend { display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; justify-content:center; }
.perf-legend-item { display:flex; align-items:center; gap:4px; font-size:.6rem; font-family:'JetBrains Mono','Fira Code','Cascadia Code','Consolas',monospace; color:var(--dim); }
.perf-legend-dot { width:8px; height:8px; border-radius:2px; }

@media(max-width:1100px) {
.main-container { flex-direction:column; }
.info-panel { width:100%; flex-direction:row; flex-wrap:wrap; }
.info-card { flex:1; min-width:260px; }
.bottom-grid { grid-template-columns:1fr; }
}
</style>
</head>
<body>
<div class="grain"></div>

<header>
  <h1>GPU Cache Coherency</h1>
  <p>Architecture Explorer ¬∑ Memory Hierarchy ¬∑ Data Flow</p>
</header>

<div class="arch-tabs" id="arch-tabs">
  <div class="arch-tab active" data-arch="pascal" style="--accent-color:#51cf66" onclick="switchArch('pascal')">Pascal<span class="tab-gen">SM 6.1 ¬∑ 2016</span></div>
  <div class="arch-tab" data-arch="volta" style="--accent-color:#339af0" onclick="switchArch('volta')">Volta<span class="tab-gen">SM 7.0 ¬∑ 2017</span></div>
  <div class="arch-tab" data-arch="ampere" style="--accent-color:#ffa94d" onclick="switchArch('ampere')">Ampere<span class="tab-gen">SM 8.0 ¬∑ 2020</span></div>
  <div class="arch-tab" data-arch="hopper" style="--accent-color:#845ef7" onclick="switchArch('hopper')">Hopper<span class="tab-gen">SM 9.0 ¬∑ 2022</span></div>
  <div class="arch-tab" data-arch="apex" style="--accent-color:#f59e0b" onclick="switchArch('apex')">Apex ‚ú¶<span class="tab-gen">SM 10.0 ¬∑ Concept</span></div>
</div>

<div class="diff-banner" id="diff-banner"></div>
<div class="arch-intro"><div class="arch-intro-inner" id="arch-intro"></div></div>

<div class="controls">
  <button class="scenario-btn" data-scenario="read"   onclick="triggerScenario('read')">SM Read</button>
  <button class="scenario-btn" data-scenario="write"  onclick="triggerScenario('write')">SM Write</button>
  <button class="scenario-btn" data-scenario="invalidate" onclick="triggerScenario('invalidate')">Invalidate</button>
  <button class="scenario-btn" data-scenario="writeback"  onclick="triggerScenario('writeback')">Write-Back</button>
  <button class="scenario-btn" data-scenario="shared"     onclick="triggerScenario('shared')">Shared Mem</button>
  <button class="scenario-btn" data-scenario="reg_spill"  onclick="triggerScenario('reg_spill')" id="btn-reg-spill">Reg Spill</button>
  <button class="scenario-btn atomic-btn" data-scenario="atomic" onclick="triggerScenario('atomic')" id="btn-atomic">‚öõ atomicAdd</button>
  <button class="scenario-btn cp-async-btn" data-scenario="cp_async" onclick="triggerScenario('cp_async')" id="btn-cp-async" style="display:none">cp.async</button>
  <button class="scenario-btn tma-btn" data-scenario="tma_load" onclick="triggerScenario('tma_load')" id="btn-tma-load" style="display:none">TMA Load</button>
  <button id="btn-pause" class="pause-btn" onclick="togglePause()">‚è∏ Pause</button>
  <button id="btn-auto" class="active" onclick="toggleAuto()">Auto</button>
  <button class="reset-btn" onclick="resetAll()">Reset</button>
</div>

<div class="main-container">
  <div class="viz-area">
    <canvas id="canvas" width="900" height="640"></canvas>
    <!-- paused badge removed -->
    <!-- Block tooltip -->
    <div id="block-tooltip">
      <div class="tt-title"><div class="tt-dot" id="tt-dot"></div><span id="tt-name"></span></div>
      <div class="tt-desc" id="tt-desc"></div>
      <div class="tt-meta" id="tt-meta"></div>
      <div class="tt-hint" id="tt-hint">Click to explore connections</div>
    </div>
    <!-- Selection panel -->
    <div id="sel-panel">
      <span class="close-btn" onclick="clearSelection()">‚úï close</span>
      <h4>Block Selected</h4>
      <div class="sel-name" id="sel-name"></div>
      <div class="sel-desc" id="sel-desc"></div>
      <div class="sel-connections">
        <h5>Connects To</h5>
        <div class="conn-list" id="conn-list"></div>
      </div>
    </div>
  </div>
  <div class="info-panel">
    <div class="info-card" id="key-card"></div>
    <div class="info-card">
      <h3>Cache States (MSI)</h3>
      <div class="state-row"><div class="state-dot" style="background:#51cf66"></div><span class="state-label">Modified</span><span class="state-desc">Dirty, exclusive</span></div>
      <div class="state-row"><div class="state-dot" style="background:#339af0"></div><span class="state-label">Shared</span><span class="state-desc">Clean, multi-reader</span></div>
      <div class="state-row"><div class="state-dot" style="background:#555"></div><span class="state-label">Invalid</span><span class="state-desc">Stale / absent</span></div>
    </div>
    <div class="info-card">
      <h3>Live Stats</h3>
      <div class="stats-grid">
        <div class="stat-item"><div class="stat-value" id="stat-hits" style="color:var(--smem)">0</div><div class="stat-label">Hits</div></div>
        <div class="stat-item"><div class="stat-value" id="stat-misses" style="color:var(--l1)">0</div><div class="stat-label">Misses</div></div>
        <div class="stat-item"><div class="stat-value" id="stat-inv" style="color:var(--coherency)">0</div><div class="stat-label">Invalidations</div></div>
        <div class="stat-item"><div class="stat-value" id="stat-wb" style="color:var(--l2)">0</div><div class="stat-label">Write-Backs</div></div>
      </div>
    </div>
    <div class="info-card explainer" id="explainer-card">
      <h3>What's Happening</h3>
      <div id="explainer-title" class="explainer-title" style="color:var(--dim)"><span class="dot" style="background:var(--dim)"></span>Click a scenario or wait for auto...</div>
      <ol class="step-list" id="step-list"></ol>
      <div class="explainer-summary" id="explainer-summary"></div>
    </div>
    <div class="info-card">
      <h3>Event Log</h3>
      <div class="event-log" id="event-log"></div>
    </div>
  </div>
</div>

<div class="bottom-section">
  <div class="bottom-grid">
    <div class="info-card easy-card">
      <h3>Easy Explain <span>for beginners</span></h3>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">üè†</span><span class="easy-title">What is a cache?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p>A cache is a <strong>small, fast storage</strong> that keeps copies of frequently used data close to where it's needed.</p><p class="analogy">Analogy: Your desk (cache) vs the library (main memory). You keep the books you're reading on your desk so you don't have to walk to the library every time.</p></div>
      </div>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">ü§ù</span><span class="easy-title">What is cache coherency?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p>When <strong>multiple processors</strong> (SMs) each have their own cache, they might hold different copies of the same data. Cache coherency keeps everyone's copies consistent.</p></div>
      </div>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">üì¶</span><span class="easy-title">What is an SM?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p>A <strong>Streaming Multiprocessor</strong> is the GPU's core compute unit. Each SM runs thousands of threads in parallel using "warps" (groups of 32 threads).</p></div>
      </div>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">‚ö°</span><span class="easy-title">Shared memory vs L1?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p><strong>L1</strong> is automatic ‚Äî hardware decides what to cache. <strong>Shared memory</strong> is manual ‚Äî programmer explicitly loads data. Faster and predictable, but more work.</p></div>
      </div>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">üö´</span><span class="easy-title">What does "invalidate" mean?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p>When one SM writes, others' cached copies become <strong>outdated</strong>. Invalidation says "throw away your copy." Next access fetches fresh from L2.</p></div>
      </div>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">üîÑ</span><span class="easy-title">What does "write-evict" mean?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p>Instead of keeping a dirty copy in L1, the SM <strong>drops the L1 copy entirely</strong> and writes straight to L2. Simpler than CPU write-back but more L2 traffic.</p></div>
      </div>
    </div>
  </div>
</div>

<div class="bottom-section instr-section">
  <div class="bottom-grid">
    <div class="info-card" id="instr-ref-card">
      <h3>Instruction Reference <span style="font-size:.6rem;color:var(--dim);font-weight:400;font-family:'JetBrains Mono',monospace;text-transform:uppercase;letter-spacing:1px">‚Äî hover any chip</span></h3>
      <div class="instr-chips" id="instr-chips"></div>
    </div>
  </div>
</div>

<!-- Scenario tooltip at body level -->
<div id="scenario-tooltip">
  <div class="st-title"><div class="st-dot" id="st-dot"></div><span id="st-title-text"></span></div>
  <div class="st-desc" id="st-desc-text"></div>
  <div class="st-detail">
    <div class="st-detail-label">What to watch for</div>
    <div class="st-detail-text" id="st-watch-text"></div>
  </div>
</div>

<!-- Instruction tooltip at body level so fixed positioning works correctly -->
<div id="instr-tooltip">
  <div class="it-name"><div class="it-dot" id="it-dot"></div><span id="it-name"></span></div>
  <div class="it-section">
    <div class="it-label">What it does</div>
    <div class="it-text" id="it-what"></div>
  </div>
  <div class="it-why-box">
    <div class="it-label">Why you need this op</div>
    <div class="it-text" id="it-why"></div>
  </div>
</div>
  <script>
// globals.js ‚Äî GPU Cache Coherency Demo

// Global state, constants, pause toggle, scenario tooltip data


var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
var W, H, dpr;
var initialized = false;

// ‚îÄ‚îÄ Pause state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
var paused = false;


function togglePause() {
  paused = !paused;
  var btn = document.getElementById('btn-pause');
  var badge = document.getElementById('paused-badge');
  if (paused) {
    btn.classList.add('active');
    btn.textContent = '‚ñ∂ Resume';
    if (badge) badge.classList.add('visible');
    // Also stop auto when pausing
    if (autoMode) { autoMode = false; document.getElementById('btn-auto').classList.remove('active'); }
    logEvent('Paused ‚Äî animation frozen', '#845ef7');
  } else {
    btn.classList.remove('active');
    btn.textContent = '‚è∏ Pause';
    if (badge) badge.classList.remove('visible');
    lastTime = performance.now(); // reset dt so we don't get a big jump
    logEvent('Resumed', '#845ef7');
  }
}


// ‚îÄ‚îÄ Scenario button tooltip data ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
var SCENARIO_INFO = {
  read: {
    title: 'SM Read  (L1 Miss ‚Üí L2 Fetch)',
    color: '#ff6b6b',
    desc: 'A warp issues a global load (LD.E). The SM checks its L1 ‚Äî on a miss, it sends a read request down to L2. The cache line travels back and fills L1.',
    watch: 'Watch the RdReq particle travel SM‚ÜíBus‚ÜíL2, then DATA come back and fill the L1 line. L1 state transitions: Invalid ‚Üí Shared.'
  },
  write: {
    title: 'SM Write  (write-evict + INV)',
    color: '#51cf66',
    desc: 'Pascal: writes bypass L1 and go straight to L2 (write-through). Volta+: SM writes to L1 (Modified), then evicts to L2 and broadcasts INV to invalidate other SMs\' copies.',
    watch: 'On Volta+: see the INV packets fan out to all other SMs, turning their L1 lines grey (Invalid). On Pascal: just a direct WR to L2, no INV needed.'
  },
  invalidate: {
    title: 'Broadcast Invalidation',
    color: '#f06595',
    desc: 'A global coherency event ‚Äî a write happened somewhere and all cached copies of that address must be dropped. The coherency bus broadcasts INV to every SM simultaneously.',
    watch: 'INV packets fire from the bus center to all SMs in parallel. Each SM\'s L1 transitions to Invalid (grey). Cost scales linearly with SM count ‚Äî this is why write-heavy kernels are expensive.'
  },
  writeback: {
    title: 'Write-Back Cascade (L1‚ÜíL2‚ÜíDRAM)',
    color: '#ffa94d',
    desc: 'A dirty L1 line is being evicted (capacity pressure). It writes to L2. If L2 is also full, the victim cascades all the way to DRAM through the memory controller.',
    watch: 'The full eviction chain: WB particle L1‚ÜíBus‚ÜíL2, then EVICT particle L2‚ÜíCrossbar‚ÜíGlobal Mem‚ÜíHBM. The HBM block flashes purple at the end ‚Äî data is now only in DRAM.'
  },
  shared: {
    title: 'Shared Memory Access (+ DSMEM on Hopper)',
    color: '#51cf66',
    desc: 'Threads access __shared__ SRAM via LDS/STS ‚Äî no coherency protocol, no bus traffic, no L2 involvement. Pure on-chip speed. Hopper adds DSMEM: cross-SM shared memory within a cluster.',
    watch: 'Notice: no bus or L2 activity at all. The particles stay entirely inside the SM. On Hopper, a second DSMEM particle crosses to the adjacent SM ‚Äî still on-chip, ~20 cycle latency.'
  },
  atomic: {
    title: '‚öõ atomicAdd ‚Äî Hardware Serialization',
    color: '#f59e0b',
    desc: 'Multiple SMs simultaneously call atomicAdd() to the same address. Without an arbiter, two SMs could both read the value, add to it, and one result gets silently lost. The Apex Arbiter prevents this by serializing all requests with sequence numbers.',
    watch: 'On Apex: watch ATOM packets queue in the Arbiter panel (hover it to expand). Each gets a SEQ#. GRANTs fire one at a time. On older archs: watch the raw bus contention with no coordination ‚Äî and imagine the race conditions without hardware atomics.'
  },
  reg_spill: {
    title: 'Register Spill ‚Äî Regs ‚Üí L1 ‚Üí L2',
    color: '#fb923c',
    desc: 'A warp runs out of physical registers. The compiler spills excess live values to L1 cache, stalling the warp. If L1 is full, the spill cascades to L2 (~200 cycles). When the value is needed again, a RELOAD brings it back.',
    watch: 'See the SPILL particle travel from the register file into L1. If L1 is under pressure, watch it cascade to L2. Then the RELOAD particle returns ‚Äî that round-trip is the stall.'
  },
  cp_async: {
    title: 'cp.async ‚Äî Global ‚Üí SMEM (Bypass Regs)',
    color: '#22d3ee',
    desc: 'Ampere\'s async copy loads data from global memory directly into shared memory ‚Äî without touching registers and without stalling the warp. The warp immediately continues computing while data arrives.',
    watch: 'Notice the cp.async particle bypasses the register file. Simultaneously a compute pulse appears inside the SM ‚Äî the warp keeps working. This is how Ampere achieves compute-memory overlap.'
  },
  tma_load: {
    title: 'TMA Load ‚Äî Bulk Tensor Tile ‚Üí SMEM',
    color: '#22d3ee',
    desc: 'Hopper\'s Tensor Memory Accelerator transfers entire tensor tiles from global memory to shared memory. One thread issues the descriptor; the hardware DMA handles all address math and data movement.',
    watch: 'The TILE particle originates from the TMA block. Multiple tiles arrive in sequence. SM threads compute on the previous tile while new data arrives ‚Äî true pipeline overlap.'
  }
};

var scenarioTooltipEl = document.getElementById('scenario-tooltip');
var scenarioVisible = false;


function showScenarioTooltip(key, clientX, clientY) {
  var info = SCENARIO_INFO[key];
  if (!info) return;
  document.getElementById('st-dot').style.background = info.color;
  scenarioTooltipEl.style.borderColor = info.color + '50';
  document.getElementById('st-title-text').textContent = info.title;
  document.getElementById('st-desc-text').textContent = info.desc;
  document.getElementById('st-watch-text').textContent = info.watch;
  positionScenarioTooltip(clientX, clientY);
  scenarioTooltipEl.classList.add('visible');
  scenarioVisible = true;
}

function hideScenarioTooltip() {
  scenarioTooltipEl.classList.remove('visible');
  scenarioVisible = false;
}

function positionScenarioTooltip(clientX, clientY) {
  var tw = 300, th = 200;
  var vw = window.innerWidth, vh = window.innerHeight;
  var tx = clientX - tw / 2;
  var ty = clientY - th - 14; // above the button
  if (tx + tw > vw - 10) tx = vw - tw - 10;
  if (tx < 8) tx = 8;
  if (ty < 8) ty = clientY + 40; // flip below if no room above
  scenarioTooltipEl.style.left = tx + 'px';
  scenarioTooltipEl.style.top  = ty + 'px';
}

// Attach hover listeners to scenario buttons
document.querySelectorAll('.scenario-btn').forEach(function(btn) {
  var key = btn.getAttribute('data-scenario');
  btn.addEventListener('mouseenter', function(e) {
    showScenarioTooltip(key, e.clientX, e.clientY);
  });
  btn.addEventListener('mousemove', function(e) {
    positionScenarioTooltip(e.clientX, e.clientY);
  });
  btn.addEventListener('mouseleave', function() {
    hideScenarioTooltip();
  });
});


// data.js ‚Äî GPU Cache Coherency Demo

// Architecture definitions, block metadata, instruction reference

var BLOCK_INFO = {
  regs:      { name:'Register File', color:'#a8b0d0', desc:'Fastest storage on the chip. Each thread gets its own private registers ‚Äî no sharing, no coherency needed. 32-bit per lane, ~255 per thread.', chips:[{t:'~1 cycle',c:'#51cf66'},{t:'private',c:'#339af0'}], connects:[{to:'l1',arrow:'‚Üí',why:'Spill registers to L1 when exhausted (register spilling)'},{to:'smem',arrow:'‚Üî',why:'Threads read/write shared mem via LDS/STS instructions'}] },
  l1:        { name:'L1 Cache (unified)', color:'#ff6b6b', desc:'Per-SM cache. Pascal: read-only for global data ‚Äî zero coherency overhead. Volta+: caches writes too, requires invalidation protocol when another SM writes to the same address.', chips:[{t:'~28 cycles',c:'#ffa94d'},{t:'per-SM',c:'#339af0'}], connects:[{to:'bus',arrow:'‚Üí',why:'Miss ‚Üí sends RdReq or INV across coherency bus'},{to:'smem',arrow:'‚Üî',why:'Shares physical SRAM pool (Volta+); split is software-configurable'},{to:'regs',arrow:'‚Üê',why:'Fills data into thread registers on cache hit/fill'}] },
  texCache:  { name:'Texture Cache (TEX$)', color:'#e599f7', desc:'Separate read-only cache optimized for 2D spatial locality. Used for sampled textures. Pascal keeps this distinct from L1; Volta+ merged them.', chips:[{t:'read-only',c:'#e599f7'},{t:'~24KB',c:'#a0a0a0'}], connects:[{to:'l2',arrow:'‚Üí',why:'All misses fetch from L2'},{to:'regs',arrow:'‚Üê',why:'Filtered/sampled results go into registers'}] },
  smem:      { name:'Shared Memory (SMEM)', color:'#51cf66', desc:'Software-managed on-chip SRAM. Threads in the same CTA (thread block) share this scratchpad. No coherency protocol ‚Äî programmer controls all reads/writes explicitly. 32 memory banks.', chips:[{t:'~20 cycles',c:'#51cf66'},{t:'per-CTA',c:'#339af0'},{t:'no coherency',c:'#f06595'}], connects:[{to:'regs',arrow:'‚Üî',why:'LDS/STS instructions move data between threads and SMEM'},{to:'l1',arrow:'‚Üî',why:'Shares the same physical SRAM as L1 (Volta+), split is configurable'},{to:'async',arrow:'‚Üê',why:'cp.async loads data from global memory directly into SMEM (Ampere+)'}] },
  tma:       { name:'Tensor Memory Accelerator (TMA)', color:'#22d3ee', desc:'Hopper hardware DMA engine. Handles bulk multi-dimensional tensor transfers between global memory and SMEM. Offloads address calculation from threads, freeing them for compute.', chips:[{t:'NEW: Hopper',c:'#22d3ee'},{t:'hardware DMA',c:'#845ef7'}], connects:[{to:'smem',arrow:'‚Üí',why:'Deposits tensor tiles directly into SMEM with tensor-aware addressing'},{to:'globalMem',arrow:'‚Üê',why:'Reads from global memory with N-D tensor coordinate logic'}] },
  dsmem:     { name:'Distributed Shared Memory (DSMEM)', color:'#22d3ee', desc:'Hopper feature. SMs within the same Thread Block Cluster can directly read each other\'s shared memory ‚Äî at roughly SMEM latency ‚Äî without going through L2. Enables tighter SM cooperation.', chips:[{t:'NEW: Hopper',c:'#22d3ee'},{t:'cluster-scope',c:'#845ef7'},{t:'~20 cycles',c:'#51cf66'}], connects:[{to:'smem',arrow:'‚Üî',why:'DSMEM is a window into another SM\'s SMEM within the cluster'},{to:'bus',arrow:'‚Üî',why:'Cluster bus carries cross-SM DSMEM traffic'}] },
  async:     { name:'Async Copy (cp.async)', color:'#22d3ee', desc:'Ampere+ instruction that moves data from global to shared memory without occupying registers or stalling the warp. Like a mini-DMA per thread, enabling compute-memory overlap.', chips:[{t:'Ampere+',c:'#ffa94d'},{t:'bypass regs',c:'#51cf66'}], connects:[{to:'smem',arrow:'‚Üí',why:'Destination: deposits data directly into SMEM'},{to:'globalMem',arrow:'‚Üê',why:'Source: reads from global memory without touching registers'}] },
  bus:       { name:'Coherency Bus / Crossbar', color:'#f06595', desc:'The shared interconnect between all SMs and the L2. Carries read requests, data responses, and invalidation messages. Pascal uses a simple crossbar (L1 is read-only). Volta+ must broadcast INV messages when writes occur.', chips:[{t:'shared fabric',c:'#f06595'},{t:'broadcast INV',c:'#339af0'}], connects:[{to:'l1',arrow:'‚Üî',why:'Delivers RdReq/DATA/INV messages to each SM\'s L1'},{to:'l2',arrow:'‚Üî',why:'Connects all SMs to the shared L2 cache'}] },
  l2:        { name:'L2 Cache (unified)', color:'#ffa94d', desc:'Shared by all SMs ‚Äî the point of coherence. All cache lines must pass through L2. Ampere introduced 10√ó larger L2 (40 MB) with software-controlled persistence windows. Hopper: 50 MB.', chips:[{t:'~200 cycles',c:'#ffa94d'},{t:'unified',c:'#339af0'},{t:'coherence point',c:'#f06595'}], connects:[{to:'bus',arrow:'‚Üî',why:'Serves read/write requests from all SMs via the coherency bus'},{to:'globalMem',arrow:'‚Üî',why:'Evicts dirty lines down to DRAM; fetches missing lines up on miss'}] },
  l2Persist: { name:'L2 Persistence Window', color:'#ffa94d', desc:'Ampere+ feature. You can pin a set of addresses to always stay in L2. Useful for weights or lookup tables accessed repeatedly across many kernels. Set via cudaAccessPolicyWindow.', chips:[{t:'Ampere+',c:'#ffa94d'},{t:'software ctrl',c:'#51cf66'}], connects:[{to:'l2',arrow:'‚Üî',why:'A sub-region of the L2 pinned via CUDA API policy'},{to:'globalMem',arrow:'‚Üê',why:'Persistently caches frequently-read global data in L2'}] },
  globalMem: { name:'Global Memory Interface', color:'#339af0', desc:'The on-chip logic (memory controllers + NoC) that bridges L2 to physical DRAM. Handles address translation, ECC, and row/bank scheduling. Multiple controllers run in parallel for bandwidth.', chips:[{t:'memory ctrl',c:'#339af0'},{t:'multi-channel',c:'#845ef7'}], connects:[{to:'l2',arrow:'‚Üî',why:'Receives evictions from L2; returns fetched DRAM data to L2'},{to:'hbm',arrow:'‚Üî',why:'Issues actual read/write commands to HBM stacks'}] },
  hbm:       { name:'HBM / GDDR (DRAM)', color:'#845ef7', desc:'Off-chip high-bandwidth memory. HBM stacks dies vertically connected via micro-bumps. Hopper HBM3 = 3.35 TB/s. Slowest in the hierarchy but largest ‚Äî all GPU memory ultimately lives here.', chips:[{t:'~400 cycles',c:'#ff6b6b'},{t:'off-chip',c:'#845ef7'},{t:'largest',c:'#6b7094'}], connects:[{to:'globalMem',arrow:'‚Üî',why:'Memory controllers read/write HBM banks via wide parallel buses'}] },
  arbiter: {
    name: 'Atomic Arbiter',
    color: '#f59e0b',
    desc: 'Hardware serialization unit for atomic operations.',
    descHTML: `
<div class="arb-section">
  <div class="arb-section-title">What it does</div>
  <div class="arb-note">Every <code>atomicAdd</code>, <code>atomicCAS</code>, <code>atomicExch</code> passes through this block. Without it, multiple SMs race to L2 simultaneously and corrupt each other's read-modify-write ‚Äî the lost-update bug. The arbiter serializes all atomics to the same address with zero programmer effort.</div>
</div>

<div class="arb-section">
  <div class="arb-section-title">Full pipeline</div>
  <div class="arb-pipeline">
    <span class="arb-step amber">ATOM</span><span class="arb-arrow">‚Üí</span>
    <span class="arb-step amber">interface</span><span class="arb-arrow">‚Üí</span>
    <span class="arb-step amber">SEQ# + queue</span><span class="arb-arrow">‚Üí</span>
    <span class="arb-step green">GRANT‚ÜíSM</span><span class="arb-arrow">‚Üí</span>
    <span class="arb-step blue">RMW through arbiter‚ÜíL2</span><span class="arb-arrow">‚Üí</span>
    <span class="arb-step orange">ACK#N‚ÜêL2</span><span class="arb-arrow">‚Üí</span>
    <span class="arb-step purple">ROB retire</span><span class="arb-arrow">‚Üí</span>
    <span class="arb-step green">DATA‚ÜíSM</span>
  </div>
</div>

<hr class="arb-divider">

<div class="arb-section">
  <div class="arb-section-title amber">‚ë† Bus interface + back-pressure</div>
  <div class="arb-row">
    <span class="arb-row-label">What:</span>
    <span class="arb-row-val">The single entry point between the coherency bus and the arbiter. All ATOM particles arrive here first. This is where back-pressure manifests ‚Äî if the queue is full (6 slots), the particle stalls <em>at this line</em> and retries until space opens. The SM warp is stalled for that entire duration.</span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">Why a line:</span>
    <span class="arb-row-val">The interface is a distinct named boundary, not a bus segment. It represents the hardware FIFO entry gate ‚Äî one logical point, not a block.</span>
  </div>
</div>

<div class="arb-section">
  <div class="arb-section-title amber">‚ë° SEQ# tagging + queue</div>
  <div class="arb-row">
    <span class="arb-row-label">What:</span>
    <span class="arb-row-val">On admission, each ATOM gets a monotonically increasing sequence number ‚Äî <span class="arb-tag amber">SEQ#0</span>, <span class="arb-tag amber">SEQ#1</span>, ‚Ä¶ assigned strictly in arrival order. Simultaneously, a slot is reserved in both the Incoming Queue (left) and the Hold Buffer/ROB (right).</span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">Why:</span>
    <span class="arb-row-val">L2 banks complete out of order. Without a SEQ# the arbiter can't match a returning ACK to the right SM. The number travels with the request all the way to L2 and back ‚Äî it's the ordering anchor for the ROB.</span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">Capacity:</span>
    <span class="arb-row-val"><strong>6 in-flight ops maximum.</strong> Queue and ROB both have 6 slots. Arrivals beyond 6 stall at the interface until a slot frees.</span>
  </div>
</div>

<div class="arb-section">
  <div class="arb-section-title green">‚ë¢ GRANT (control signal only)</div>
  <div class="arb-row">
    <span class="arb-row-label">What:</span>
    <span class="arb-row-val">The arbiter pops the front-of-queue entry and sends a <span class="arb-tag green">GRANT</span> back to that SM's warp scheduler. This is a <em>control signal</em>, not data ‚Äî it travels only to the bus junction (warp scheduler), not all the way to L1. The SM holds the atomic operand in a register already.</span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">Policy:</span>
    <span class="arb-row-val"><strong>FIFO arrival order.</strong> The SM that arrived first gets granted first. The arbiter issues grants back-to-back as fast as requests arrive ‚Äî multiple RMWs can be in-flight through the arbiter simultaneously. Mutual exclusion on the cache line lives at L2, not here.</span>
  </div>
</div>

<div class="arb-section">
  <div class="arb-section-title blue">‚ë£ RMW through arbiter ‚Üí L2</div>
  <div class="arb-row">
    <span class="arb-row-label">Path:</span>
    <span class="arb-row-val">SM bus junction ‚Üí bus ‚Üí arbiter top (enters block) ‚Üí arbiter bottom (exits block) ‚Üí L2. The particle physically traverses the arbiter block. The arbiter is a pass-through for ordering and sequencing ‚Äî the actual atomic lock is held by L2 on the cache line.</span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">At L2:</span>
    <span class="arb-row-val">L2 performs Read-Modify-Write atomically in one locked step: read old value ‚Üí apply op ‚Üí write new value. <strong>~200 cycles</strong> round-trip. This is why atomics are expensive ‚Äî full L2 latency, serialized.</span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">Jitter:</span>
    <span class="arb-row-val">Different L2 banks take different amounts of time. A random per-op latency (0‚Äì500ms visual) models this ‚Äî it's what causes ACKs to return out of order, making the ROB actually do work.</span>
  </div>
</div>

<div class="arb-section">
  <div class="arb-section-title orange">‚ë§ ACK ‚Üê L2 (out of order)</div>
  <div class="arb-row">
    <span class="arb-row-label">What:</span>
    <span class="arb-row-val">L2 sends <span class="arb-tag orange">ACK#N</span> back to the arbiter bottom carrying the result value and original SEQ# tag. Because multiple RMWs are in-flight simultaneously, <span class="arb-tag orange">ACK#2</span> may arrive before <span class="arb-tag orange">ACK#0</span>. The SEQ# is the only way to know which result belongs to which SM.</span>
  </div>
</div>

<div class="arb-section">
  <div class="arb-section-title purple">‚ë• Hold Buffer (ROB) ‚Äî the reordering</div>
  <div class="arb-row">
    <span class="arb-row-label">What:</span>
    <span class="arb-row-val">Reorder Buffer with 6 slots, one per in-flight op, allocated at enqueue time in SEQ order. The ROB head always points to the lowest unretired SEQ#. Retirement only proceeds from the head.</span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">States per slot:</span>
    <span class="arb-row-val">
      <span class="arb-tag amber">‚è≥ pending</span> ‚Äî RMW dispatched, ACK not back yet<br>
      <span class="arb-tag blue">‚ú¶ complete</span> ‚Äî ACK received, result in hand ‚Äî but blocked behind earlier pending slots<br>
      <span class="arb-tag green">‚úì done</span> ‚Äî head-of-line, DATA being sent to SM, slot cleaning up
    </span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">Example:</span>
    <span class="arb-row-val">SEQ#2 finishes before SEQ#0. ROB slot 2 flips to <span class="arb-tag blue">‚ú¶ complete</span> but cannot retire ‚Äî slot 0 is still <span class="arb-tag amber">‚è≥ pending</span>. When SEQ#0 finally arrives: slot 0 retires ‚Üí slot 1 checked ‚Üí slot 2 checked ‚Üí cascade drain in one pass. All three DATA packets leave in order 0, 1, 2.</span>
  </div>
  <div class="arb-row">
    <span class="arb-row-label">Why order?</span>
    <span class="arb-row-val">Each SM expects its own old value back ‚Äî not another SM's result. Out-of-order delivery would give SM1 SM3's pre-op value. The ROB guarantees every SM gets exactly the result of its own atomic, in the correct order.</span>
  </div>
</div>

<hr class="arb-divider">
<div class="arb-note">Without this arbiter, atomics serialize inside L2 invisibly ‚Äî you get correctness but zero visibility into latency, back-pressure, or reordering. The interface line, queue, and ROB are all implicit in real silicon. Apex makes every stage explicit.</div>`,
    chips: [{t:'NEW: Apex',c:'#f59e0b'},{t:'seq-numbered',c:'#339af0'},{t:'ROB ordered',c:'#51cf66'}],
    connects: [
      {to:'bus',   arrow:'‚Üê', why:'Receives all atomic requests from SMs via the coherency bus'},
      {to:'l2',    arrow:'‚Üí', why:'Dispatches one granted atomic at a time down to L2 for RMW'},
      {to:'l2',    arrow:'‚Üê', why:'Receives ACK with result value back from L2 (possibly out of order)'},
      {to:'bus',   arrow:'‚Üí', why:'Returns DATA to originating SM after ROB retires in SEQ order'}
    ]
  },
  cohDir:    { name:'Coherency Directory', color:'#22d3ee', desc:'A hardware table tracking which SMs hold a copy of each cache line. When a write occurs, instead of broadcasting INV to all SMs (O(n) traffic), the directory sends INV only to the SMs listed as sharers ‚Äî O(sharers). At 256+ SMs this is a massive bus bandwidth saving. CPUs have used directories for decades; GPUs are still mostly broadcast-based.', chips:[{t:'NEW: Apex',c:'#22d3ee'},{t:'targeted INV',c:'#f06595'},{t:'O(sharers)',c:'#51cf66'}], connects:[{to:'l2',arrow:'‚Üî',why:'Directory lives alongside L2 ‚Äî each L2 set has an associated sharer vector'},{to:'bus',arrow:'‚Üí',why:'Sends targeted INV only to SMs in the sharer list'}] },
  warpScheduler:{ name:'Warp Scheduler', color:'#a78bfa', desc:'The SM sub-unit that decides which warp runs each clock cycle. When a warp stalls (waiting for L2 data, a dependency, or a barrier), the scheduler instantly switches to another ready warp. With enough resident warps, the stall is completely hidden by useful work from other warps ‚Äî this is GPU latency tolerance. In Apex this becomes an explicit visible block with per-warp stall reason tracking.', chips:[{t:'NEW: Apex',c:'#a78bfa'},{t:'per-SM',c:'#339af0'},{t:'latency hiding',c:'#51cf66'}], connects:[{to:'l1',arrow:'‚Üî',why:'When a warp misses L1, scheduler marks it stalled; when DATA arrives, marks it ready'},{to:'regs',arrow:'‚Üî',why:'Stalled warp context (registers, PC) is swapped out when another warp runs'}] },
};

var INSTRUCTION_INFO = {
  'LD.E':   { name:'LD.E  (global load)', color:'#ff6b6b',
    what:'Load from global memory into registers. The .E suffix = "extended addressing" (64-bit). Each thread in the warp loads from its own address ‚Äî if addresses are contiguous the hardware coalesces them into one wide transaction.',
    why:'You need this any time you read from a __device__ pointer or cudaMalloc\'d buffer. It\'s the bread-and-butter read path for all GPGPU work ‚Äî matrix rows, activation tensors, weight arrays, etc.' },
  'ST.E':   { name:'ST.E  (global store)', color:'#51cf66',
    what:'Store from registers to global memory. On Pascal, bypasses L1 entirely (write-through). On Volta+ it evicts the L1 line and writes to L2 (write-evict), then broadcasts INV to other SMs.',
    why:'Writing results back to global memory after a kernel computation ‚Äî output matrices, reduction results, feature maps. Write-evict keeps coherency cheap: only one SM "owns" a dirty line at a time.' },
  'LDS':    { name:'LDS  (load from shared)', color:'#51cf66',
    what:'Load from shared memory (SMEM) into registers. ~20 cycles ‚Äî far cheaper than global. Hardware checks 32 memory banks; accesses to the same bank by different threads in a warp are serialised (bank conflict).',
    why:'The classic CUDA optimization: load a tile from global into SMEM once, then all threads reuse it from LDS repeatedly. MatMul tiling, stencil kernels, and reductions all rely on this.' },
  'STS':    { name:'STS  (store to shared)', color:'#51cf66',
    what:'Store from registers to shared memory. Same 32-bank structure as LDS. Used to cooperatively build a shared tile that other threads in the block will then read via LDS.',
    why:'Tiling patterns: one thread loads from global, stores into SMEM with STS, then all threads read with LDS. Also used for warp-level reductions ‚Äî each thread stores its partial sum then reads neighbours.' },
  'ST.S':   { name:'ST.S  (store to shared, alt form)', color:'#51cf66',
    what:'Alternate encoding for shared memory store. Functionally equivalent to STS ‚Äî same 20-cycle latency, same 32-bank conflict rules.',
    why:'Same use cases as STS ‚Äî cooperative data staging, tiling, reductions. The assembler may emit either form.' },
  'RdReq':  { name:'RdReq  (read request packet)', color:'#ff6b6b',
    what:'Not an ISA instruction ‚Äî a cache coherency protocol message sent from an SM\'s L1 to the L2 on a cache miss. Carries the missed cache line address. The L2 either serves it or forwards it to DRAM.',
    why:'Every L1 cache miss generates one. High miss rates flood the coherency bus and stall warps waiting for data ‚Äî the root cause of memory-bound kernel performance.' },
  'INV':    { name:'INV  (invalidation message)', color:'#f06595',
    what:'Coherency protocol message broadcast from the L2 to all SMs after a write. Any SM holding a Shared or Modified copy of the written cache line must drop it (set to Invalid). Happens on every write in Volta+ write-evict policy.',
    why:'Essential for correctness in multi-SM workloads sharing the same address. Without invalidation, SM 0 could read a stale cached copy of data that SM 1 just wrote. The cost is bus bandwidth ‚Äî atomic-heavy kernels saturate the bus with INVs.' },
  'DATA':   { name:'DATA  (cache line fill)', color:'#ffa94d',
    what:'The response to an RdReq ‚Äî the actual 128-byte cache line payload travelling back from L2 (or DRAM) to the requesting SM\'s L1. On arrival, the L1 fills the line and transitions its state to Shared.',
    why:'This latency is what the GPU hides with warp switching (latency tolerance). If a warp stalls on DATA, the scheduler immediately runs another ready warp. More resident warps = more latency hiding.' },
  'WR':     { name:'WR  (write request)', color:'#51cf66',
    what:'Cache-level write packet flowing from L1 down to L2 on a write-evict event, or from L2 down to the memory controller. Carries both the address and dirty data payload.',
    why:'Part of the write-evict chain: thread writes to L1 ‚Üí L1 drops the dirty line ‚Üí WR packet carries it to L2. If L2 is also full, another WR goes all the way to DRAM. Write-heavy kernels generate a constant stream of these.' },
  'RMW':    { name:'RMW  (read-modify-write)', color:'#f59e0b',
    what:'The atomic read-modify-write operation dispatched by the Apex Arbiter to L2 after serialisation. The arbiter has already granted exclusive access; this packet carries the operation type (e.g. ADD), operand, and SEQ# to the L2 slice, which performs the read, applies the operation, and writes the result atomically.',
    why:'By the time you see RMW, the hard work is already done ‚Äî the arbiter serialised competing requests so L2 never sees two RMWs to the same address simultaneously. Without the arbiter, two ATOMs reaching L2 at the same time would corrupt each other\'s result silently.' },
  'WB':     { name:'WB  (write-back)', color:'#ffa94d',
    what:'Write-Back ‚Äî a dirty L1 line is being evicted and its contents written back to L2. Different from a regular write in that it\'s triggered by cache capacity pressure, not the thread actively storing. Carries Modified ‚Üí Shared state transition.',
    why:'Happens automatically when the L1 is full and a new line must enter. Frequent write-backs indicate working sets larger than L1 ‚Äî a sign you should either reduce data reuse distances or tune the SMEM/L1 split.' },
  'EVICT':  { name:'EVICT  (L2 victim eviction)', color:'#339af0',
    what:'An L2 cache line is being evicted to DRAM because L2 is full. The victim line (chosen by LRU policy) travels through the NoC to the memory controller. Ampere\'s persistence window lets you protect chosen lines from eviction.',
    why:'L2 evictions to DRAM are slow (~400+ cycles). If your kernel constantly evicts from L2 it\'s DRAM-bandwidth-bound. Ampere\'s cudaAccessPolicyWindow lets you pin hot data (e.g., a weight matrix) to resist eviction.' },
  'STORE':  { name:'STORE  (DRAM write)', color:'#845ef7',
    what:'The final write command issued from a memory controller to an HBM/GDDR bank. At this point data leaves the on-chip world entirely. Row-activation (tRCD), column write (tCL), and precharge (tRP) timing all apply.',
    why:'DRAM writes are the slowest path in the hierarchy. You want kernels to rarely reach here ‚Äî maximize L2 residency and use cp.async or TMA to overlap DRAM reads with compute rather than blocking on them.' },
  'DSMEM':  { name:'DSMEM  (distributed shared memory)', color:'#22d3ee',
    what:'Hopper-only packet. An SM reads from another SM\'s shared memory within the same Thread Block Cluster. The request travels the cluster bus ‚Äî but stays entirely on-chip, never touching L2 or DRAM. ~20 cycle latency.',
    why:'Enables sub-L2 communication between cooperating SMs: e.g., overlapping tiles in FlashAttention-style kernels, or producer-consumer pipelines where one SM generates data another immediately consumes.' },
  'cp.async':{ name:'cp.async  (async global‚Üíshared copy)', color:'#22d3ee',
    what:'Ampere instruction. Initiates a DMA-style transfer from global memory directly into SMEM ‚Äî without allocating registers, without stalling the issuing warp. Multiple cp.async loads can be in flight simultaneously.',
    why:'The key to software pipelining (double-buffering) on Ampere+: issue cp.async for tile N+1 while computing on tile N. Completely hides DRAM latency. Critical for reaching peak FLOPS on matrix multiply kernels.' },
  'ATOM':   { name:'ATOM  (atomic request)', color:'#f59e0b',
    what:'An atomic operation packet (e.g. atomicAdd) leaving an SM and entering the Apex Arbiter. Carries: the target address, the operation type (ADD/CAS/MIN/MAX), the operand value, and the SM source ID. The arbiter stamps a SEQ# on it immediately.',
    why:'Atomics are the only safe way for concurrent threads to update shared memory without races. The cost is serialization ‚Äî all atomics to the same address queue through the arbiter one at a time. See the atomicAdd scenario to watch this unfold.' },
  'GRANT':  { name:'GRANT  (arbiter grant signal)', color:'#51cf66',
    what:'Apex Arbiter signal sent back to the SM whose ATOM request just reached the front of the queue. Tells the SM: "you now have exclusive access to this cache line ‚Äî proceed with the read-modify-write." The L2 cache line is locked until ACK is received.',
    why:'The grant/ack protocol prevents two SMs from simultaneously modifying the same address. Without it, atomicAdd would not be atomic ‚Äî two SMs could both read the value, both add to it, and one result would be silently lost.' },
  'ACK':    { name:'ACK  (atomic acknowledgement)', color:'#f59e0b',
    what:'Returned by L2 to the Arbiter after the atomic read-modify-write is complete. The arbiter logs this in the ROB under the original SEQ#, marks the slot done, and notifies the originating SM that the operation finished.',
    why:'The ACK closes the transaction loop. Until the arbiter receives ACK, the next SM in the queue cannot be granted access to that cache line address. High atomic contention means long chains of GRANT ‚Üí op ‚Üí ACK cycles.' },
  'SEQ':    { name:'SEQ#  (sequence number)', color:'#fbbf24',
    what:'A monotonically incrementing transaction ID stamped by the Apex Arbiter on every incoming ATOM request. Travels with the request all the way to L2 and back. The ROB uses it to match returning ACKs to the correct waiting SM.',
    why:'Without sequence numbers, returning data has no way to identify which SM asked for it ‚Äî especially when L2 bank conflicts cause some atomics to complete before earlier-numbered ones. The ROB uses SEQ# to restore order before retiring.' },
  'SPILL':  { name:'SPILL  (register spill to L1)', color:'#fb923c',
    what:'A thread\'s live registers exceed the physical register file. The compiler spills excess values to L1 cache (and if L1 is full, the spill cascades to L2). The warp stalls until the spill completes.',
    why:'High occupancy reduces registers per thread, increasing spill risk. Spills consume L1 bandwidth and add ~28 cycles on L1 hit, ~200 cycles on L2 hit. Minimise by reducing thread count or splitting large kernels.' },
  'RELOAD': { name:'RELOAD  (register reload from L1/L2)', color:'#fb923c',
    what:'The compiler reloads a previously-spilled register value from L1 (or L2 on a miss) just before it is needed again.',
    why:'Every RELOAD stalls the critical path. If all resident warps are spilling simultaneously, the SM stalls completely. Visible as "register-limited" in CUDA occupancy calculators.' },
  'TILE':   { name:'TILE  (TMA bulk tile transfer)', color:'#22d3ee',
    what:'A multi-dimensional tensor tile transferred by the Tensor Memory Accelerator. The TMA engine handles all address arithmetic autonomously ‚Äî zero thread registers consumed, warp continues computing immediately.',
    why:'TMA enables true compute-memory overlap on Hopper. Issue one TILE descriptor, compute on the previous tile, and the next tile arrives in SMEM for free. Critical for persistent kernels and WGMMA pipelines.' },
};

var ARCHS = {
  pascal: {
    name:'Pascal', gen:'SM 6.1', year:2016, color:'#51cf66', example:'GTX 1080 Ti',
    smLabel:'SM',
    intro:"The last generation before unified L1. Pascal keeps things simple ‚Äî L1 is read-only for global memory, so there's zero coherency overhead at L1. Writes go straight to L2. Great for understanding the baseline before things got complex.",
      delta:"<strong>vs baseline:</strong> This is the reference point ‚Äî read-only L1, no coherency, writes bypass L1 entirely.",
    perf:{ smCount:28, l1Size:24, smemSize:96, l2Size:4096, bw:484, flops:11.3, memType:'GDDR5X', vram:11, tdp:250, l1Latency:28, l2Latency:200, dramLatency:400 },
    blocks:{
      l1:{ label:'L1 (24KB)', desc:'Read-only texture/data cache. NOT coherent with global stores.', state:true },
      texCache:{ label:'TEX$', desc:'Separate texture cache, read-only, ~24KB.' },
      sharedMem:{ label:'SMEM (48‚Äì96KB)', desc:'Separate physical SRAM from L1. Configurable split.', state:false },
      l2:{ label:'L2 Cache (3‚Äì4MB)', desc:'Unified, coherent. Point of coherence for all SMs.', size:'3‚Äì4MB' },
      coherencyBus:{ label:'Crossbar', desc:'Simple crossbar ‚Äî minimal coherency traffic since L1 is read-only.' },
      globalMem:{ label:'Global Memory', desc:'GDDR5/GDDR5X memory interface.' },
      hbm:{ label:'GDDR5X', desc:'High-speed GDDR, ~480 GB/s on 1080 Ti.' },
    },
    writePolicy:'Write-through (L1 is read-only for globals)',
    coherency:'None at L1 ‚Äî L2 is sole coherence point',
    keyChange:null,
  },
  volta: {
    name:'Volta', gen:'SM 7.0', year:2017, color:'#339af0', example:'V100',
    smLabel:'SM',
    intro:"The big unification. Volta merged L1 and texture cache into a single 128KB SRAM that's also shared with SMEM. L1 now caches global writes too, which means coherency actually matters ‚Äî enter write-evict and invalidation.",
      delta:"<strong>vs Pascal:</strong> L1 now caches writes. That means a dirty line in SM0 must be invalidated in SM1 ‚Äî the first time GPUs needed a real coherency protocol. Cost: every write triggers an INV broadcast to all SMs.",
    perf:{ smCount:80, l1Size:128, smemSize:96, l2Size:6144, bw:900, flops:15.7, memType:'HBM2', vram:32, tdp:300, l1Latency:28, l2Latency:193, dramLatency:370 },
    blocks:{
      l1:{ label:'L1 + TEX (unified, 128KB)', desc:'L1 and texture cache merged.', state:true, changed:true },
      texCache:null,
      sharedMem:{ label:'SMEM (up to 96KB)', desc:'Shares the 128KB SRAM pool with L1.', changed:true },
      l2:{ label:'L2 Cache (6MB)', desc:'Larger L2. Write-evict policy from L1.', size:'6MB', changed:true },
      coherencyBus:{ label:'Coherency Bus', desc:'Now carries invalidation messages.' },
      globalMem:{ label:'Global Memory', desc:'HBM2 interface. 4 stacks.' },
      hbm:{ label:'HBM2', desc:'900 GB/s. Stacked DRAM.', changed:true },
    },
    writePolicy:'Write-evict (dirty L1 line dropped, write goes to L2)',
    coherency:'L1 invalidation via bus, L2 is coherence point',
    keyChange:'L1 + TEX unified, shared SRAM pool with SMEM, HBM2',
  },
  ampere: {
    name:'Ampere', gen:'SM 8.0', year:2020, color:'#ffa94d', example:'A100',
    smLabel:'SM',
    intro:"Ampere's headline: 10√ó larger L2 (40MB!) with software-controlled persistence, and async copy (cp.async) that moves data from global to shared memory without burning registers.",
      delta:"<strong>vs Volta:</strong> L2 grew 10√ó to 40MB and you can now pin data to stay resident (persistence window). cp.async decouples memory loads from register pressure ‚Äî overlapping compute and memory without stalling warps.",
    perf:{ smCount:108, l1Size:192, smemSize:164, l2Size:40960, bw:2039, flops:19.5, memType:'HBM2e', vram:80, tdp:400, l1Latency:33, l2Latency:200, dramLatency:400 },
    blocks:{
      l1:{ label:'L1 + TEX (192KB)', desc:'Larger unified L1/TEX cache.', state:true, changed:true },
      texCache:null,
      sharedMem:{ label:'SMEM (up to 164KB)', desc:'Larger SMEM. cp.async bypasses register file.', changed:true },
      asyncCopy:{ label:'ASYNC COPY', desc:'cp.async: DMA-like transfer from global to shared, bypassing registers.', isNew:true },
      l2:{ label:'L2 Cache (40MB)', desc:'Massive L2. Persistence controls via cudaAccessPolicyWindow.', size:'40MB', changed:true },
      l2Persist:{ label:'L2 PERSIST', desc:'Software-controlled L2 data persistence.', isNew:true },
      coherencyBus:{ label:'Coherency Bus', desc:'Same write-evict L1 coherency as Volta.' },
      globalMem:{ label:'Global Memory', desc:'HBM2e interface. 5 stacks.' },
      hbm:{ label:'HBM2e', desc:'2 TB/s. 80GB.', changed:true },
    },
    writePolicy:'Write-evict (same as Volta)',
    coherency:'L1 write-evict + invalidation, L2 persistence controls',
    keyChange:'Async copy (cp.async), 10√ó larger L2 with persistence',
  },
  hopper: {
    name:'Hopper', gen:'SM 9.0', year:2022, color:'#845ef7', example:'H100',
    smLabel:'SM',
    intro:"Hopper introduces TMA (Tensor Memory Accelerator) ‚Äî a hardware DMA engine for complex tensor addressing ‚Äî and DSMEM, where SMs in a cluster can directly read each other's shared memory.",
      delta:"<strong>vs Ampere:</strong> TMA offloads tensor address math from threads to hardware ‚Äî freeing warps entirely during data movement. DSMEM lets SMs in a cluster share memory at SMEM latency (~20 cycles) rather than going through L2 (~200 cycles).",
    perf:{ smCount:132, l1Size:256, smemSize:228, l2Size:51200, bw:3352, flops:66.9, memType:'HBM3', vram:80, tdp:700, l1Latency:33, l2Latency:200, dramLatency:380 },
    blocks:{
      l1:{ label:'L1 + TEX (256KB)', desc:'Even larger unified cache with TMA support.', state:true, changed:true },
      texCache:null,
      sharedMem:{ label:'SMEM (up to 228KB)', desc:'Largest SMEM. DSMEM for cross-SM shared memory access.', changed:true },
      dsmem:{ label:'DSMEM', desc:'Distributed Shared Memory. SMs within a cluster can directly access each other\'s shared memory.', isNew:true },
      tma:{ label:'TMA', desc:'Tensor Memory Accelerator. Hardware DMA for bulk data transfers with tensor-aware addressing.', isNew:true },
      asyncCopy:{ label:'ASYNC COPY', desc:'Enhanced from Ampere with TMA integration.' },
      l2:{ label:'L2 Cache (50MB)', desc:'Larger still with improved persistence controls.', size:'50MB', changed:true },
      l2Persist:{ label:'L2 PERSIST', desc:'Refined from Ampere with better granularity.' },
      coherencyBus:{ label:'Cluster Bus', desc:'New cluster-level interconnect for DSMEM.', changed:true },
      globalMem:{ label:'Global Memory', desc:'HBM3 interface.' },
      hbm:{ label:'HBM3', desc:'3.35 TB/s. 80GB.', changed:true },
    },
    writePolicy:'Write-evict + TMA bulk transfers',
    coherency:'Cluster-level DSMEM coherency + L2 global coherence',
    keyChange:'TMA engine, Distributed Shared Memory (DSMEM), HBM3',
  },
  apex: {
    name:'Apex', gen:'SM 10.0', year:2026, color:'#f59e0b', example:'Concept',
    smLabel:'SM',
    intro:"A forward-looking architecture exploring three unsolved problems in GPU memory design. The headline addition: a hardware <strong>Atomic Arbiter</strong> with a visible request queue, sequence-numbered transactions, and a Reorder Buffer (ROB) to handle out-of-order returns. Also features a Coherency Directory replacing broadcast INV with targeted per-SM invalidation. None of these exist in shipping silicon yet ‚Äî but the problems they solve are very real.",
      delta:"<strong>vs Hopper:</strong> Atomics were always a black box ‚Äî requests raced into L2 and serialised invisibly. The Arbiter makes that visible: you see the queue fill, grants issue, RMWs fly, and the ROB reorder returns. The Coherency Directory eliminates the O(n) INV broadcast ‚Äî only SMs that actually hold a copy get notified. Both ideas exist in CPU design but not yet in shipping GPU silicon.",
    perf:{ smCount:144, l1Size:320, smemSize:256, l2Size:65536, bw:5000, flops:120, memType:'HBM4', vram:192, tdp:1000, l1Latency:25, l2Latency:160, dramLatency:350 },
    blocks:{
      l1:{ label:'L1 + TEX (320KB)', desc:'Enlarged unified L1 with lower latency predictor logic.', state:true, changed:true },
      texCache:null,
      sharedMem:{ label:'SMEM (up to 256KB)', desc:'Larger SMEM with hardware bank-conflict detection.', changed:true },
      warpScheduler:{ label:'WARP SCHED', desc:'Explicit warp scheduler sub-unit. Tracks stall reasons per warp ‚Äî memory, dependency, branch ‚Äî and uses them to pick the best next warp to run. Makes latency hiding observable.', isNew:true },
      arbiter:{ label:'ATOMIC ARBITER', desc:'Hardware arbiter serializing atomic operations. Assigns a sequence number to every atomic request, queues up to 6 pending ops, and grants them FIFO (arrival order). A Reorder Buffer (ROB) holds returning data until it can be retired in order.', isNew:true },
      l2:{ label:'L2 Cache (64MB)', desc:'Larger L2 with per-address owner tracking for the coherency directory.', size:'64MB', changed:true },
      cohDir:{ label:'COHERENCY DIR', desc:'Directory replacing broadcast INV. Tracks which SMs hold a copy of each cache line. Writes only send INV to SMs that actually have a copy ‚Äî O(sharers) instead of O(all SMs). Critical for scaling to 256+ SM counts.', isNew:true },
      coherencyBus:{ label:'Targeted Inval. Bus', desc:'Bus now carries targeted (not broadcast) INV messages. Only SMs listed in the directory receive INV ‚Äî massive bandwidth saving at high SM counts.', changed:true },
      globalMem:{ label:'Global Memory', desc:'HBM4 interface. 8 stacks, 5 TB/s.' },
      hbm:{ label:'HBM4', desc:'5 TB/s. 192GB. Next-generation stacked DRAM.', changed:true },
    },
    writePolicy:'Write-evict + arbiter-serialized atomics',
    coherency:'Directory-based targeted INV + ROB-ordered atomic returns',
    keyChange:'Atomic Arbiter with ROB, Coherency Directory, Warp Scheduler',
  }
};

var currentArch = 'pascal';
var prevArch = null;
var stats = { hits:0, misses:0, inv:0, wb:0 };
var autoMode = true, autoTimer = 0;
var particles = [], flashEffects = [], stepTimers = [], bubbles = [];
var SPEED_SCALE = 0.55;  // global multiplier ‚Äî all particle speeds divided by this; <1 = slower
var layout = {};

var NUM_LINES = 16;
var cacheState = [];
// L2 line state: 0=empty, 1=clean, 2=dirty (mirroring L1 convention)
// Shared across all SMs ‚Äî L2 is unified. NUM_L2_LINES shown as occupancy bars.
var NUM_L2_LINES = 24;
var l2Lines = new Array(NUM_L2_LINES).fill(0);


// cache.js ‚Äî GPU Cache Coherency Demo

// Cache line state, L2 state helpers, resize, drawing utilities

function resize() {
  dpr = window.devicePixelRatio || 1;
  var r = canvas.getBoundingClientRect();
  // In sandboxed iframes getBCR and offsetWidth can both be 0 during first paint.
  // Fall back to the canvas's CSS-declared height (640px) and parent width, or
  // hardcoded safe defaults ‚Äî we'd rather draw at wrong size than not draw at all.
  var newW = (r.width  > 10 ? r.width  : null) ||
             (canvas.offsetWidth  > 10 ? canvas.offsetWidth  : null) ||
             (canvas.parentElement ? canvas.parentElement.offsetWidth : 0) ||
             800;
  var newH = (r.height > 10 ? r.height : null) ||
             (canvas.offsetHeight > 10 ? canvas.offsetHeight : null) ||
             640;
  if (newW === W && newH === H) return;
  W = newW; H = newH;
  canvas.width  = Math.round(W * dpr);
  canvas.height = Math.round(H * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  if (initialized) buildLayout();
}

window.addEventListener('resize', resize);

function rrect(x, y, w, h, r) {
  r = Math.min(r, w/2, h/2);
  ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y);
  ctx.arcTo(x+w,y,x+w,y+r,r); ctx.lineTo(x+w,y+h-r);
  ctx.arcTo(x+w,y+h,x+w-r,y+h,r); ctx.lineTo(x+r,y+h);
  ctx.arcTo(x,y+h,x,y+h-r,r); ctx.lineTo(x,y+r);
  ctx.arcTo(x,y,x+r,y,r); ctx.closePath();
}

function l2Fill(dirty) {
  var count = 10 + Math.floor(Math.random() * 10);
  for (var i = 0; i < NUM_L2_LINES; i++) l2Lines[i] = i < count ? (dirty ? 2 : 1) : 0;
  // shuffle
  for (var j = NUM_L2_LINES-1; j > 0; j--) {
    var k = Math.floor(Math.random()*(j+1));
    var t = l2Lines[j]; l2Lines[j]=l2Lines[k]; l2Lines[k]=t;
  }
}
// Add exactly one clean slot ‚Äî used on a single cache line read hit
function l2AbsorbOne() {
  // First try to fill an empty slot
  for (var i = 0; i < NUM_L2_LINES; i++) {
    if (l2Lines[i] === 0) { l2Lines[i] = 1; return; }
  }
  // L2 full: silently refresh first clean line (already present, just reused)
  for (var i2 = 0; i2 < NUM_L2_LINES; i2++) {
    if (l2Lines[i2] === 1) { l2Lines[i2] = 1; return; }
  }
  // All dirty ‚Äî overwrite first with clean
  l2Lines[0] = 1;
}
function l2Absorb() {
  // Mark some empty slots as clean ‚Äî data written to L2
  var filled = 0;
  for (var i = 0; i < NUM_L2_LINES; i++) if (l2Lines[i] > 0) filled++;
  var empty = NUM_L2_LINES - filled;
  var toFill = Math.min(empty, 2 + Math.floor(Math.random()*3));
  var added = 0;
  for (var i2 = 0; i2 < NUM_L2_LINES && added < toFill; i2++) {
    if (l2Lines[i2] === 0) { l2Lines[i2] = 1; added++; }
  }
}
// Write-evict/write-through: dirty line arrives at L2
function l2AbsorbDirty() {
  for (var i = 0; i < NUM_L2_LINES; i++) {
    if (l2Lines[i] === 0) { l2Lines[i] = 2; return; }
  }
  for (var i2 = 0; i2 < NUM_L2_LINES; i2++) {
    if (l2Lines[i2] === 1) { l2Lines[i2] = 2; return; }
  }
}
function l2Dirty() {
  // Mark a clean line dirty ‚Äî guaranteed to mark at least one
  for (var i = 0; i < NUM_L2_LINES; i++) {
    if (l2Lines[i] === 1) { l2Lines[i] = 2; return; }
  }
  for (var i2 = 0; i2 < NUM_L2_LINES; i2++) {
    if (l2Lines[i2] === 0) { l2Lines[i2] = 2; return; }
  }
}
function l2Evict() {
  // Remove the first dirty line ‚Äî evicted victim going to DRAM
  for (var i = 0; i < NUM_L2_LINES; i++) {
    if (l2Lines[i] === 2) { l2Lines[i] = 0; return; }
  }
  // No dirty line ‚Äî evict a clean line (capacity eviction)
  for (var i2 = 0; i2 < NUM_L2_LINES; i2++) {
    if (l2Lines[i2] === 1) { l2Lines[i2] = 0; return; }
  }
}

function initCacheState() {
  cacheState = [];
  l2Lines = new Array(NUM_L2_LINES).fill(0);
  var n = layout.sms ? layout.sms.length : 4;
  for (var i = 0; i < n; i++) {
    // Baseline ~75-82%: registers are nearly always heavily allocated on a real GPU kernel.
    // Each resident warp has a fixed compile-time register allocation ‚Äî the file is never "empty".
    var base = 0.72 + Math.random() * 0.10;
    cacheState.push({
      l1:   new Array(NUM_LINES).fill(0),
      smem: new Array(NUM_LINES).fill(0),
      regsPressure: base,
      regsPressureTarget: base,
    });
  }
}

// Set register pressure target for an SM ‚Äî animates smoothly in draw loop
function setRegPressure(smIdx, target) {
  if (!cacheState[smIdx]) return;
  cacheState[smIdx].regsPressureTarget = Math.max(0, Math.min(1.15, target)); // allow slight overflow past 1
}

// Tick register pressure toward target ‚Äî call once per draw frame
function tickRegPressure(dt) {
  for (var i = 0; i < cacheState.length; i++) {
    var cs = cacheState[i];
    if (!cs) continue;
    var diff = cs.regsPressureTarget - cs.regsPressure;
    // Fast rise on spill (overflow is sudden), moderate decay back to loaded baseline
    var rate = diff > 0 ? 3.5 : 1.2;
    cs.regsPressure += diff * rate * dt;
  }
}

function fillL1Random(smIdx, dirty) {
  if (!cacheState[smIdx]) return;
  var lines = cacheState[smIdx].l1;
  var count = 6 + Math.floor(Math.random() * 8);
  for (var i = 0; i < NUM_LINES; i++) {
    lines[i] = i < count ? (dirty ? 2 : 1) : 0;
  }
  for (var j = NUM_LINES - 1; j > 0; j--) {
    var k = Math.floor(Math.random() * (j + 1));
    var tmp = lines[j]; lines[j] = lines[k]; lines[k] = tmp;
  }
}

function setL1Dirty(smIdx) {
  if (!cacheState[smIdx]) return;
  var lines = cacheState[smIdx].l1;
  var filled = lines.filter(function(v){ return v > 0; }).length;
  if (filled < 4) { fillL1Random(smIdx, false); }
  var dirtied = 0;
  for (var i = 0; i < NUM_LINES && dirtied < 3; i++) {
    if (lines[i] === 1 && Math.random() > 0.5) { lines[i] = 2; dirtied++; }
  }
  if (dirtied === 0) { lines[Math.floor(Math.random()*NUM_LINES)] = 2; }
}

function invalidateL1(smIdx) {
  if (!cacheState[smIdx]) return;
  cacheState[smIdx].l1 = new Array(NUM_LINES).fill(0);
}
function invalidateL1Lines(smIdx, count) {
  if (!cacheState[smIdx]) return;
  var lines = cacheState[smIdx].l1;
  count = count || 1;
  var occupied = [];
  for (var i = 0; i < NUM_LINES; i++) { if (lines[i] > 0) occupied.push(i); }
  for (var j = occupied.length - 1; j > 0; j--) {
    var k = Math.floor(Math.random() * (j + 1));
    var tmp = occupied[j]; occupied[j] = occupied[k]; occupied[k] = tmp;
  }
  var toDrop = Math.min(count, occupied.length);
  for (var d = 0; d < toDrop; d++) { lines[occupied[d]] = 0; }
}

function writebackL1(smIdx) {
  if (!cacheState[smIdx]) return;
  var lines = cacheState[smIdx].l1;
  for (var i = 0; i < NUM_LINES; i++) { if (lines[i] === 2) lines[i] = 1; }
}

function fillSmem(smIdx) {
  if (!cacheState[smIdx]) return;
  var lines = cacheState[smIdx].smem;
  var count = 8 + Math.floor(Math.random() * 7);
  for (var i = 0; i < NUM_LINES; i++) lines[i] = i < count ? 1 : 0;
  for (var j = NUM_LINES - 1; j > 0; j--) {
    var kk = Math.floor(Math.random() * (j + 1));
    var tt = lines[j]; lines[j] = lines[kk]; lines[kk] = tt;
  }
}

function getCacheStats(smIdx, kind) {
  if (!cacheState[smIdx]) return { filled:0, dirty:0, empty:NUM_LINES };
  var arr = cacheState[smIdx][kind];
  var filled = 0, dirty = 0;
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === 1) filled++;
    else if (arr[i] === 2) { filled++; dirty++; }
  }
  return { filled: filled, dirty: dirty, empty: NUM_LINES - filled };
}

var hoveredBlock = null;
var selectedBlock = null;
var connLines = [];
var mouseX = 0, mouseY = 0;
var lastClientX = 0, lastClientY = 0;

// Phase names for display
var ARB_PHASES = {
  queued:    { label: 'QUEUED',    color: '#f59e0b', desc: 'Waiting in request queue for grant' },
  granted:   { label: 'GRANTED',   color: '#51cf66', desc: 'Grant issued ‚Äî SM has exclusive access' },
  rmw:       { label: 'RMW‚ÜíL2',   color: '#339af0', desc: 'Read-Modify-Write in progress at L2' },
  ack:       { label: 'ACK‚ÜêL2',   color: '#ffa94d', desc: 'Acknowledgement returning from L2' },
  retiring:  { label: 'RETIRING',  color: '#a78bfa', desc: 'ROB retiring ‚Äî data routing to SM' },
};
var hitRects = [];


// tooltip.js ‚Äî GPU Cache Coherency Demo

// Hit testing, block selection, tooltip rendering

function buildHitRects() {
  hitRects = [];
  for (var si = 0; si < layout.sms.length; si++) {
    var sm = layout.sms[si];
    for (var bi = 0; bi < sm.sub.length; bi++) {
      var b = sm.sub[bi];
      hitRects.push({ type: b.type, x: b.x, y: b.y, w: b.w, h: b.h, smIdx: si, label: b.label });
    }
  }
  if (layout.l2) hitRects.push({ type: 'l2', x: layout.l2.x, y: layout.l2.y, w: layout.l2.w, h: layout.l2.h });
  if (layout.l2Persist) hitRects.push({ type: 'l2Persist', x: layout.l2Persist.x, y: layout.l2Persist.y, w: layout.l2Persist.w, h: layout.l2Persist.h });
  if (layout.arbiter) hitRects.push({ type: 'arbiter', x: layout.arbiter.x, y: layout.arbiter.y, w: layout.arbiter.w, h: layout.arbiter.h });
  if (layout.cohDir) hitRects.push({ type: 'cohDir', x: layout.cohDir.x, y: layout.cohDir.y, w: layout.cohDir.w, h: layout.cohDir.h });
  if (layout.bus) hitRects.push({ type: 'bus', x: layout.bus.x1, y: layout.bus.y - 12, w: layout.bus.x2 - layout.bus.x1, h: 24 });
  if (layout.globalMem) hitRects.push({ type: 'globalMem', x: layout.globalMem.x, y: layout.globalMem.y, w: layout.globalMem.w, h: layout.globalMem.h });
  if (layout.hbm) hitRects.push({ type: 'hbm', x: layout.hbm.x, y: layout.hbm.y, w: layout.hbm.w, h: layout.hbm.h });
}

function hitTest(mx, my) {
  for (var i = hitRects.length - 1; i >= 0; i--) {
    var r = hitRects[i];
    if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) return r;
  }
  return null;
}

function getBlockCenter(type, smIdx) {
  if (type === 'l2') return { x: layout.l2.x + layout.l2.w/2, y: layout.l2.y + layout.l2.h/2 };
  if (type === 'l2Persist') return { x: layout.l2Persist.x + layout.l2Persist.w/2, y: layout.l2Persist.y + layout.l2Persist.h/2 };
  if (type === 'arbiter' && layout.arbiter) return { x: layout.arbiter.x + layout.arbiter.w/2, y: layout.arbiter.y + layout.arbiter.h/2 };
  if (type === 'cohDir' && layout.cohDir) return { x: layout.cohDir.x + layout.cohDir.w/2, y: layout.cohDir.y + layout.cohDir.h/2 };
  if (type === 'bus') return { x: (layout.bus.x1 + layout.bus.x2)/2, y: layout.bus.y };
  if (type === 'globalMem') return { x: layout.globalMem.x + layout.globalMem.w/2, y: layout.globalMem.y + layout.globalMem.h/2 };
  if (type === 'hbm') return { x: layout.hbm.x + layout.hbm.w/2, y: layout.hbm.y + layout.hbm.h/2 };
  var targetSmIdx = (smIdx !== undefined && smIdx !== null) ? smIdx : 0;
  for (var si = 0; si < layout.sms.length; si++) {
    var sm = layout.sms[si];
    for (var bi = 0; bi < sm.sub.length; bi++) {
      var b = sm.sub[bi];
      if (b.type === type && si === targetSmIdx) return { x: b.x + b.w/2, y: b.y + b.h/2 };
    }
  }
  for (var si2 = 0; si2 < layout.sms.length; si2++) {
    for (var bi2 = 0; bi2 < layout.sms[si2].sub.length; bi2++) {
      if (layout.sms[si2].sub[bi2].type === type) {
        var bb = layout.sms[si2].sub[bi2];
        return { x: bb.x + bb.w/2, y: bb.y + bb.h/2 };
      }
    }
  }
  return null;
}

function getBlockRect(type, smIdx) {
  for (var i = 0; i < hitRects.length; i++) {
    var r = hitRects[i];
    if (r.type === type && (smIdx === undefined || r.smIdx === smIdx)) return r;
  }
  return null;
}

var connLineAnim = 0;
var SM_LOCAL_TYPES = { regs:1, l1:1, texCache:1, smem:1, tma:1, dsmem:1, async:1 };

function buildConnLines(blockType, smIdx) {
  var info = BLOCK_INFO[blockType];
  if (!info || !info.connects) return;
  connLines = [];
  var from = getBlockCenter(blockType, smIdx);
  if (!from) return;
  for (var i = 0; i < info.connects.length; i++) {
    var conn = info.connects[i];
    var isGlobal = !SM_LOCAL_TYPES[conn.to];
    if (isGlobal) {
      var tc = getBlockCenter(conn.to, smIdx);
      if (tc) connLines.push({ from: from, to: tc, why: conn.why, arrow: conn.arrow, color: info.color });
    } else {
      var tc2 = getBlockCenter(conn.to, smIdx);
      if (tc2) connLines.push({ from: from, to: tc2, why: conn.why, arrow: conn.arrow, color: info.color });
    }
  }
  connLineAnim = 0;
}

canvas.addEventListener('mousemove', function(e) {
  var r = canvas.getBoundingClientRect();
  mouseX = e.clientX - r.left;
  mouseY = e.clientY - r.top;
  lastClientX = e.clientX;
  lastClientY = e.clientY;

  var pHit = hitTestParticleLabels(mouseX, mouseY);
  if (pHit && INSTRUCTION_INFO[pHit.key]) {
    showInstrTooltip(pHit.key, pHit.clientX, pHit.clientY - 20);
    hoveredBlock = null;
    hideTooltip();
    canvas.style.cursor = 'help';
    return;
  }
  hideInstrTooltip();

  var hit = hitTest(mouseX, mouseY);
  hoveredBlock = hit;
  canvas.style.cursor = hit ? 'pointer' : 'default';
  updateTooltip(hit, e.clientX, e.clientY);
});

canvas.addEventListener('mouseleave', function() {
  hoveredBlock = null;
  hideTooltip();
  hideInstrTooltip();
});

canvas.addEventListener('click', function(e) {
  var r = canvas.getBoundingClientRect();
  var mx = e.clientX - r.left;
  var my = e.clientY - r.top;
  var hit = hitTest(mx, my);
  if (hit) {
    if (selectedBlock && selectedBlock.type === hit.type && selectedBlock.smIdx === hit.smIdx) {
      clearSelection();
    } else {
      selectBlock(hit);
    }
  } else {
    clearSelection();
  }
});

function selectBlock(hit) {
  selectedBlock = hit;
  buildConnLines(hit.type, hit.smIdx);
  updateSelPanel(hit);
}

function clearSelection() {
  selectedBlock = null;
  connLines = [];
  document.getElementById('sel-panel').classList.remove('visible');
}

function updateSelPanel(hit) {
  var info = BLOCK_INFO[hit.type];
  if (!info) return;
  var panel = document.getElementById('sel-panel');
  panel.classList.add('visible');
  document.getElementById('sel-name').innerHTML = '<span style="color:' + info.color + '">' + info.name + '</span>';
  var descEl = document.getElementById('sel-desc');
  if (info.descHTML) {
    descEl.innerHTML = info.descHTML;
  } else {
    descEl.textContent = info.desc;
  }
  var connList = document.getElementById('conn-list');
  connList.innerHTML = '';
  if (!info.connects || info.connects.length === 0) {
    connList.innerHTML = '<div style="font-size:.75rem;color:var(--dim);padding:6px 0">No direct connections defined.</div>';
    return;
  }
  for (var i = 0; i < info.connects.length; i++) {
    var c = info.connects[i];
    var targetInfo = BLOCK_INFO[c.to] || {};
    var el = document.createElement('div');
    el.className = 'conn-item';
    el.innerHTML = '<span class="ci-arrow" style="color:' + (targetInfo.color||'#6b7094') + '">' + c.arrow + '</span><div class="ci-body"><span class="ci-target" style="color:' + (targetInfo.color||'#aaa') + '">' + (targetInfo.name || c.to) + '</span><span class="ci-why">' + c.why + '</span></div>';
    (function(connTo) {
      el.addEventListener('click', function(e) {
        e.stopPropagation();
        var targetHit = getBlockRect(connTo, hit.smIdx) || getBlockRect(connTo);
        if (targetHit) selectBlock(targetHit);
      });
    })(c.to);
    connList.appendChild(el);
  }
}

var tooltipEl = document.getElementById('block-tooltip');
var ttName = document.getElementById('tt-name');
var ttDot = document.getElementById('tt-dot');
var ttDesc = document.getElementById('tt-desc');
var ttMeta = document.getElementById('tt-meta');
var ttHint = document.getElementById('tt-hint');

var instrTooltipEl = null;
var instrHovered = null;

function getInstrEl() {
  if (!instrTooltipEl) instrTooltipEl = document.getElementById('instr-tooltip');
  return instrTooltipEl;
}

function showInstrTooltip(key, clientX, clientY) {
  var info = INSTRUCTION_INFO[key];
  if (!info) return;
  var el = getInstrEl();
  if (!el) return;
  if (instrHovered === key) { positionInstrTooltip(clientX, clientY); return; }
  instrHovered = key;
  document.getElementById('it-dot').style.background = info.color;
  el.style.borderColor = info.color + '40';
  document.getElementById('it-name').textContent = info.name;
  document.getElementById('it-what').textContent = info.what;
  document.getElementById('it-why').textContent = info.why;
  el.querySelector('.it-why-box').style.borderColor = info.color + '30';
  positionInstrTooltip(clientX, clientY);
  el.classList.add('visible');
}

function hideInstrTooltip() {
  instrHovered = null;
  var el = getInstrEl();
  if (el) el.classList.remove('visible');
}

function positionInstrTooltip(clientX, clientY) {
  var el = getInstrEl();
  if (!el) return;
  var tw = 320, th = 220;
  var vw = window.innerWidth, vh = window.innerHeight;
  var tx = clientX + 18;
  var ty = clientY - 24;
  if (tx + tw > vw - 10) tx = clientX - tw - 18;
  if (ty + th > vh - 10) ty = clientY - th + 10;
  if (ty < 8) ty = 8;
  el.style.left = tx + 'px';
  el.style.top  = ty + 'px';
}

var particleLabelRects = [];

function buildParticleLabelRects() {
  particleLabelRects = [];
  var cr = canvas.getBoundingClientRect();
  for (var i = 0; i < particles.length; i++) {
    var p = particles[i];
    if (!p.label || !p.alive) continue;
    var ppos = p._getPos ? p._getPos() : { x: p.from.x + (p.to.x - p.from.x) * (p.t||0), y: p.from.y + (p.to.y - p.from.y) * (p.t||0) };
    var cx2 = ppos.x, cy2 = ppos.y;
    var clientX = cr.left + cx2;
    var clientY = cr.top  + cy2;
    particleLabelRects.push({ key: p.label, cx: cx2, cy: cy2, clientX: clientX, clientY: clientY });
  }
}

function hitTestParticleLabels(mx, my) {
  var HIT_R = 36;
  for (var i = 0; i < particleLabelRects.length; i++) {
    var r = particleLabelRects[i];
    var dx = mx - r.cx;
    var dy = my - (r.cy - 12);
    if (dx*dx + dy*dy < HIT_R*HIT_R) return r;
  }
  return null;
}

var _lastTooltipType = null;

function updateTooltip(hit, clientX, clientY) {
  if (!hit) { hideTooltip(); return; }
  var info = BLOCK_INFO[hit.type];
  if (!info) { hideTooltip(); return; }

  // Clear skeleton when block type changes so stale DOM nodes don't leak between types
  var typeKey = hit.type + (hit.smIdx !== undefined ? '-' + hit.smIdx : '');
  if (typeKey !== _lastTooltipType) {
    ttMeta.innerHTML = '';
    _lastTooltipType = typeKey;
  }

  ttName.textContent = info.name;
  ttDot.style.background = info.color;
  tooltipEl.style.borderColor = info.color + '50';
  ttDesc.textContent = info.desc;

  var isCacheBlock = (hit.type === 'l1' || hit.type === 'smem') && hit.smIdx !== undefined;
  var isL2Block = hit.type === 'l2';
  var isArbiterBlock = hit.type === 'arbiter';
  var isCohDirBlock = hit.type === 'cohDir';

  if (isL2Block) {
    tooltipEl.classList.remove('tt-wide');
    // Build skeleton once ‚Äî recognised by sentinel id
    if (!document.getElementById('tt-l2-fill-label')) {
      var arch = ARCHS[currentArch];
      var smStateRows = '';
      for (var ssi = 0; ssi < layout.sms.length; ssi++) {
        smStateRows +=
          '<div id="tt-l2-sm-' + ssi + '" style="display:flex;align-items:center;gap:4px;padding:2px 0">' +
            '<span style="font-family:JetBrains Mono,monospace;font-size:.58rem;color:#6b7090;min-width:28px">SM' + ssi + '</span>' +
            '<span id="tt-l2-sm-dot-' + ssi + '" style="display:inline-block;width:8px;height:8px;border-radius:50%"></span>' +
            '<span id="tt-l2-sm-state-' + ssi + '" style="font-family:JetBrains Mono,monospace;font-size:.6rem"></span>' +
            '<span id="tt-l2-sm-tag-' + ssi + '" style="font-family:JetBrains Mono,monospace;font-size:.56rem;color:#3a3d55;margin-left:auto"></span>' +
          '</div>';
      }
      // Build N line cells for the grid
      var gridCells = '';
      for (var gi = 0; gi < NUM_L2_LINES; gi++) {
        gridCells += '<div id="tt-l2-cell-' + gi + '" style="flex:1;border-radius:2px;transition:background .15s"></div>';
      }
      ttMeta.innerHTML =
        // ‚îÄ‚îÄ Line grid header ‚îÄ‚îÄ
        '<div style="margin-bottom:6px">' +
          '<div style="display:flex;align-items:center;gap:8px;margin-bottom:5px">' +
            '<span style="font-family:JetBrains Mono,monospace;font-size:.6rem;color:#9095b0;text-transform:uppercase;letter-spacing:1px">L2 Lines (' + arch.blocks.l2.size + ')</span>' +
            '<span id="tt-l2-fill-label" style="font-family:JetBrains Mono,monospace;font-size:.68rem;font-weight:700;color:#ffa94d"></span>' +
            '<span id="tt-l2-dirty-label" style="font-family:JetBrains Mono,monospace;font-size:.62rem;color:#ffa94d;margin-left:2px"></span>' +
          '</div>' +
          // Live line grid
          '<div style="display:flex;gap:2px;height:10px;margin-bottom:4px">' + gridCells + '</div>' +
          // Legend
          '<div style="display:flex;gap:10px;font-family:JetBrains Mono,monospace;font-size:.56rem;margin-bottom:5px">' +
            '<span style="color:#339af0">‚ñ† clean</span>' +
            '<span style="color:#ffa94d">‚ñ† dirty</span>' +
            '<span style="color:#4a5080">‚ñ† empty</span>' +
          '</div>' +
          // Occupancy bar
          '<div style="height:3px;background:#1e2030;border-radius:2px;margin-bottom:8px">' +
            '<div id="tt-l2-occ-bar" style="height:3px;border-radius:2px;transition:width .2s,background .2s"></div>' +
          '</div>' +

          // ‚îÄ‚îÄ Lifecycle section ‚îÄ‚îÄ
          '<div style="border-top:1px solid #1e2030;padding-top:7px;margin-bottom:6px">' +
            '<div style="font-family:JetBrains Mono,monospace;font-size:.56rem;color:#9095b0;text-transform:uppercase;letter-spacing:1px;margin-bottom:5px">Cache Line Lifecycle</div>' +
            // How lines go clean
            '<div style="margin-bottom:4px">' +
              '<div style="font-family:JetBrains Mono,monospace;font-size:.58rem;font-weight:700;color:#339af0;margin-bottom:1px">Clean (blue)</div>' +
              '<div style="font-family:JetBrains Mono,monospace;font-size:.56rem;color:#6b7090;line-height:1.5">Filled on SM read miss (RdReq ‚Üí L2 ‚Üí DATA). Shared read-only across SMs ‚Äî any number of SMs can hold a Shared copy simultaneously.</div>' +
            '</div>' +
            // How lines go dirty
            '<div style="margin-bottom:4px">' +
              '<div style="font-family:JetBrains Mono,monospace;font-size:.58rem;font-weight:700;color:#ffa94d;margin-bottom:1px">Dirty (orange)</div>' +
              '<div style="font-family:JetBrains Mono,monospace;font-size:.56rem;color:#6b7090;line-height:1.5">Marked dirty on SM write (write-evict policy on Volta+) or write-back from L1. Dirty means L2 has the most recent value ‚Äî DRAM is stale. Must be flushed before eviction.</div>' +
            '</div>' +
            // Eviction
            '<div style="margin-bottom:4px">' +
              '<div style="font-family:JetBrains Mono,monospace;font-size:.58rem;font-weight:700;color:#845ef7;margin-bottom:1px">Eviction ‚Üí DRAM</div>' +
              '<div style="font-family:JetBrains Mono,monospace;font-size:.56rem;color:#6b7090;line-height:1.5">When L2 is &gt;75% full, the LRU victim is evicted. Clean lines are simply discarded. Dirty lines must be written to DRAM first (EVICT ‚Üí NoC ‚Üí MC ‚Üí HBM) ‚Äî adds ~400 cycles.</div>' +
            '</div>' +
            // Write policy
            '<div style="margin-bottom:6px">' +
              '<div style="font-family:JetBrains Mono,monospace;font-size:.58rem;font-weight:700;color:#6b7090;margin-bottom:1px">Write policy: <span id="tt-l2-writepolicy" style="color:#aaa"></span></div>' +
              '<div style="font-family:JetBrains Mono,monospace;font-size:.56rem;color:#6b7090;line-height:1.5"><span id="tt-l2-writepolicy-desc"></span></div>' +
            '</div>' +
          '</div>' +

          // ‚îÄ‚îÄ Latency row ‚îÄ‚îÄ
          '<div style="display:flex;gap:8px;margin-bottom:8px;font-family:JetBrains Mono,monospace;font-size:.56rem">' +
            '<span style="color:#6b7090">Hit latency:</span>' +
            '<span id="tt-l2-latency" style="color:#aaa"></span>' +
            '<span style="color:#6b7090;margin-left:auto">Miss ‚Üí DRAM:</span>' +
            '<span style="color:#ff6b6b">~400 cycles</span>' +
          '</div>' +

          // ‚îÄ‚îÄ Per-SM coherency state ‚îÄ‚îÄ
          '<div style="font-family:JetBrains Mono,monospace;font-size:.58rem;color:#9095b0;letter-spacing:.5px;margin-bottom:3px;text-transform:uppercase">Coherency state (L1 per SM)</div>' +
          smStateRows +
        '</div>';

      // Set static content
      var wpEl = document.getElementById('tt-l2-writepolicy');
      var wpdEl = document.getElementById('tt-l2-writepolicy-desc');
      var latEl = document.getElementById('tt-l2-latency');
      if (wpEl) wpEl.textContent = currentArch === 'pascal' ? 'write-through' : 'write-evict / write-back';
      if (wpdEl) wpdEl.textContent = currentArch === 'pascal'
        ? 'Pascal L1 is read-only ‚Äî stores bypass it and go straight to L2. L2 always has the authoritative copy, so L1 never needs to be invalidated on a write.'
        : 'Volta+: stores hit L1, which becomes Modified. L2 gets the data only when L1 evicts the dirty line (write-back) or on capacity pressure. Other SMs\' L1 copies are invalidated via INV.';
      if (latEl) latEl.textContent = '~' + (currentArch === 'pascal' ? '80' : currentArch === 'ampere' || currentArch === 'hopper' ? '50' : '60') + ' cycles';
    }
    refreshTooltipL2Data();
    ttHint.style.display = (selectedBlock && selectedBlock.type === 'l2') ? 'none' : 'flex';
    positionTooltip(clientX, clientY);
    tooltipEl.classList.add('visible');
    return;
  }

  if (isArbiterBlock) {
    tooltipEl.classList.add('tt-wide');
    // Render rich arbiter state in tooltip
    var arbQ = arbiterState.queue;
    var arbROB = arbiterState.rob;
    var arbOps = arbiterState.activeOps;
    var arbGrants = arbiterState.recentGrants;
    var latFracTT = arbiterState.contentionLevel;
    var cycTT = Math.round(2 + latFracTT * 30);
    var statusTT = arbQ.length >= QUEUE_CAPACITY - 2 ? 'SATURATED' : arbiterState.active ? 'ACTIVE' : 'IDLE';
    var statusColor = arbQ.length >= QUEUE_CAPACITY - 2 ? '#ff6b6b' : arbiterState.active ? '#fbbf24' : '#4a5080';

    // ‚îÄ‚îÄ Live ops table ‚Äî what each in-flight op is doing RIGHT NOW ‚îÄ‚îÄ
    var liveOpsHtml = '';
    if (arbOps.length === 0) {
      liveOpsHtml = '<div style="color:#4a5080;font-size:.6rem;padding:2px 0">No ops in flight</div>';
    } else {
      for (var tao = 0; tao < Math.min(arbOps.length, 6); tao++) {
        var aop = arbOps[tao];
        var ph = ARB_PHASES[aop.phase] || ARB_PHASES.queued;
        var elapsed = Math.round((Date.now() - aop.phaseStart) / 10); // in ~cycles (10ms ‚âà 1 notional cycle)
        var phaseBar = '';
        // 5-step pipeline indicator
        var phases = ['queued','granted','rmw','ack','retiring'];
        var curPhaseIdx = phases.indexOf(aop.phase);
        for (var pp = 0; pp < phases.length; pp++) {
          var ppActive = pp === curPhaseIdx;
          var ppDone = pp < curPhaseIdx;
          var ppColor = ppDone ? '#51cf6660' : ppActive ? ph.color : '#2a2d3a';
          phaseBar += '<span style="display:inline-block;width:14px;height:4px;border-radius:2px;background:'+ppColor+';margin-right:2px"></span>';
        }
        liveOpsHtml +=
          '<div style="display:flex;align-items:center;gap:6px;padding:3px 0;border-bottom:1px solid #1e2030">' +
            '<span style="font-family:JetBrains Mono,monospace;font-size:.58rem;color:#f59e0b;min-width:28px">#'+aop.seq+'</span>' +
            '<span style="font-family:JetBrains Mono,monospace;font-size:.58rem;color:#e0e2ec;min-width:22px">SM'+aop.smIdx+'</span>' +
            '<span style="font-family:JetBrains Mono,monospace;font-size:.58rem;font-weight:700;color:'+ph.color+';min-width:64px">'+ph.label+'</span>' +
            '<span style="flex:1">'+phaseBar+'</span>' +
            '<span style="font-family:JetBrains Mono,monospace;font-size:.54rem;color:#6b7090">'+elapsed+'œÑ</span>' +
          '</div>';
      }
    }

    // ‚îÄ‚îÄ ROB slots ‚îÄ‚îÄ
    var robSlots = '';
    for (var trs = 0; trs < 6; trs++) {
      var tre = trs < arbROB.length ? arbROB[trs] : null;
      var rstate = tre ? tre.state : '';
      var rcls = 'tt-arb-rob-slot' + (rstate==='pending'?' pend':rstate==='complete'?' comp':rstate==='retiring'?' retr':rstate==='done'?' done':'');
      var robLabel = tre ? '#'+tre.seq : '‚Äî';
      robSlots += '<div class="'+rcls+'" title="'+rstate+'">'+robLabel+'</div>';
    }

    // ‚îÄ‚îÄ Queue slots ‚îÄ‚îÄ
    var qSlots = '';
    for (var tqs = 0; tqs < 6; tqs++) {
      var tqe = tqs < arbQ.length ? arbQ[tqs] : null;
      var cls = tqe ? 'tt-arb-slot occ' : 'tt-arb-slot';
      qSlots += '<div class="'+cls+'">'+(tqe ? '#'+tqe.seq : '‚Äî')+'</div>';
    }

    // ‚îÄ‚îÄ Grant log ‚îÄ‚îÄ
    var grantHtml = '';
    if (arbGrants.length === 0) {
      grantHtml = '<span style="color:#4a5080">No grants yet ‚Äî run atomicAdd scenario</span>';
    } else {
      for (var tgi = 0; tgi < Math.min(arbGrants.length, 3); tgi++) {
        var tge = arbGrants[tgi];
        grantHtml += '‚Üí <span class="gs">#'+tge.seq+'</span> retired in <span class="gc">'+tge.cycles+' cyc</span><br>';
      }
    }

    var latBarPct = Math.round(latFracTT * 100);
    var latColor = latFracTT > 0.6 ? '#ff6b6b' : latFracTT > 0.3 ? '#f59e0b' : '#51cf66';

    ttMeta.innerHTML =
      // Status header
      '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:5px">' +
        '<span style="font-family:JetBrains Mono,monospace;font-size:.58rem;color:#6b7090">STATUS</span>' +
        '<span style="font-family:JetBrains Mono,monospace;font-size:.64rem;font-weight:700;letter-spacing:.5px;color:'+statusColor+'">‚óè '+statusTT+'</span>' +
      '</div>' +
      // Live ops ‚Äî the star of the show
      '<div class="tt-arb-section">' +
        '<div class="tt-arb-label">Live In-Flight Operations <span style="float:right;color:#f59e0b">SEQ#'+String(arbiterState.seqCounter).padStart(3,'0')+'</span></div>' +
        liveOpsHtml +
      '</div>' +
      // Queue + ROB side by side
      '<div class="tt-arb-section" style="display:grid;grid-template-columns:1fr 1fr;gap:8px">' +
        '<div>' +
          '<div class="tt-arb-label">Wait Queue</div>' +
          '<div class="tt-arb-queue">'+qSlots+'</div>' +
        '</div>' +
        '<div>' +
          '<div class="tt-arb-label">ROB</div>' +
          '<div class="tt-arb-rob">'+robSlots+'</div>' +
        '</div>' +
      '</div>' +
      // Contention bar
      '<div class="tt-arb-section">' +
        '<div class="tt-arb-label">Bus Contention <span style="float:right;color:'+latColor+'">~'+cycTT+' cyc/grant</span></div>' +
        '<div class="tt-arb-bar-bg"><div class="tt-arb-bar-fill" style="width:'+latBarPct+'%"></div></div>' +
        '<div style="font-family:JetBrains Mono,monospace;font-size:.54rem;color:#4a5080;margin-top:2px">'+
          'Idle: 2 cyc ¬∑ Contended: up to 32 cyc' +
        '</div>' +
      '</div>' +
      // Grant log
      '<div class="tt-arb-section">' +
        '<div class="tt-arb-label">Recent Completions <span style="float:right;color:#6b7090">'+arbiterState.grantCount+' total</span></div>' +
        '<div class="tt-arb-grant-log">'+grantHtml+'</div>' +
      '</div>';
    ttHint.style.display = 'none';
    positionTooltip(clientX, clientY);
    tooltipEl.classList.add('visible');
    return;
  } else {
    tooltipEl.classList.remove('tt-wide');
  }

  if (isCacheBlock) {
    if (!document.getElementById('tt-line-grid')) {
      // Build L1/SMEM skeleton with lifecycle info
      var isL1 = hit.type === 'l1';
      ttMeta.innerHTML =
        '<div style="margin-bottom:2px">' +
          '<div style="display:flex;align-items:center;gap:6px;margin-bottom:5px">' +
            '<span style="font-family:JetBrains Mono,monospace;font-size:.6rem;color:#9095b0;text-transform:uppercase;letter-spacing:1px">Cache Lines</span>' +
            '<span id="tt-fill-label" style="font-family:JetBrains Mono,monospace;font-size:.68rem;font-weight:700;color:'+info.color+'"></span>' +
            '<span id="tt-dirty-label" style="font-family:JetBrains Mono,monospace;font-size:.62rem;color:#51cf66"></span>' +
          '</div>' +
          '<div id="tt-line-grid" style="display:flex;gap:2px;height:10px;margin-bottom:5px"></div>' +
          '<div id="tt-state-label" style="font-size:.66rem;font-family:JetBrains Mono,monospace;margin-bottom:8px"></div>' +
          (isL1 ? (
            '<div style="border-top:1px solid #1e2030;padding-top:7px">' +
              '<div style="font-family:JetBrains Mono,monospace;font-size:.56rem;color:#9095b0;text-transform:uppercase;letter-spacing:1px;margin-bottom:5px">L1 Cache Line States</div>' +
              '<div style="margin-bottom:3px;font-family:JetBrains Mono,monospace;font-size:.56rem">' +
                '<span style="color:#339af0;font-weight:700">Shared</span>' +
                '<span style="color:#6b7090"> ‚Äî clean copy. Filled on read miss (RdReq ‚Üí L2 ‚Üí DATA). Multiple SMs can hold Shared simultaneously. Instantly invalidated if another SM writes to the same address.</span>' +
              '</div>' +
              '<div style="margin-bottom:3px;font-family:JetBrains Mono,monospace;font-size:.56rem">' +
                '<span style="color:#51cf66;font-weight:700">Modified</span>' +
                '<span style="color:#6b7090"> ‚Äî dirty. Set when SM writes to this line (write-evict). This SM has the only valid copy ‚Äî all other SMs\' copies are invalidated. Line must be written back to L2 before eviction.</span>' +
              '</div>' +
              '<div style="font-family:JetBrains Mono,monospace;font-size:.56rem">' +
                '<span style="color:#6b7090;font-weight:700">Invalid</span>' +
                '<span style="color:#6b7090"> ‚Äî empty. Either never loaded, or dropped by an INV message. Next access causes a miss ‚Äî RdReq goes to L2 to refill.</span>' +
              '</div>' +
            '</div>'
          ) : (
            '<div style="border-top:1px solid #1e2030;padding-top:7px;font-family:JetBrains Mono,monospace;font-size:.56rem;color:#6b7090;line-height:1.5">' +
              'SMEM is software-managed scratchpad. No coherency protocol ‚Äî the programmer controls all reads and writes. Access via LDS (load) and STS (store). 32 memory banks; simultaneous access to different banks costs 0 extra cycles.' +
            '</div>'
          )) +
        '</div>';
    }
    refreshTooltipCacheData(hit, info);
  } else {
    ttMeta.innerHTML = '';
    if (info.chips) {
      for (var i = 0; i < info.chips.length; i++) {
        var chip = info.chips[i];
        var span = document.createElement('span');
        span.className = 'tt-chip';
        span.style.background = chip.c + '20';
        span.style.color = chip.c;
        span.textContent = chip.t;
        ttMeta.appendChild(span);
      }
    }
  }

  ttHint.style.display = (selectedBlock && selectedBlock.type === hit.type) ? 'none' : 'flex';
  positionTooltip(clientX, clientY);
  tooltipEl.classList.add('visible');
}

// Live in-place refresh for L2 tooltip ‚Äî called every frame while L2 is hovered.
// Only touches .style properties and .textContent ‚Äî never rebuilds innerHTML.
function refreshTooltipL2Data() {
  var l2Filled = 0, l2Dirty = 0;
  for (var i = 0; i < NUM_L2_LINES; i++) {
    if (l2Lines[i] === 1) l2Filled++;
    else if (l2Lines[i] === 2) { l2Filled++; l2Dirty++; }
  }
  var l2Empty = NUM_L2_LINES - l2Filled;
  var l2OccPct = Math.round(l2Filled / NUM_L2_LINES * 100);

  // Fill / dirty labels
  var fillEl = document.getElementById('tt-l2-fill-label');
  if (fillEl) fillEl.textContent = l2Filled + '/' + NUM_L2_LINES + ' filled';
  var dirtyEl = document.getElementById('tt-l2-dirty-label');
  if (dirtyEl) dirtyEl.textContent = l2Dirty > 0 ? l2Dirty + ' dirty' : '';

  // Line cells ‚Äî update background in-place so CSS transition fires
  for (var gi = 0; gi < NUM_L2_LINES; gi++) {
    var cell = document.getElementById('tt-l2-cell-' + gi);
    if (!cell) continue;
    var lv = l2Lines[gi];
    cell.style.background = lv === 2 ? '#ffa94d' : lv === 1 ? '#339af060' : '#1e2030';
  }

  // Occupancy bar
  var bar = document.getElementById('tt-l2-occ-bar');
  if (bar) {
    bar.style.width = l2OccPct + '%';
    bar.style.background = l2OccPct > 80 ? '#ff6b6b' : '#ffa94d';
  }

  // Per-SM coherency state rows
  for (var ssi = 0; ssi < layout.sms.length; ssi++) {
    var st = layout.sms[ssi].l1.state;
    var sc = st === 'modified' ? '#51cf66' : st === 'shared' ? '#339af0' : '#4a5080';
    var sl = st === 'modified' ? '[M]' : st === 'shared' ? '[S]' : '[I]';
    var dotEl = document.getElementById('tt-l2-sm-dot-' + ssi);
    var stEl  = document.getElementById('tt-l2-sm-state-' + ssi);
    var tagEl = document.getElementById('tt-l2-sm-tag-' + ssi);
    if (dotEl) dotEl.style.background = sc;
    if (stEl)  { stEl.style.color = sc; stEl.textContent = st; }
    if (tagEl) tagEl.textContent = sl;
  }
}

function refreshTooltipCacheData(hit, info) {
  if (!hit) return;
  var inf = info || BLOCK_INFO[hit.type];
  if (!inf) return;
  var kind = hit.type === 'l1' ? 'l1' : 'smem';
  if (hit.type !== 'l1' && hit.type !== 'smem') return;

  var cs = getCacheStats(hit.smIdx, kind);
  var arr = cacheState[hit.smIdx] ? cacheState[hit.smIdx][kind] : [];

  var fillLbl = document.getElementById('tt-fill-label');
  if (fillLbl) fillLbl.textContent = cs.filled + '/' + NUM_LINES + ' filled';

  var dirtyLbl = document.getElementById('tt-dirty-label');
  if (dirtyLbl) dirtyLbl.textContent = cs.dirty > 0 ? cs.dirty + ' dirty' : '';

  var grid = document.getElementById('tt-line-grid');
  if (grid) {
    if (grid.children.length !== NUM_LINES) {
      grid.innerHTML = '';
      for (var li = 0; li < NUM_LINES; li++) {
        var sq = document.createElement('div');
        sq.style.cssText = 'flex:1;border-radius:2px;transition:background .12s';
        grid.appendChild(sq);
      }
    }
    for (var li2 = 0; li2 < NUM_LINES; li2++) {
      var lv = arr[li2] || 0;
      var lc;
      if (lv === 2)      lc = '#51cf66';
      else if (lv === 1) lc = hit.type === 'l1' ? inf.color + 'cc' : '#51cf6688';
      else               lc = '#1e2030';
      grid.children[li2].style.background = lc;
    }
  }

  var stateLbl = document.getElementById('tt-state-label');
  if (stateLbl && hit.type === 'l1') {
    var l1b = null;
    if (layout.sms[hit.smIdx]) {
      for (var bi = 0; bi < layout.sms[hit.smIdx].sub.length; bi++) {
        if (layout.sms[hit.smIdx].sub[bi].type === 'l1') { l1b = layout.sms[hit.smIdx].sub[bi]; break; }
      }
    }
    var st = l1b ? l1b.state : 'invalid';
    var stateLabel, stateColor;
    if (st === 'modified')      { stateLabel = '‚óè Modified ‚Äî has dirty data';  stateColor = '#51cf66'; }
    else if (st === 'shared')   { stateLabel = '‚óè Shared ‚Äî clean copy';        stateColor = '#5ab0f8'; }
    else                        { stateLabel = '‚óè Invalid ‚Äî empty';            stateColor = '#6b7090'; }
    stateLbl.style.color = stateColor;
    stateLbl.textContent = stateLabel;
  } else if (stateLbl && hit.type === 'smem') {
    var smFilled = cs.filled;
    stateLbl.style.color = smFilled > 0 ? '#6ee09a' : '#6b7090';
    stateLbl.textContent = smFilled > 0 ? '‚óè Active ‚Äî ' + smFilled + ' slots used' : '‚óè Empty ‚Äî no data loaded';
  }
}

function positionTooltip(clientX, clientY) {
  var vizRect = canvas.parentElement.getBoundingClientRect();
  var tx = clientX - vizRect.left + 14;
  var ty = clientY - vizRect.top - 12;
  var tw = 250, th = 160;
  if (tx + tw > vizRect.width - 10)  tx = clientX - vizRect.left - tw - 14;
  if (ty + th > vizRect.height - 10) ty = clientY - vizRect.top - th - 12;
  if (ty < 4) ty = 4;
  tooltipEl.style.left = tx + 'px';
  tooltipEl.style.top  = ty + 'px';
}

function hideTooltip() {
  tooltipEl.classList.remove('visible');
  _lastTooltipType = null;
}

// draw.js ‚Äî GPU Cache Coherency Demo

// Layout building, arch switching, all canvas rendering

function bubble(x, y, text, color, opts) {
  var o = opts || {};
  bubbles.push({ x:x, y:y-8, text:text, sub:o.sub||null, color:color, bg:(o.bg||color.slice(0,7))+'18', age:0, life:o.life||2.8, rise:o.rise||18, wobble:Math.random()*6, vx:0, vy:0 });
}

function updateDiffBanner() {
  var banner = document.getElementById('diff-banner');
  if (!prevArch || prevArch === currentArch) { banner.classList.remove('visible'); return; }
  var prev = ARCHS[prevArch], curr = ARCHS[currentArch];
  var parts = [];
  for (var k in curr.blocks) {
    var v = curr.blocks[k]; if (!v) continue;
    var prevBlock = prev.blocks[k];
    if (!prevBlock && v) parts.push('<span class="new-tag">+ ' + v.label + '</span>');
    else if (prevBlock && v.changed) parts.push('<span class="changed-tag">‚Üë ' + v.label + '</span>');
  }
  for (var k2 in prev.blocks) {
    var v2 = prev.blocks[k2]; if (!v2) continue;
    if (!curr.blocks[k2] || curr.blocks[k2] === null) parts.push('<span class="removed-tag">' + v2.label + '</span>');
  }
  if (curr.keyChange) parts.push('<br><span style="color:var(--dim)">Key: ' + curr.keyChange + '</span>');
  if (parts.length) {
    banner.innerHTML = '<strong style="color:' + curr.color + '">' + prev.name + ' ‚Üí ' + curr.name + ':</strong> ' + parts.join(' ¬∑ ');
    banner.classList.add('visible');
  } else { banner.classList.remove('visible'); }
}

function updateKeyCard() {
  var arch = ARCHS[currentArch];
  var prev = prevArch ? ARCHS[prevArch] : null;
  var html = '<h3>Diagram Key ‚Äî ' + arch.name + ' <span style="color:' + arch.color + ';font-weight:600">' + arch.example + '</span></h3>';
  var items = [
    { key:'l1', color:'var(--l1)', meta:'per-SM' },
    { key:'texCache', color:'#e599f7', meta:'per-SM' },
    { key:'sharedMem', color:'var(--smem)', meta:'per-SM' },
    { key:'warpScheduler', color:'#a78bfa', meta:'per-SM' },
    { key:'dsmem', color:'var(--new-block)', meta:'cluster' },
    { key:'tma', color:'var(--new-block)', meta:'per-SM' },
    { key:'asyncCopy', color:'var(--new-block)', meta:'engine' },
    { key:'arbiter', color:'#f59e0b', meta:'atomic ctrl' },
    { key:'cohDir', color:'#22d3ee', meta:'dir-based' },
    { key:'coherencyBus', color:'var(--coherency)', meta:'fabric' },
    { key:'l2', color:'var(--l2)', meta:'unified' },
    { key:'l2Persist', color:'var(--l2)', meta:'L2 ctrl' },
    { key:'globalMem', color:'var(--global)', meta:'interface' },
    { key:'hbm', color:'var(--dram)', meta:'off-chip' },
  ];
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    var block = arch.blocks[item.key];
    if (!block) continue;
    var badge = '';
    if (block.isNew) badge = '<span class="acc-badge-new">NEW</span>';
    else if (block.changed && prev) badge = '<span class="acc-badge-changed">CHANGED</span>';
    html += '<div class="acc-item" onclick="this.classList.toggle(\'open\')"><div class="acc-head"><div class="acc-dot" style="background:' + item.color + '"></div><span class="acc-title">' + block.label + badge + '</span><span class="acc-meta">' + item.meta + '</span><span class="acc-chev">‚ñ∏</span></div><div class="acc-body"><p>' + block.desc + '</p></div></div>';
  }
  html += '<div style="margin-top:10px;padding-top:8px;border-top:1px solid var(--border);font-size:.72rem;color:var(--dim)"><strong style="color:var(--text)">Write policy:</strong> ' + arch.writePolicy + '<br><strong style="color:var(--text)">Coherency:</strong> ' + arch.coherency + '</div>';
  document.getElementById('key-card').innerHTML = html;
}

function switchArch(arch) {
  if (arch === currentArch) return;
  prevArch = currentArch;
  currentArch = arch;
  var tabs = document.querySelectorAll('.arch-tab');
  for (var i = 0; i < tabs.length; i++) { tabs[i].classList.toggle('active', tabs[i].dataset.arch === arch); }
  clearSelection();
  resetAll(true);
  buildLayout();
  updateDiffBanner();
  updateKeyCard();
  updateArchIntro();
  updateScenarioButtons();
  logEvent('Switched to ' + ARCHS[arch].name + ' (' + ARCHS[arch].gen + ')', ARCHS[arch].color);
}

// Update scenario button labels and visibility based on current arch
function updateScenarioButtons() {
  var isPascal = currentArch === 'pascal';
  var isHopper = currentArch === 'hopper';
  var isAmpere = currentArch === 'ampere';
  var isApex   = currentArch === 'apex';
  var atomicBtn = document.getElementById('btn-atomic');
  if (atomicBtn) {
    atomicBtn.classList.remove('apex-only');
    atomicBtn.title = isApex
      ? 'Apex: arbiter-serialized atomicAdd with SEQ# + ROB'
      : 'Raw atomicAdd ‚Äî serializes inside L2 with no coordination (slower)';
  }
  var writeBtn = document.querySelector('[data-scenario="write"]');
  if (writeBtn) {
    writeBtn.textContent = isPascal ? 'SM Write (WT)' : 'SM Write';
    writeBtn.title = isPascal
      ? 'Pascal: writes bypass L1, go straight to L2 (write-through)'
      : 'Volta+: write hits L1 (Modified), INV fires to other SMs';
  }
  var cpBtn = document.getElementById('btn-cp-async');
  if (cpBtn) cpBtn.style.display = (isAmpere || isHopper) ? '' : 'none';
  var tmaBtn = document.getElementById('btn-tma-load');
  if (tmaBtn) tmaBtn.style.display = isHopper ? '' : 'none';
}

function updateArchIntro() {
  var arch = ARCHS[currentArch];
  var delta = arch.delta ? '<div class="arch-intro-delta">' + arch.delta + '</div>' : '';
  document.getElementById('arch-intro').innerHTML =
    '<div class="arch-intro-badge" style="background:' + arch.color + '20;color:' + arch.color + '">' + arch.name + ' ¬∑ ' + arch.example + '</div>' +
    '<div class="arch-intro-text">' + arch.intro + '</div>' +
    delta;
}

function buildLayout() {
  if (!W || !H) return;
  var cx = W/2;
  var mob = W < 500;
  var arch = ARCHS[currentArch];
  var smCount = mob ? 2 : (currentArch === 'hopper' ? 4 : (currentArch === 'pascal' ? 3 : (currentArch === 'apex' ? 4 : 4)));
  var margin = mob ? 12 : 30;
  var usable = W - margin*2;
  var smGap = mob ? 12 : 20;
  var smW = Math.min(110, (usable - (smCount-1)*smGap)/smCount);
  var smSubBlocks = 2;
  if (arch.blocks.texCache) smSubBlocks++;
  if (arch.blocks.tma) smSubBlocks++;
  if (arch.blocks.dsmem) smSubBlocks++;
  if (arch.blocks.asyncCopy && arch.blocks.asyncCopy.isNew) smSubBlocks++;
  if (arch.blocks.warpScheduler) smSubBlocks++;
  var smH = mob ? (80+smSubBlocks*18) : (90+smSubBlocks*22);
  var totalSmW = smCount*smW + (smCount-1)*smGap;
  var smStartX = cx - totalSmW/2;
  var smY = mob ? 16 : 30;

  layout.sms = [];
  for (var i = 0; i < smCount; i++) {
    var x = smStartX + i*(smW+smGap);
    var subY = smY + (mob ? 32 : 38);
    var subH = mob ? 18 : 22;
    var subPad = mob ? 4 : 5;
    var sub = [];
    sub.push({ type:'regs', x:x+6, y:subY+8, w:smW-12, h:10 });
    subY += 22;
    if (arch.blocks.texCache) {
      sub.push({ type:'texCache', x:x+6, y:subY, w:smW-12, h:subH, label:'TEX$' });
      subY += subH+subPad;
    }
    sub.push({ type:'l1', x:x+6, y:subY, w:smW-12, h:subH, label:arch.blocks.l1.label.split('(')[0].trim(), state:'invalid' });
    var l1Ref = sub[sub.length-1];
    subY += subH+subPad;
    sub.push({ type:'smem', x:x+6, y:subY, w:smW-12, h:subH, label:'SMEM' });
    subY += subH+subPad;
    if (arch.blocks.tma) {
      sub.push({ type:'tma', x:x+6, y:subY, w:smW-12, h:subH, label:'TMA' });
      subY += subH+subPad;
    }
    if (arch.blocks.dsmem) {
      sub.push({ type:'dsmem', x:x+6, y:subY, w:smW-12, h:subH, label:'DSMEM' });
      subY += subH+subPad;
    }
    if (arch.blocks.asyncCopy && (currentArch === 'ampere' || currentArch === 'hopper')) {
      sub.push({ type:'async', x:x+6, y:subY, w:smW-12, h:14, label:'cp.async' });
      subY += 14+subPad;
    }
    if (arch.blocks.warpScheduler) {
      sub.push({ type:'warpScheduler', x:x+6, y:subY, w:smW-12, h:subH, label:'WARP SCHED' });
      subY += subH+subPad;
    }
    var actualH = Math.max(smH, subY-smY+8);
    layout.sms.push({ x:x, y:smY, w:smW, h:actualH, label:arch.smLabel+' '+i, sub:sub, l1:l1Ref });
  }

  var maxSmBottom = 0;
  for (var j = 0; j < layout.sms.length; j++) { maxSmBottom = Math.max(maxSmBottom, layout.sms[j].y+layout.sms[j].h); }

  if (currentArch === 'hopper' && smCount > 1) {
    layout.cluster = { x1:smStartX-6, x2:smStartX+totalSmW+6, y1:smY-8, y2:maxSmBottom+8 };
  } else { layout.cluster = null; }

  var busY = maxSmBottom + (mob ? 30 : 40);
  layout.bus = { y:busY, x1:smStartX-15, x2:smStartX+totalSmW+15, label:currentArch==='hopper' ? 'CLUSTER BUS + COHERENCY' : (currentArch==='pascal' ? 'CROSSBAR' : 'COHERENCY BUS') };

  var l2W = Math.min(totalSmW*0.85, usable*0.78);
  var l2Y = busY + (mob ? 35 : 45);
  var l2H = mob ? 42 : 52;
  layout.l2 = { x:cx-l2W/2, y:l2Y, w:l2W, h:l2H };
  layout.l2Persist = (currentArch==='ampere'||currentArch==='hopper') ? { x:cx-l2W/2+6, y:l2Y+l2H-12, w:l2W-12, h:8 } : null;

  // Shared vars needed by both Apex and non-Apex paths
  var gmH = mob ? 52 : 62;
  var mcCount = mob ? 2 : (currentArch==='pascal' ? 3 : 4);
  var mcW = mob ? 36 : 44;

  // Apex-specific: Arbiter is a FULL-WIDTH block between bus and L2
  // cohDir is a sub-region INSIDE L2 (right portion)
  if (currentArch === 'apex') {
    var arbH = mob ? 56 : 68;
    var arbGap = mob ? 32 : 38;  // gap between arbiter and L2 ‚Äî enough for ACK particle travel
    // Arbiter and L2 span the full usable width on Apex
    var apexW = Math.min(usable * 0.92, totalSmW * 1.02);
    var apexX = cx - apexW/2;
    var newL2Y = l2Y + arbH + arbGap;
    layout.arbiter = { x: apexX, y: l2Y, w: apexW, h: arbH };
    // Shift l2 down to make room
    layout.l2 = { x: apexX, y: newL2Y, w: apexW, h: l2H };
    // cohDir is a sub-region inside l2 (right 35%)
    var cdW = Math.round(apexW * 0.35);
    layout.cohDir = { x: apexX + apexW - cdW - 6, y: newL2Y + 6, w: cdW, h: l2H - 12 };
    // Shift everything below l2 down too
    var cbY2 = newL2Y + l2H + (mob ? 16 : 22);
    layout.crossbar = { y: cbY2, x1: apexX-8, x2: apexX+apexW+8 };
    var gmY2 = cbY2 + (mob ? 22 : 30);
    var gmW2 = apexW;
    layout.globalMem = { x: apexX, y: gmY2, w: gmW2, h: gmH };
    var mcGap3 = (gmW2 - mcCount*mcW)/(mcCount+1);
    layout.mcs = [];
    for (var mi2 = 0; mi2 < mcCount; mi2++) {
      layout.mcs.push({ x: layout.globalMem.x+mcGap3+mi2*(mcW+mcGap3), y: gmY2+24, w: mcW, h: 14 });
    }
    var hbmY2 = gmY2 + gmH + (mob ? 16 : 22);
    var hbmW2 = gmW2*0.88;
    layout.hbm = { x: cx-hbmW2/2, y: hbmY2, w: hbmW2, h: mob ? 34 : 42, label: ARCHS[currentArch].blocks.hbm.label };
  } else {
    // Non-Apex: no arbiter, standard layout
    layout.arbiter = null;
    layout.cohDir = null;

    var cbY = l2Y+l2H+(mob ? 22 : 30);
    layout.crossbar = { y:cbY, x1:cx-l2W/2-8, x2:cx+l2W/2+8 };

    var gmW = Math.min(totalSmW*0.85, usable*0.82);
    var gmY = cbY + (mob ? 28 : 38);
    layout.globalMem = { x:cx-gmW/2, y:gmY, w:gmW, h:gmH };

    var mcGap2 = (gmW - mcCount*mcW)/(mcCount+1);
    layout.mcs = [];
    for (var mi = 0; mi < mcCount; mi++) {
      layout.mcs.push({ x:layout.globalMem.x+mcGap2+mi*(mcW+mcGap2), y:gmY+24, w:mcW, h:14 });
    }

    var hbmY = gmY+gmH+(mob ? 16 : 22);
    var hbmW = gmW*0.88;
    layout.hbm = { x:cx-hbmW/2, y:hbmY, w:hbmW, h:mob ? 34 : 42, label:ARCHS[currentArch].blocks.hbm.label };
  }

  buildHitRects();
  initCacheState();
}

function bezierPoint(p0, cp1, cp2, p1, t) {
  var mt = 1 - t;
  return {
    x: mt*mt*mt*p0.x + 3*mt*mt*t*cp1.x + 3*mt*t*t*cp2.x + t*t*t*p1.x,
    y: mt*mt*mt*p0.y + 3*mt*mt*t*cp1.y + 3*mt*t*t*cp2.y + t*t*t*p1.y,
  };
}

function drawConnLines(time) {
  if (connLines.length === 0) return;
  connLineAnim += 0.022;
  for (var i = 0; i < connLines.length; i++) {
    var cl = connLines[i];
    var dx = cl.to.x - cl.from.x;
    var dy = cl.to.y - cl.from.y;
    var dist = Math.sqrt(dx*dx + dy*dy);

    var isVertical = Math.abs(dy) > Math.abs(dx);
    var bow = Math.min(dist * 0.35, 60) * (i % 2 === 0 ? 1 : -1);
    var cp1, cp2;
    if (isVertical) {
      cp1 = { x: cl.from.x + bow, y: cl.from.y + dy * 0.3 };
      cp2 = { x: cl.to.x + bow,   y: cl.to.y   - dy * 0.3 };
    } else {
      cp1 = { x: cl.from.x + dx * 0.3, y: cl.from.y + bow };
      cp2 = { x: cl.to.x   - dx * 0.3, y: cl.to.y   + bow };
    }

    var alpha = 0.55 + Math.sin(connLineAnim * 2.5 + i * 1.2) * 0.2;
    var colorHex = cl.color + Math.round(alpha * 255).toString(16).padStart(2,'0');

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(cl.from.x, cl.from.y);
    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, cl.to.x, cl.to.y);
    ctx.strokeStyle = cl.color + '18';
    ctx.lineWidth = 7;
    ctx.setLineDash([]);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(cl.from.x, cl.from.y);
    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, cl.to.x, cl.to.y);
    ctx.strokeStyle = colorHex;
    ctx.lineWidth = 1.8;
    ctx.setLineDash([7, 5]);
    ctx.lineDashOffset = -connLineAnim * 28;
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.beginPath(); ctx.arc(cl.from.x, cl.from.y, 3.5, 0, Math.PI*2);
    ctx.fillStyle = cl.color; ctx.fill();
    ctx.beginPath(); ctx.arc(cl.from.x, cl.from.y, 6, 0, Math.PI*2);
    ctx.fillStyle = cl.color + '30'; ctx.fill();

    var tip  = bezierPoint({x:cl.from.x,y:cl.from.y}, cp1, cp2, {x:cl.to.x,y:cl.to.y}, 0.98);
    var tang = bezierPoint({x:cl.from.x,y:cl.from.y}, cp1, cp2, {x:cl.to.x,y:cl.to.y}, 0.93);
    var angle = Math.atan2(cl.to.y - tang.y, cl.to.x - tang.x);
    ctx.translate(cl.to.x, cl.to.y);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-9, -4.5);
    ctx.lineTo(-9, 4.5);
    ctx.closePath();
    ctx.fillStyle = cl.color + 'dd';
    ctx.fill();

    var travelT = (connLineAnim * 0.55 + i * 0.28) % 1.0;
    ctx.restore();
    var tp = bezierPoint({x:cl.from.x,y:cl.from.y}, cp1, cp2, {x:cl.to.x,y:cl.to.y}, travelT);
    ctx.beginPath(); ctx.arc(tp.x, tp.y, 4, 0, Math.PI*2);
    ctx.fillStyle = cl.color; ctx.fill();
    ctx.beginPath(); ctx.arc(tp.x, tp.y, 8, 0, Math.PI*2);
    ctx.fillStyle = cl.color + '28'; ctx.fill();
  }
}

function drawHoverHighlight() {
  if (!hoveredBlock) return;
  var r = hoveredBlock;
  ctx.save();
  rrect(r.x-3, r.y-3, r.w+6, r.h+6, 6);
  var info = BLOCK_INFO[r.type];
  var hcolor = info ? info.color : '#ffffff';
  ctx.strokeStyle = hcolor + 'cc';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.fillStyle = hcolor + '10';
  ctx.fill();
  ctx.restore();
}

function drawSelectionHighlight() {
  if (!selectedBlock) return;
  var r = selectedBlock;
  ctx.save();
  rrect(r.x-4, r.y-4, r.w+8, r.h+8, 7);
  var info = BLOCK_INFO[r.type];
  var scolor = info ? info.color : '#ffffff';
  var pulse = 0.6 + Math.sin(Date.now()/300) * 0.4;
  ctx.strokeStyle = scolor + Math.round(pulse * 255).toString(16).padStart(2,'0');
  ctx.lineWidth = 2.5;
  ctx.stroke();
  ctx.fillStyle = scolor + '15';
  ctx.fill();
  ctx.restore();
}

function drawFrame(time) {
  if (!initialized || !layout.sms) { requestAnimationFrame(drawFrame); return; }
  try {
    if (paused) {
      drawStaticFrame();
      requestAnimationFrame(drawFrame);
      return;
    }
    var dt = Math.min((time - lastTime)/1000, 0.05);
    lastTime = time;
    drawAnimatedFrame(dt, time);
    requestAnimationFrame(drawFrame);
  } catch(e) {
    // Surface any silent crash to the canvas so we can see it
    ctx.fillStyle = '#ff6b6b';
    ctx.font = '13px monospace';
    ctx.fillText('JS error: ' + e.message, 20, 40);
    ctx.fillText(e.stack ? e.stack.split('\n')[1] : '', 20, 60);
    requestAnimationFrame(drawFrame);
  }
}

function drawStaticFrame() {
  ctx.clearRect(0, 0, W, H);
  drawSceneContent(0, performance.now());
  if (hoveredBlock && (hoveredBlock.type === 'l1' || hoveredBlock.type === 'smem')) {
    refreshTooltipCacheData(hoveredBlock, BLOCK_INFO[hoveredBlock.type]);
  }
}

function drawAnimatedFrame(dt, time) {
  ctx.clearRect(0, 0, W, H);
  tickRegPressure(dt);
  drawSceneContent(dt, time);

  // Live tooltip refresh for cache blocks
  if (hoveredBlock && (hoveredBlock.type === 'l1' || hoveredBlock.type === 'smem')) {
    refreshTooltipCacheData(hoveredBlock, BLOCK_INFO[hoveredBlock.type]);
  }
  // Live tooltip refresh for L2 ‚Äî in-place DOM update so CSS transitions fire
  if (hoveredBlock && hoveredBlock.type === 'l2' && tooltipEl.classList.contains('visible')) {
    refreshTooltipL2Data();
  }
  // Live tooltip refresh for arbiter (state changes while hovered)
  if (hoveredBlock && hoveredBlock.type === 'arbiter' && tooltipEl.classList.contains('visible')) {
    updateTooltip(hoveredBlock, lastClientX, lastClientY);
  }

  if (autoMode) {
    autoTimer+=dt;
    var autoInterval = (currentArch === 'apex' && arbiterState.active) ? 99 : 6.5;
    if (autoTimer > autoInterval) {
      autoTimer=0;
      var anyValid    = layout.sms.some(function(s){ return s.l1.state !== 'invalid'; });
      var anyModified = layout.sms.some(function(s){ return s.l1.state === 'modified'; });
      var apex    = currentArch === 'apex';
      var hopper  = currentArch === 'hopper';
      var ampere  = currentArch === 'ampere';
      var pool;
      if (!anyValid) {
        // Nothing in L1 ‚Äî only ops that work from cold state
        pool = apex    ? ['read','read','read','atomic','reg_spill'] :
               hopper  ? ['read','read','reg_spill','tma_load'] :
               ampere  ? ['read','read','reg_spill','cp_async'] :
                         ['read','reg_spill'];
      } else if (anyModified) {
        // At least one SM has dirty data ‚Äî write-back and invalidate make sense; write does NOT (needs Shared)
        pool = apex    ? ['writeback','writeback','invalidate','read','atomic','reg_spill'] :
               hopper  ? ['writeback','writeback','invalidate','read','reg_spill','tma_load'] :
               ampere  ? ['writeback','writeback','invalidate','read','reg_spill','cp_async'] :
                         ['writeback','writeback','invalidate','read','reg_spill'];
      } else {
        // Some Shared lines in L1 ‚Äî write, invalidate, read all valid; writeback is NOT (nothing dirty)
        pool = apex    ? ['write','invalidate','read','read','shared','atomic','reg_spill'] :
               hopper  ? ['write','invalidate','read','read','shared','reg_spill','tma_load','cp_async'] :
               ampere  ? ['write','invalidate','read','read','shared','reg_spill','cp_async'] :
                         ['write','invalidate','read','read','shared','reg_spill'];
      }
      triggerScenario(pool[Math.floor(Math.random()*pool.length)], true); // true = silent (no toasts)
    }
  }
}

function drawSceneContent(dt, time) {
  var arch = ARCHS[currentArch];
  var mob = W < 500;
  var fs = mob ? 0.88 : 1;
  var FONT_SM_LABEL  = Math.max(10, 10*fs);
  var FONT_SM_WARP   = Math.max(7,  7*fs);
  var FONT_BLOCK_LG  = Math.max(8,  8*fs);
  var FONT_BLOCK_SM  = Math.max(7.5, 7.5*fs);
  var FONT_BLOCK_XS  = Math.max(7,  7*fs);
  var FONT_L2        = Math.max(11, 11*fs);
  var FONT_LABEL_MED = Math.max(10, 10*fs);
  var FONT_LABEL_SM  = Math.max(7,  7*fs);
  var FONT_HBM       = Math.max(11, 11*fs);

  if (layout.cluster) {
    var c = layout.cluster;
    ctx.setLineDash([4,4]);
    rrect(c.x1, c.y1, c.x2-c.x1, c.y2-c.y1, 10);
    ctx.strokeStyle = arch.color+'40'; ctx.lineWidth=1.5; ctx.stroke();
    ctx.setLineDash([]);
    ctx.font='bold '+Math.max(8,8*fs)+'px monospace';
    ctx.fillStyle=arch.color+'90'; ctx.textAlign='center';
    ctx.fillText('THREAD BLOCK CLUSTER', (c.x1+c.x2)/2, c.y1-2);
  }

  for (var si = 0; si < layout.sms.length; si++) {
    var sm = layout.sms[si];
    rrect(sm.x, sm.y, sm.w, sm.h, 7);
    ctx.fillStyle='#0f1118'; ctx.fill();
    ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1; ctx.stroke();
    ctx.font='700 '+FONT_SM_LABEL+'px system-ui,sans-serif';
    ctx.fillStyle='#e8eaf6'; ctx.textAlign='center';
    ctx.fillText(sm.label, sm.x+sm.w/2, sm.y+14*fs);
    ctx.font='400 '+FONT_SM_WARP+'px monospace';
    ctx.fillStyle='#8890b0';
    ctx.fillText('Warps ‚ñ∏‚ñ∏‚ñ∏', sm.x+sm.w/2, sm.y+24*fs);

    for (var bi = 0; bi < sm.sub.length; bi++) {
      var b = sm.sub[bi];
      if (b.type === 'regs') {
        var barC = Math.max(4, Math.floor(b.w/10));
        var cs_r = cacheState[si];
        var pressure = cs_r ? cs_r.regsPressure : 0.75;
        // Clamp visual fill to 1.0 ‚Äî overflow (>1) is shown via color, not height
        var visualFill = Math.min(1.0, pressure);
        // Color: blue-grey at normal load ‚Üí orange approaching limit ‚Üí red pulsing at overflow
        var pressureColor;
        if (pressure < 0.82) {
          // Normal loaded state: blue-grey (registers allocated but not overflowing)
          pressureColor = 'hsl(220,35%,28%)';
        } else if (pressure < 0.95) {
          // High load approaching limit: shift warm
          var t2 = (pressure - 0.82) / 0.13;
          pressureColor = 'hsl(' + Math.round(220 - t2*180) + ',55%,' + Math.round(28+t2*8) + '%)';
        } else {
          // Overflow / spill: orange-red pulse ‚Äî compiler had to spill!
          var pulse = 0.5 + 0.5 * Math.sin(Date.now() / 100);
          pressureColor = 'hsl(' + Math.round(18 - pulse*18) + ',85%,' + Math.round(38+pulse*10) + '%)';
        }
        // Subtle shimmer across bars (texture, not a fill change)
        var shimmer = Math.sin(Date.now()/1200 + si) * 0.018;
        for (var rj = 0; rj < barC; rj++) {
          var barX = b.x + rj * (b.w / barC);
          var barW = b.w / barC - 1.5;
          ctx.fillStyle = '#141620';
          ctx.fillRect(barX, b.y, barW, b.h);
          var barFill = Math.min(1, Math.max(0, visualFill + shimmer + (rj % 3 - 1) * 0.015));
          var fillH = Math.round(b.h * barFill);
          ctx.fillStyle = pressureColor;
          ctx.fillRect(barX, b.y + b.h - fillH, barW, fillH);
        }
        // Label ‚Äî orange when spilling
        ctx.font = '500 ' + Math.max(6, FONT_BLOCK_XS) + 'px monospace';
        ctx.fillStyle = pressure >= 0.95 ? '#fb923c' : '#6b7094';
        ctx.textAlign = 'center';
        ctx.fillText('regs', b.x + b.w/2, b.y - 1);
        continue;
      }
      rrect(b.x, b.y, b.w, b.h, 3);
      if (b.type === 'l1' && b.state) {
        var stColors = { modified:'#51cf66', shared:'#339af0', invalid:'#6b7090' };
        var sc = stColors[b.state]||'#6b7090';
        ctx.fillStyle = b.state === 'invalid' ? '#6b709018' : sc+'22'; ctx.fill();
        ctx.strokeStyle = b.state === 'invalid' ? '#5a5e78' : sc; ctx.lineWidth=1.5; ctx.stroke();

        var csm2 = cacheState[si];
        if (csm2) {
          var lines2 = csm2.l1;
          var gx = b.x + 4, gw = b.w - 8;
          var slotW = gw / NUM_LINES;
          var gy = b.y + b.h - 6;
          for (var li = 0; li < NUM_LINES; li++) {
            var lv = lines2[li];
            var lc = lv === 2 ? '#51cf66' : (lv === 1 ? (b.state==='shared'?'#339af0':'#51cf6688') : '#2a2d3a');
            ctx.fillStyle = lc;
            ctx.fillRect(gx + li*slotW + 0.5, gy, slotW - 1, 4);
          }
        }

        ctx.font='600 '+FONT_BLOCK_LG+'px monospace';
        ctx.fillStyle = b.state === 'invalid' ? '#9095b0' : sc;
        ctx.textAlign='center';
        ctx.fillText(b.label+' ['+b.state.charAt(0).toUpperCase()+']', b.x+b.w/2, b.y+b.h/2+1);
      } else {
        var cBg, cBr, cLbl;
        if (b.type==='texCache')             { cBg='#e599f712'; cBr='#e599f760'; cLbl='#e599f7'; }
        else if (b.type==='tma')             { cBg='#22d3ee12'; cBr='#22d3ee70'; cLbl='#22d3ee'; }
        else if (b.type==='dsmem')           { cBg='#22d3ee10'; cBr='#22d3ee60'; cLbl='#22d3ee'; }
        else if (b.type==='async')           { cBg='#22d3ee0a'; cBr='#22d3ee45'; cLbl='#6de8f0'; }
        else if (b.type==='warpScheduler')   { cBg='#a78bfa12'; cBr='#a78bfa60'; cLbl='#c4b5fd'; }
        else /* smem */                      { cBg='#51cf660a'; cBr='#51cf6660'; cLbl='#6ee09a'; }
        ctx.fillStyle=cBg; ctx.fill();
        ctx.strokeStyle=cBr; ctx.lineWidth=1; ctx.stroke();

        if (b.type === 'smem') {
          var csm3 = cacheState[si];
          if (csm3) {
            var slines = csm3.smem;
            var sgx = b.x + 4, sgw = b.w - 8;
            var sslotW = sgw / NUM_LINES;
            var sgy = b.y + b.h - 5;
            for (var sli2 = 0; sli2 < NUM_LINES; sli2++) {
              ctx.fillStyle = slines[sli2] === 1 ? '#51cf6680' : '#1e2030';
              ctx.fillRect(sgx + sli2*sslotW + 0.5, sgy, sslotW - 1, 3);
            }
          }
        }

        var lblFs = (b.type==='async') ? FONT_BLOCK_XS : FONT_BLOCK_SM;
        ctx.font='600 '+lblFs+'px monospace';
        ctx.fillStyle=cLbl; ctx.textAlign='center';
        ctx.fillText(b.label, b.x+b.w/2, b.y+b.h/2+1);
      }
    }
  }

  drawHoverHighlight();
  drawSelectionHighlight();
  drawConnLines(time);

  // ‚îÄ‚îÄ Draw Apex arbiter (full-width block) and cohDir (L2 sub-region) ‚îÄ‚îÄ
  if (currentArch === 'apex' && layout.arbiter) {
    var arb = layout.arbiter;

    // ‚îÄ‚îÄ Bus-to-arbiter interface line ‚îÄ‚îÄ
    // A single vertical tick at the arbiterBusEntry point, between bus and arbiter top.
    // This is the physical interface where back-pressure manifests when the queue is full.
    var ifaceX = arb.x + arb.w / 2;
    var ifaceY0 = layout.bus.y;       // bus level
    var ifaceY1 = arb.y;              // arbiter top
    var qFull = arbiterState.queue.length >= QUEUE_CAPACITY;
    ctx.save();
    ctx.strokeStyle = qFull ? '#ff6b6b' : '#f59e0b60';
    ctx.lineWidth   = qFull ? 2 : 1;
    if (qFull) { ctx.shadowColor = '#ff6b6b'; ctx.shadowBlur = 6; }
    ctx.beginPath(); ctx.moveTo(ifaceX, ifaceY0); ctx.lineTo(ifaceX, ifaceY1); ctx.stroke();
    // Small horizontal crossbar at the interface point (shows it's a named boundary)
    var tickW = qFull ? 10 : 6;
    ctx.beginPath(); ctx.moveTo(ifaceX - tickW, ifaceY0 + 2); ctx.lineTo(ifaceX + tickW, ifaceY0 + 2); ctx.stroke();
    ctx.restore();
    // Interface label
    ctx.font = '500 5px monospace'; ctx.textAlign = 'left';
    ctx.fillStyle = qFull ? '#ff6b6b90' : '#f59e0b35';
    ctx.fillText(qFull ? '‚ö† STALL' : 'interface', ifaceX + tickW + 3, ifaceY0 + 5);

    var arbTime2 = Date.now();
    var arbPulse = Math.sin(arbTime2/600) * 0.3 + 0.7;
    var isHovArb = hoveredBlock && hoveredBlock.type === 'arbiter';
    var latFrac = Math.min(arbiterState.contentionLevel, 1);
    var arbColor = latFrac > 0.6 ? '#ff6b6b' : '#f59e0b';

    // Main block
    rrect(arb.x, arb.y, arb.w, arb.h, 8);
    ctx.fillStyle = isHovArb ? '#f59e0b18' : '#f59e0b0c'; ctx.fill();
    ctx.strokeStyle = arbColor + Math.round(arbPulse * (isHovArb ? 230 : 160)).toString(16).padStart(2,'0');
    ctx.lineWidth = isHovArb ? 2 : 1.5; ctx.stroke();

    if (arbiterState.active) {
      ctx.save(); ctx.shadowColor = '#f59e0b'; ctx.shadowBlur = 14;
      rrect(arb.x, arb.y, arb.w, arb.h, 8);
      ctx.strokeStyle = '#f59e0b25'; ctx.lineWidth = 3; ctx.stroke();
      ctx.restore();
    }

    // Header strip
    ctx.fillStyle = '#f59e0b16';
    rrect(arb.x+1, arb.y+1, arb.w-2, 17, 7); ctx.fill();

    ctx.font = '700 8.5px monospace'; ctx.fillStyle = '#f59e0b'; ctx.textAlign = 'left';
    ctx.fillText('‚öñ ATOMIC ARBITER', arb.x + 12, arb.y + 13);
    var statusText = arbiterState.queue.length >= QUEUE_CAPACITY - 2 ? 'SATURATED' : arbiterState.active ? 'ACTIVE' : 'IDLE';
    var statusColor = arbiterState.queue.length >= QUEUE_CAPACITY - 2 ? '#ff6b6b' : arbiterState.active ? '#fbbf24' : '#4a5080';
    ctx.font = '600 7px monospace'; ctx.fillStyle = statusColor; ctx.textAlign = 'right';
    ctx.fillText('‚óè ' + statusText, arb.x + arb.w - 12, arb.y + 13);

    // ‚îÄ‚îÄ Layout: divide arbiter into left (QUEUE) and right (HOLD BUFFER / ROB) ‚îÄ‚îÄ
    var divX = arb.x + arb.w * 0.48;  // vertical divider x
    var innerY = arb.y + 21;
    var slotH2 = 15, slotGap2 = 4;

    // Divider line
    ctx.strokeStyle = '#f59e0b20'; ctx.lineWidth = 1;
    ctx.setLineDash([3,3]);
    ctx.beginPath(); ctx.moveTo(divX, arb.y + 18); ctx.lineTo(divX, arb.y + arb.h - 6); ctx.stroke();
    ctx.setLineDash([]);

    // ‚îÄ‚îÄ LEFT: INCOMING QUEUE ‚îÄ‚îÄ
    var qLabelX = arb.x + 12;
    ctx.font = '600 6px monospace'; ctx.fillStyle = '#f59e0b60'; ctx.textAlign = 'left';
    ctx.fillText('INCOMING QUEUE', qLabelX, innerY + 7);
    var qSlotW2 = 24;
    var qSlotStartX = qLabelX;
    var qSlotY = innerY + 11;
    var maxQSlots = Math.floor((divX - qLabelX - 12) / (qSlotW2 + slotGap2));
    maxQSlots = Math.min(maxQSlots, 6);
    for (var qs2 = 0; qs2 < maxQSlots; qs2++) {
      var sx2 = qSlotStartX + qs2 * (qSlotW2 + slotGap2);
      var qe2 = qs2 < arbiterState.queue.length ? arbiterState.queue[qs2] : null;
      ctx.fillStyle = qe2 ? '#f59e0b22' : '#141620';
      // granted slots show green (RMW dispatched, slot still held until arbiter entry)
      var qGranted = qe2 && qe2.granted;
      ctx.fillStyle = qGranted ? '#51cf6618' : (qe2 ? '#f59e0b22' : '#141620');
      ctx.strokeStyle = qGranted ? '#51cf6680' : (qe2 ? '#f59e0baa' : '#252840');
      ctx.lineWidth = qe2 ? 1.1 : 0.7;
      rrect(sx2, qSlotY, qSlotW2, slotH2, 3); ctx.fill(); ctx.stroke();
      ctx.font = '700 6px monospace'; ctx.textAlign = 'center';
      ctx.fillStyle = qGranted ? '#51cf66' : (qe2 ? '#fbbf24' : '#2a2d45');
      ctx.fillText(qe2 ? '#'+qe2.seq : '‚Äî', sx2 + qSlotW2/2, qSlotY + 10);
      // SM label below slot
      if (qe2) {
        ctx.font = '500 5px monospace'; ctx.fillStyle = qGranted ? '#51cf6660' : '#f59e0b60';
        ctx.fillText('SM'+qe2.smIdx, sx2 + qSlotW2/2, qSlotY + slotH2 + 6);
      }
    }

    // Queue depth indicator
    var qBotY = qSlotY + slotH2 + 11;
    ctx.font = '500 6px monospace'; ctx.fillStyle = '#f59e0b50'; ctx.textAlign = 'left';
    ctx.fillText('SEQ#' + String(arbiterState.seqCounter).padStart(3,'0'), qLabelX, qBotY);

    // ‚îÄ‚îÄ RIGHT: HOLD BUFFER (ROB) ‚îÄ‚îÄ
    var robLabelX = divX + 18;  // offset right so label clears the dashed divider
    ctx.font = '600 6px monospace'; ctx.fillStyle = '#a78bfa90'; ctx.textAlign = 'left';
    ctx.fillText('HOLD BUFFER  (ROB)', robLabelX, innerY + 7);
    var robSlotW2 = Math.floor((arb.x + arb.w - robLabelX - 12) / 6) - slotGap2;
    robSlotW2 = Math.max(robSlotW2, 18);
    var robSlotY = innerY + 11;
    for (var rs2 = 0; rs2 < 6; rs2++) {
      var rx3 = robLabelX + rs2 * (robSlotW2 + slotGap2);
      if (rx3 + robSlotW2 > arb.x + arb.w - 8) break;
      var robE2 = rs2 < arbiterState.rob.length ? arbiterState.rob[rs2] : null;
      var rBg2 = '#141620', rBr2 = '#252840', rTxt2 = '#2a2d45';
      var rIcon = '';
      if (robE2) {
        if (robE2.state === 'pending')   { rBg2='#f59e0b18'; rBr2='#f59e0b70'; rTxt2='#f59e0b'; rIcon='‚è≥'; }
        if (robE2.state === 'complete')  { rBg2='#339af020'; rBr2='#339af090'; rTxt2='#339af0'; rIcon='‚ú¶'; } // ACK back, waiting for head
        if (robE2.state === 'retiring')  { rBg2='#a78bfa20'; rBr2='#a78bfa80'; rTxt2='#a78bfa'; rIcon='‚Ü©'; } // head-of-line, being retired
        if (robE2.state === 'done')      { rBg2='#51cf6620'; rBr2='#51cf6680'; rTxt2='#51cf66'; rIcon='‚úì'; } // retired, DATA sent
      }
      ctx.fillStyle = rBg2; ctx.strokeStyle = rBr2; ctx.lineWidth = robE2 ? 1.1 : 0.7;
      rrect(rx3, robSlotY, robSlotW2, slotH2, 3); ctx.fill(); ctx.stroke();
      ctx.font = '700 5.5px monospace'; ctx.textAlign = 'center';
      ctx.fillStyle = rTxt2;
      ctx.fillText(robE2 ? '#'+robE2.seq : '‚Äî', rx3 + robSlotW2/2, robSlotY + 7);
      if (robE2) {
        ctx.font = '500 5px monospace'; ctx.fillStyle = rTxt2 + '90';
        ctx.fillText(rIcon, rx3 + robSlotW2/2, robSlotY + 13);
      }
    }

    // ROB state legend
    var robBotY = robSlotY + slotH2 + 11;
    ctx.font = '500 5.5px monospace'; ctx.textAlign = 'left';
    ctx.fillStyle = '#f59e0b60'; ctx.fillText('‚è≥ pending', robLabelX, robBotY);
    ctx.fillStyle = '#339af060'; ctx.fillText('‚ú¶ complete', robLabelX + 52, robBotY);
    ctx.fillStyle = '#a78bfa60'; ctx.fillText('‚Ü© retiring', robLabelX + 110, robBotY);
    ctx.fillStyle = '#51cf6660'; ctx.fillText('‚úì done', robLabelX + 162, robBotY);

    // ‚îÄ‚îÄ LEFT GUTTER ANNOTATION (side panel, left of arbiter) ‚îÄ‚îÄ
    var gutterX = arb.x - 8;
    var gutterW = Math.max(gutterX - 10, 0);
    if (gutterW > 40) {
      var gx = 8, gw = gutterX - 12;
      var gArbY = arb.y + 4;
      ctx.font = '500 5.5px monospace'; ctx.fillStyle = '#f59e0b40'; ctx.textAlign = 'right';
      ctx.fillText('SERIALIZES', gx + gw, gArbY + 8);
      ctx.fillText('ATOMICS', gx + gw, gArbY + 16);
      ctx.fillStyle = '#f59e0b25'; ctx.textAlign = 'right';
      ctx.fillText('SEQ# tags', gx + gw, gArbY + 26);
      ctx.fillText('ROB order', gx + gw, gArbY + 34);
      // Contention bar
      var gbY = gArbY + 42;
      ctx.font = '500 5px monospace'; ctx.fillStyle = '#f59e0b40'; ctx.textAlign = 'right';
      ctx.fillText('contention', gx + gw, gbY);
      ctx.fillStyle = '#141620';
      ctx.fillRect(gx + gw - 36, gbY + 2, 36, 4);
      if (latFrac > 0) {
        var gGrad = ctx.createLinearGradient(gx + gw - 36, 0, gx + gw, 0);
        gGrad.addColorStop(0, '#51cf66'); gGrad.addColorStop(0.5, '#f59e0b'); gGrad.addColorStop(1, '#ff6b6b');
        ctx.fillStyle = gGrad;
        ctx.fillRect(gx + gw - 36, gbY + 2, 36 * latFrac, 4);
      }
      ctx.font = '600 5.5px monospace'; ctx.fillStyle = '#f59e0b'; ctx.textAlign = 'right';
      var cycEst3 = Math.round(2 + latFrac * 30);
      ctx.fillText('~'+cycEst3+'cyc', gx + gw, gbY + 14);
    }

    // ‚îÄ‚îÄ RIGHT GUTTER ANNOTATION (side panel, right of arbiter) ‚îÄ‚îÄ
    var rGutterX = arb.x + arb.w + 8;
    var rGutterW = W - rGutterX - 8;
    if (rGutterW > 40) {
      var rgx = rGutterX + 4;
      var rgArbY = arb.y + 4;
      ctx.font = '500 5.5px monospace'; ctx.fillStyle = '#f59e0b40'; ctx.textAlign = 'left';
      ctx.fillText('GRANT policy:', rgx, rgArbY + 8);
      ctx.fillStyle = '#f59e0b25';
      ctx.fillText('FIFO arrival', rgx, rgArbY + 17);
      ctx.fillText('1 at a time', rgx, rgArbY + 26);
      ctx.font = '500 5px monospace';
      ctx.fillStyle = '#f59e0b20';
      ctx.fillText('Granted: '+arbiterState.grantCount, rgx, rgArbY + 37);
    }
  }

  // ‚îÄ‚îÄ cohDir drawn as sub-region INSIDE L2 block ‚îÄ‚îÄ
  if (currentArch === 'apex' && layout.cohDir) {
    var cd = layout.cohDir;
    var isHovCd = hoveredBlock && hoveredBlock.type === 'cohDir';
    var cdPulse = Math.sin(Date.now()/900) * 0.2 + 0.8;
    rrect(cd.x, cd.y, cd.w, cd.h, 5);
    ctx.fillStyle = isHovCd ? '#22d3ee18' : '#22d3ee0a'; ctx.fill();
    ctx.strokeStyle = '#22d3ee' + Math.round(cdPulse * (isHovCd ? 200 : 100)).toString(16).padStart(2,'0');
    ctx.lineWidth = isHovCd ? 1.5 : 0.8; ctx.stroke();
    ctx.font = '700 6.5px monospace'; ctx.fillStyle = '#22d3ee'; ctx.textAlign = 'center';
    ctx.fillText('COH. DIR', cd.x + cd.w/2, cd.y + 10);
    var cdRowH = 5, cdRowGap = 2, cdRows = 3, cdBitCount = 4;
    for (var dr2 = 0; dr2 < cdRows; dr2++) {
      var ry2 = cd.y + 15 + dr2 * (cdRowH + cdRowGap);
      var cdBitW = (cd.w - 14) / cdBitCount;
      for (var db2 = 0; db2 < cdBitCount; db2++) {
        var hasSharer = (dr2 * 7 + db2 * 3 + Math.floor(Date.now()/2000)) % 3 !== 0;
        ctx.fillStyle = hasSharer ? '#22d3ee35' : '#1a1c28';
        ctx.strokeStyle = '#22d3ee30'; ctx.lineWidth = 0.5;
        ctx.fillRect(cd.x + 7 + db2*cdBitW, ry2, cdBitW-1, cdRowH);
      }
    }
    ctx.font = '500 5.5px monospace'; ctx.fillStyle = '#22d3ee50'; ctx.textAlign = 'center';
    ctx.fillText('targeted', cd.x + cd.w/2, cd.y + cd.h - 3);

    // ‚îÄ‚îÄ L2 RIGHT GUTTER: bandwidth and state info ‚îÄ‚îÄ
    var l2 = layout.l2;
    var l2RGutX = l2.x + l2.w + 8;
    var l2RGutW = W - l2RGutX - 8;
    if (l2RGutW > 40) {
      var l2gx = l2RGutX + 4;
      var l2gY = l2.y + 4;
      ctx.font = '500 5.5px monospace'; ctx.fillStyle = '#ffa94d40'; ctx.textAlign = 'left';
      ctx.fillText('L2: 64MB', l2gx, l2gY + 8);
      ctx.fillText('unified', l2gx, l2gY + 17);
      ctx.fillStyle = '#22d3ee30';
      ctx.fillText('coh. point', l2gx, l2gY + 28);
    }
    // ‚îÄ‚îÄ L2 LEFT GUTTER: RMW annotation ‚îÄ‚îÄ
    var l2LGutW2 = l2.x - 12;
    if (l2LGutW2 > 40) {
      ctx.font = '500 5.5px monospace'; ctx.fillStyle = '#ffa94d40'; ctx.textAlign = 'right';
      ctx.fillText('RMW here', l2.x - 8, l2.y + 10);
      ctx.fillStyle = '#ffa94d20';
      ctx.fillText('~200 cyc', l2.x - 8, l2.y + 20);
    }
  }

  for (var ci = 0; ci < layout.sms.length; ci++) {
    var csm = layout.sms[ci];
    ctx.beginPath(); ctx.moveTo(csm.x+csm.w/2, csm.y+csm.h);
    ctx.lineTo(csm.x+csm.w/2, layout.bus.y);
    ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1; ctx.stroke();
  }

  if (currentArch==='hopper' && layout.sms.length>1) {
    var dsPulse = Math.sin(Date.now()/500)*0.3+0.5;
    for (var di = 0; di < layout.sms.length-1; di++) {
      var dsA=null, dsB=null;
      for (var ds1=0;ds1<layout.sms[di].sub.length;ds1++) { if(layout.sms[di].sub[ds1].type==='dsmem') dsA=layout.sms[di].sub[ds1]; }
      for (var ds2=0;ds2<layout.sms[di+1].sub.length;ds2++) { if(layout.sms[di+1].sub[ds2].type==='dsmem') dsB=layout.sms[di+1].sub[ds2]; }
      if (dsA&&dsB) {
        ctx.beginPath(); ctx.moveTo(dsA.x+dsA.w, dsA.y+dsA.h/2);
        ctx.lineTo(dsB.x, dsB.y+dsB.h/2);
        ctx.strokeStyle='rgba(34,211,238,'+(dsPulse*0.5)+')';
        ctx.lineWidth=1.5; ctx.setLineDash([3,3]); ctx.stroke(); ctx.setLineDash([]);
      }
    }
  }

  var bus = layout.bus;
  var busPulse = Math.sin(Date.now()/400)*0.3+0.5;
  ctx.setLineDash([5,3]);
  ctx.beginPath(); ctx.moveTo(bus.x1, bus.y); ctx.lineTo(bus.x2, bus.y);
  ctx.strokeStyle='#f0659550'; ctx.lineWidth=2; ctx.stroke(); ctx.setLineDash([]);
  ctx.beginPath(); ctx.moveTo(bus.x1, bus.y); ctx.lineTo(bus.x2, bus.y);
  ctx.strokeStyle='rgba(240,101,149,'+(busPulse*0.15)+')'; ctx.lineWidth=8; ctx.stroke();
  ctx.font='600 '+Math.max(8,8*fs)+'px monospace';
  ctx.fillStyle='#f06595e0'; ctx.textAlign='center';
  ctx.fillText(bus.label, (bus.x1+bus.x2)/2, bus.y-9);

  ctx.beginPath(); ctx.moveTo(W/2, bus.y); ctx.lineTo(W/2, layout.l2.y);
  ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1.5; ctx.stroke();

  var l2 = layout.l2;
  rrect(l2.x, l2.y, l2.w, l2.h, 7);
  ctx.fillStyle='#1a1408'; ctx.fill();
  ctx.strokeStyle='#ffa94d60'; ctx.lineWidth=1.5; ctx.stroke();
  ctx.font='700 '+Math.max(11,11*fs)+'px system-ui,sans-serif';
  ctx.fillStyle='#ffb55a'; ctx.textAlign='center';
  ctx.fillText(arch.blocks.l2.label, l2.x+l2.w/2, l2.y+18*fs);
  // L2 line state bars ‚Äî same visual language as L1 but wider (unified across all SMs)
  var l2BarY = l2.y + 24*fs;
  var l2BarH = 8*fs;
  var l2BarGutter = 10;
  var l2BarW = (l2.w - l2BarGutter*2) / NUM_L2_LINES;
  for (var l2i = 0; l2i < NUM_L2_LINES; l2i++) {
    var lv2 = l2Lines[l2i];
    if (lv2 === 2)      ctx.fillStyle = '#ffa94d';   // dirty
    else if (lv2 === 1) ctx.fillStyle = '#339af060';  // clean
    else                ctx.fillStyle = '#1e2030';     // empty
    ctx.fillRect(l2.x + l2BarGutter + l2i*l2BarW, l2BarY, l2BarW - 1, l2BarH);
  }

  if (layout.l2Persist) {
    var p = layout.l2Persist;
    rrect(p.x,p.y,p.w,p.h,2);
    var grad = ctx.createLinearGradient(p.x,0,p.x+p.w,0);
    grad.addColorStop(0,'#ffa94d35'); grad.addColorStop(0.6,'#ffa94d18'); grad.addColorStop(1,'#ffa94d05');
    ctx.fillStyle=grad; ctx.fill();
    ctx.strokeStyle='#ffa94d35'; ctx.lineWidth=.5; ctx.stroke();
    ctx.font='600 '+Math.max(6,6*fs)+'px monospace';
    ctx.fillStyle='#ffa94da0'; ctx.textAlign='center';
    ctx.fillText('PERSIST WINDOW', p.x+p.w/2, p.y+p.h/2+2);
  }

  ctx.beginPath(); ctx.moveTo(W/2,l2.y+l2.h); ctx.lineTo(W/2,layout.crossbar.y);
  ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1.5; ctx.stroke();

  var cb = layout.crossbar;
  ctx.setLineDash([3,3]);
  ctx.beginPath(); ctx.moveTo(cb.x1,cb.y); ctx.lineTo(cb.x2,cb.y);
  ctx.strokeStyle='#339af038'; ctx.lineWidth=1.5; ctx.stroke(); ctx.setLineDash([]);
  ctx.font='600 '+Math.max(7.5,7.5*fs)+'px monospace';
  ctx.fillStyle='#339af0c0'; ctx.textAlign='center';
  ctx.fillText('MEMORY CROSSBAR / NoC', (cb.x1+cb.x2)/2, cb.y-6);

  ctx.beginPath(); ctx.moveTo(W/2,cb.y); ctx.lineTo(W/2,layout.globalMem.y);
  ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1.5; ctx.stroke();

  var gm = layout.globalMem;
  rrect(gm.x,gm.y,gm.w,gm.h,7);
  ctx.fillStyle='#0d1320'; ctx.fill();
  ctx.strokeStyle='#339af050'; ctx.lineWidth=1.5; ctx.stroke();
  ctx.font='700 '+Math.max(10,10*fs)+'px system-ui,sans-serif';
  ctx.fillStyle='#5ab0f8'; ctx.textAlign='center';
  ctx.fillText('Global Memory Interface', gm.x+gm.w/2, gm.y+14);
  for (var mci=0;mci<layout.mcs.length;mci++) {
    var mc=layout.mcs[mci];
    ctx.fillStyle='hsl(210,50%,'+(14+Math.sin(Date.now()/500+mci)*3)+'%)';
    ctx.fillRect(mc.x,mc.y,mc.w,mc.h);
    ctx.font='600 '+Math.max(6.5,6.5*fs)+'px monospace';
    ctx.fillStyle='#339af090'; ctx.textAlign='center';
    ctx.fillText('MC'+mci, mc.x+mc.w/2, mc.y+mc.h/2+2.5);
  }
  ctx.font='500 '+Math.max(6.5,6.5*fs)+'px monospace';
  ctx.fillStyle='#8890a8'; ctx.textAlign='center';
  ctx.fillText('MC ‚Üí '+arch.blocks.hbm.label, gm.x+gm.w/2, gm.y+gm.h-5);

  ctx.beginPath(); ctx.moveTo(W/2,gm.y+gm.h); ctx.lineTo(W/2,layout.hbm.y);
  ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1.5; ctx.stroke();

  var hbm = layout.hbm;
  rrect(hbm.x,hbm.y,hbm.w,hbm.h,7);
  ctx.fillStyle='#0d0a18'; ctx.fill();
  ctx.strokeStyle='#845ef740'; ctx.lineWidth=1.5; ctx.stroke();
  ctx.font='700 '+Math.max(11,11*fs)+'px system-ui,sans-serif';
  ctx.fillStyle='#a07af8'; ctx.textAlign='center';
  ctx.fillText(hbm.label, hbm.x+hbm.w/2, hbm.y+16*fs);
  var hbmStacks = mob ? 4 : 6;
  var hstW = (hbm.w-30)/hbmStacks;
  for (var hi=0;hi<hbmStacks;hi++) {
    for (var hl=0;hl<3;hl++) {
      ctx.fillStyle='hsl(260,40%,'+(12+hl*3+Math.sin(Date.now()/700+hi+hl)*2)+'%)';
      ctx.fillRect(hbm.x+15+hi*hstW, hbm.y+22*fs+hl*3.5, hstW-4, 3);
    }
  }

  // Flash effects (skip advancement if paused)
  flashEffects = flashEffects.filter(function(f) {
    if (!paused) f.t+=0.02;
    if (f.t>=f.dur) return false;
    rrect(f.x-2,f.y-2,f.w+4,f.h+4,5);
    ctx.strokeStyle=f.c+Math.round((1-f.t/f.dur)*0.3*255).toString(16).padStart(2,'0');
    ctx.lineWidth=2; ctx.stroke();
    return true;
  });

  // Bubble repulsion: pairs within 52px push each other apart gently
  if (!paused && bubbles.length > 1) {
    var REPEL_DIST = 52, REPEL_FORCE = 0.18, DAMP = 0.82;
    for (var ri = 0; ri < bubbles.length; ri++) {
      var ba = bubbles[ri];
      ba.vx *= DAMP; ba.vy *= DAMP;
      for (var rj = ri + 1; rj < bubbles.length; rj++) {
        var bb2 = bubbles[rj];
        var rdx = ba.x - bb2.x, rdy = ba.y - bb2.y;
        var dist = Math.sqrt(rdx*rdx + rdy*rdy) || 0.01;
        if (dist < REPEL_DIST) {
          var force = (REPEL_DIST - dist) / REPEL_DIST * REPEL_FORCE;
          var nx = rdx/dist, ny = rdy/dist;
          ba.vx += nx*force; ba.vy += ny*force;
          bb2.vx -= nx*force; bb2.vy -= ny*force;
        }
      }
    }
    for (var ri2 = 0; ri2 < bubbles.length; ri2++) {
      bubbles[ri2].x += bubbles[ri2].vx;
      bubbles[ri2].y += bubbles[ri2].vy;
    }
  }

  // Bubbles (skip advancement if paused)
  bubbles = bubbles.filter(function(b) {
    if (!paused) b.age+=dt;
    if (b.age>b.life) return false;
    var progress=b.age/b.life;
    var fadeIn=Math.min(b.age/0.15,1);
    var fadeOut=progress>0.7?1-(progress-0.7)/0.3:1;
    var alpha=fadeIn*fadeOut;
    var bx=b.x+Math.sin(b.age*1.5+b.wobble)*3;
    var by=b.y-b.age*b.rise;
    var scale=0.8+fadeIn*0.2;

    var isHovered = false;
    if (hoveredBlock) {
      var hr = hoveredBlock;
      if (b.x >= hr.x - 10 && b.x <= hr.x + hr.w + 10 &&
          b.y >= hr.y - 20 && b.y <= hr.y + hr.h + 20) {
        isHovered = true;
      }
    }
    var boostScale = isHovered ? 1.45 : 1.0;
    var boostAlpha = isHovered ? Math.min(alpha * 1.25, 1) : alpha;

    ctx.save();
    ctx.globalAlpha=boostAlpha;

    var fs2 = Math.max(8, 8*scale*boostScale);
    var subFs = Math.max(6.5, 6.5*scale*boostScale);
    ctx.font='700 '+fs2+'px monospace';
    var tw = ctx.measureText(b.text).width + 14;
    var subTw = 0;
    if (b.sub) {
      ctx.font='500 '+subFs+'px monospace';
      subTw = ctx.measureText(b.sub).width + 14;
    }
    var boxW = Math.max(tw, subTw);
    var lineH = fs2 + 3;
    var bh = b.sub ? (lineH + subFs + 7) : (lineH + 4);

    rrect(bx-boxW/2, by-bh/2-1, boxW, bh, 5);
    ctx.fillStyle = isHovered ? b.color + '28' : b.bg; ctx.fill();
    ctx.strokeStyle = isHovered ? b.color + 'cc' : b.color + '70';
    ctx.lineWidth = isHovered ? 1.8 : 1; ctx.stroke();

    if (isHovered) {
      rrect(bx-boxW/2-3, by-bh/2-4, boxW+6, bh+6, 7);
      ctx.strokeStyle = b.color + '30';
      ctx.lineWidth = 4; ctx.stroke();
    }

    if (progress<0.35) {
      ctx.beginPath();
      ctx.moveTo(bx-3, by+bh/2-1);
      ctx.lineTo(bx, by+bh/2+5);
      ctx.lineTo(bx+3, by+bh/2-1);
      ctx.closePath(); ctx.fillStyle = isHovered ? b.color + '28' : b.bg; ctx.fill();
    }

    ctx.font='700 '+fs2+'px monospace';
    ctx.fillStyle=b.color;
    ctx.textAlign='center';
    var textY = b.sub ? (by - bh/2 + fs2 + 3) : (by + fs2/2 - 1);
    ctx.fillText(b.text, bx, textY);

    if (b.sub) {
      ctx.font='500 '+subFs+'px monospace';
      ctx.fillStyle = isHovered ? b.color + 'cc' : b.color + '99';
      ctx.fillText(b.sub, bx, textY + subFs + 2);
    }
    ctx.restore();
    return true;
  });

  // Particles (skip advancement if paused)
  if (!paused) {
    particles.forEach(function(p) { p.update(dt); p.draw(ctx); });
    particles = particles.filter(function(p) { return p.alive; });
  } else {
    // Still draw particles frozen in place
    particles.forEach(function(p) { p.draw(ctx); });
  }

  buildParticleLabelRects();

  // Paused indicator is shown in the HTML badge only ‚Äî no canvas overlay needed
}

var lastTime=0;

// Particle ‚Äî supports waypoint routing so particles travel along logical wire paths
// Usage: new Particle(from, to, color, label, speed, onDone)
//   OR:  new Particle(from, to, color, label, speed, onDone, {waypoints:[{x,y}, ...]})
// Waypoints are intermediate stops; particle chains through them automatically.

// particles.js ‚Äî GPU Cache Coherency Demo

// Particle animation, coordinate helpers, flash

function Particle(from, to, color, label, speed, onDone, opts) {
  this.color=color; this.label=label||''; this.speed=(speed||2)*SPEED_SCALE; this.alive=true; this.onDone=onDone;
  this.trail=[];
  // Build segment list from waypoints
  var pts = [{x:from.x,y:from.y}];
  if (opts && opts.waypoints) { for (var wi=0;wi<opts.waypoints.length;wi++) pts.push(opts.waypoints[wi]); }
  pts.push({x:to.x,y:to.y});
  this.pts = pts;
  this.segIdx = 0;  // current segment index
  this.segT = 0;    // progress within current segment [0..1]
  // Compute segment lengths for proportional speed
  this.segLens = [];
  this.totalLen = 0;
  for (var si=0;si<pts.length-1;si++) {
    var dx=pts[si+1].x-pts[si].x, dy=pts[si+1].y-pts[si].y;
    var len=Math.sqrt(dx*dx+dy*dy)||1;
    this.segLens.push(len); this.totalLen+=len;
  }
  this.from={x:from.x,y:from.y}; this.to={x:to.x,y:to.y}; // kept for compat
  // passthrough callbacks: {t:0..1, fn:function} ‚Äî fire when particle crosses that fraction of total path
  this.passthroughs = opts && opts.passthroughs ? opts.passthroughs : [];
  this._ptFired = [];
  for (var pi=0;pi<this.passthroughs.length;pi++) this._ptFired.push(false);
  // compute elapsed fraction
  this._frac = 0;
}
Particle.prototype._getPos = function() {
  var pts=this.pts, segIdx=this.segIdx, segT=this.segT;
  if (segIdx>=pts.length-1) return {x:pts[pts.length-1].x,y:pts[pts.length-1].y};
  var a=pts[segIdx], b=pts[segIdx+1];
  return {x:a.x+(b.x-a.x)*segT, y:a.y+(b.y-a.y)*segT};
};
Particle.prototype.update = function(dt) {
  var step = (this.speed*dt*60)/Math.max(this.segLens[this.segIdx]||1,1);
  this.segT += step;
  // Advance through segments
  while (this.segT >= 1 && this.segIdx < this.pts.length-2) {
    this.segT -= 1; this.segIdx++;
    // Recompute step rate for new segment
  }
  if (this.segIdx >= this.pts.length-2 && this.segT >= 1) {
    this.segT=1; this.alive=false; if (this.onDone) this.onDone(); return;
  }
  // Compute overall fraction for passthrough callbacks
  var elapsed=0;
  for (var si=0;si<this.segIdx;si++) elapsed+=this.segLens[si];
  elapsed+=this.segLens[this.segIdx]*this.segT;
  this._frac = elapsed/this.totalLen;
  // Fire passthroughs
  for (var pi=0;pi<this.passthroughs.length;pi++) {
    if (!this._ptFired[pi] && this._frac >= this.passthroughs[pi].t) {
      this._ptFired[pi]=true;
      this.passthroughs[pi].fn();
    }
  }
  var pos=this._getPos();
  this.trail.push({x:pos.x,y:pos.y}); if(this.trail.length>18) this.trail.shift();
};
Particle.prototype.draw = function(ctx) {
  for (var i=0;i<this.trail.length;i++) {
    var p=this.trail[i], a=(1-i/this.trail.length)*0.5, r=2.5-i/this.trail.length*1.5;
    ctx.beginPath(); ctx.arc(p.x,p.y,Math.max(r,.5),0,Math.PI*2);
    ctx.fillStyle=this.color+Math.round(a*255).toString(16).padStart(2,'0'); ctx.fill();
  }
  var pos=this._getPos();
  var cx=pos.x, cy=pos.y;
  ctx.beginPath(); ctx.arc(cx,cy,4,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill();
  ctx.beginPath(); ctx.arc(cx,cy,7,0,Math.PI*2); ctx.fillStyle=this.color+'28'; ctx.fill();
  if (this.label) {
    var hasInfo = !!INSTRUCTION_INFO[this.label];
    var lFont = (hasInfo ? '700' : '500') + ' 9px monospace';
    ctx.font = lFont;
    var lw = ctx.measureText(this.label).width;
    var lx = cx, ly = cy - 12;
    if (hasInfo) {
      var pw = lw + 10, ph = 13;
      rrect(lx - pw/2, ly - ph + 3, pw, ph, 3);
      ctx.fillStyle = this.color + '28'; ctx.fill();
      ctx.strokeStyle = this.color + '70'; ctx.lineWidth = 0.8; ctx.stroke();
    }
    ctx.font = lFont; ctx.fillStyle = this.color; ctx.textAlign = 'center';
    ctx.fillText(this.label, lx, ly);
  }
};

// Convenience: spawn a particle that routes through waypoints automatically
function spawnParticle(from, to, color, label, speed, onDone, waypoints, passthroughs) {
  var opts = {};
  if (waypoints && waypoints.length) opts.waypoints = waypoints;
  if (passthroughs && passthroughs.length) opts.passthroughs = passthroughs;
  var p = new Particle(from, to, color, label, speed, onDone, opts);
  particles.push(p);
  return p;
}

function l1Pos(i) { var l1=layout.sms[i].l1; return {x:l1.x+l1.w/2,y:l1.y+l1.h/2}; }
function busP(i) { var s=layout.sms[i]; return {x:s.x+s.w/2,y:layout.bus.y}; }
function l2Top() { return {x:layout.l2.x+layout.l2.w/2,y:layout.l2.y}; }
function l2Bot() { return {x:layout.l2.x+layout.l2.w/2,y:layout.l2.y+layout.l2.h}; }
function cbP() { return {x:W/2,y:layout.crossbar.y}; }
function gmTop() { return {x:layout.globalMem.x+layout.globalMem.w/2,y:layout.globalMem.y}; }
function gmBot() { return {x:layout.globalMem.x+layout.globalMem.w/2,y:layout.globalMem.y+layout.globalMem.h}; }
function hbmTop() { return {x:layout.hbm.x+layout.hbm.w/2,y:layout.hbm.y}; }
function flash(b,c) { flashEffects.push({x:b.x,y:b.y,w:b.w,h:b.h,c:c,t:0,dur:.5}); }
function regsBlock(i) { var sm=layout.sms[i]; for(var bi=0;bi<sm.sub.length;bi++){if(sm.sub[bi].type==='regs')return sm.sub[bi];} return null; }
function regsPos(i) { var b=regsBlock(i); if(b) return {x:b.x+b.w/2,y:b.y+b.h/2}; var sm=layout.sms[i]; return {x:sm.x+sm.w/2,y:sm.y+30}; }
function subBlock(smIdx,type) { var sm=layout.sms[smIdx]; for(var bi=0;bi<sm.sub.length;bi++){if(sm.sub[bi].type===type)return sm.sub[bi];} return null; }

// scenarios.js ‚Äî GPU Cache Coherency Demo

// Cache scenario triggers, explanations, auto mode

function getExplanation(type) {
  var arch = currentArch;
  var e = {
    read:{ title:'L1 Read Miss ‚Üí L2 Fetch', color:'#ff6b6b',
      steps:[
        {text:'<strong>Warp issues load</strong> ‚Äî global memory read.', micro:'LD.E Rx, [addr]', delay:0},
        {text:'<strong>L1 tag lookup: MISS</strong>', micro:'Tag compare ‚Üí miss', delay:700},
        {text:'<strong>Request to L2</strong>', micro:'RdReq ‚Üí Bus ‚Üí L2', delay:1500},
        {text:'<strong>L2 hit</strong> ‚Äî data read from L2.', micro:'L2 '+ARCHS[arch].blocks.l2.size+' slice lookup', delay:2500},
        {text:'<strong>Data returns</strong> ‚Äî cache line fills L1.', micro:'DATA ‚Üí SM L1 fill', delay:3300},
        {text:'<strong>L1 ‚Üí Shared</strong>', micro:'State: Invalid ‚Üí Shared', delay:4000},
      ], summary: arch==='pascal' ? 'Pascal L1 is read-only for globals.' : 'Standard read miss path.'
    },
    write:{ title: arch==='pascal' ? 'SM Write ‚Üí Direct to L2' : 'SM Write ‚Üí Invalidate Others', color:'#51cf66',
      steps: arch==='pascal' ? [
        {text:'<strong>Warp issues store</strong>', micro:'ST.E [addr], Rx', delay:0},
        {text:'<strong>L1 bypassed</strong> ‚Äî write goes directly to L2.', micro:'Write-through: skip L1', delay:500},
        {text:'<strong>L2 absorbs write</strong>', micro:'L2 SRAM write', delay:1200},
        {text:'<strong>No invalidation needed</strong>', micro:'No INV broadcast', delay:1800},
      ] : [
        {text:'<strong>Warp issues store</strong>', micro:'ST.E [addr], Rx', delay:0},
        {text:'<strong>L1 ‚Üí Modified</strong> ‚Äî write-evict policy.', micro:'Write-evict: L1 drop + L2 write', delay:500},
        {text:'<strong>Invalidation broadcast</strong>', micro:'INV ‚Üí all SMs via bus', delay:1200},
        {text:'<strong>Remote L1s invalidated</strong>', micro:'Other SMs: * ‚Üí Invalid', delay:2000},
        {text:'<strong>Coherency restored</strong>', micro:'Single-writer invariant', delay:2800},
      ], summary: arch==='pascal' ? 'Pascal: L1 read-only, writes go to L2.' : 'Write-evict: L1 line dropped, L2 gets the write.'
    },
    invalidate:{ title:'Broadcast Invalidation', color:'#f06595',
      steps:[
        {text:'<strong>Coherency event</strong>', micro:'SM write or host DMA', delay:0},
        {text:'<strong>Bus broadcasts INV</strong>', micro:'INV(addr) ‚Üí all SMs', delay:600},
        {text:'<strong>L1 tags probed</strong>', micro:'Parallel tag lookup', delay:1200},
        {text:'<strong>All copies dropped</strong>', micro:'All: * ‚Üí Invalid', delay:2200},
      ], summary:'Broadcast invalidation scales linearly with SM count.'
    },
    writeback:{ title:'Write-Back ‚Üí L2 ‚Üí '+ARCHS[currentArch].blocks.hbm.label, color:'#ffa94d',
      steps:[
        {text:'<strong>L1 eviction</strong> ‚Äî dirty line needs to leave L1.', micro:'Capacity eviction or flush', delay:0},
        {text:'<strong>Data ‚Üí L2</strong>', micro:'WB+DATA ‚Üí L2 slice', delay:800},
        {text:'<strong>L2 absorbs</strong>', micro:'L2 write', delay:1800},
        {text:'<strong>L2 eviction</strong> ‚Äî if full, victim evicted to DRAM.', micro:'LRU victim ‚Üí NoC ‚Üí MC', delay:3000},
        {text:'<strong>'+ARCHS[arch].blocks.hbm.label+' write</strong>', micro:'MC ‚Üí bank write', delay:4000},
        {text:'<strong>Stored in '+ARCHS[arch].blocks.hbm.label+'</strong>', micro:'~400+ cycles total', delay:4800},
      ], summary:'Full eviction cascade: L1‚ÜíL2‚ÜíMC‚ÜíDRAM.'
    },
    shared:{ title: currentArch==='hopper' ? 'Shared Mem + DSMEM' : 'Shared Memory Access', color:'#51cf66',
      steps: currentArch==='hopper' ? [
        {text:'<strong>Thread accesses __shared__</strong>', micro:'LDS Rx, [smem_addr]', delay:0},
        {text:'<strong>Direct SRAM access</strong> ‚Äî no coherency. 32 banks.', micro:'~20 cycles', delay:500},
        {text:'<strong>DSMEM option</strong> ‚Äî access other SMs\' shared memory.', micro:'dst_sm.smem[addr]', delay:1200},
        {text:'<strong>Cluster-local</strong> ‚Äî DSMEM at SMEM latency.', micro:'~20 cycles cross-SM', delay:1800},
      ] : [
        {text:'<strong>Thread accesses __shared__</strong>', micro:'LDS Rx, [smem_addr]', delay:0},
        {text:'<strong>Direct SRAM access</strong> ‚Äî no coherency.', micro:'~20 cycles, 32 banks', delay:500},
        {text:'<strong>Bank conflict check</strong>', micro:'Best: 1 cycle. Worst: 32-way', delay:1100},
        {text:'<strong>SM-local only</strong> ‚Äî no bus traffic.', micro:'Scope: CTA local', delay:1600},
      ], summary: currentArch==='hopper' ? 'DSMEM enables cross-SM shared memory within a cluster.' : 'Shared memory sidesteps coherency by being SM-private.'
    },
    atomic:{ title: currentArch==='apex' ? '‚öõ atomicAdd ‚Üí Apex Arbiter (SEQ# + ROB)' : '‚öõ atomicAdd ‚Üí Raw L2 Serialization', color:'#f59e0b',
      steps: currentArch==='apex' ? [
        {text:'<strong>All SMs issue atomicAdd</strong> simultaneously', micro:'ATOM ‚Üí coherency bus', delay:0},
        {text:'<strong>ATOM packets hit the Arbiter</strong> ‚Äî each gets a SEQ#', micro:'Arbiter: seq++ per request', delay:500},
        {text:'<strong>Arbiter queues requests</strong> ‚Äî up to 6 deep', micro:'Round-robin grant policy', delay:1100},
        {text:'<strong>GRANT fires</strong> to front-of-queue SM', micro:'GRANT ‚Üí SM: exclusive access', delay:1800},
        {text:'<strong>SM does read-modify-write</strong> on L2', micro:'ATOM ‚Üí L2 RMW ‚Üí ACK', delay:2600},
        {text:'<strong>ACK returns ‚Üí ROB retires</strong> in SEQ order', micro:'ROB: #N retired ‚Üí next SM', delay:3400},
        {text:'<strong>DATA sent back</strong> to originating SM', micro:'DATA#N ‚Üí SM L1', delay:4200},
      ] : [
        {text:'<strong>All SMs issue atomicAdd</strong> simultaneously', micro:'ATOM ‚Üí bus (no coordination)', delay:0},
        {text:'<strong>All ATOM packets race for L2</strong>', micro:'L2 serializes them internally', delay:600},
        {text:'<strong>L2 locks the cache line</strong> for each ATOM', micro:'One SM at a time ‚Äî slow', delay:1400},
        {text:'<strong>DATA returns</strong> to each SM in turn', micro:'No ROB ‚Äî order not guaranteed', delay:2400},
        {text:'<strong>On Apex</strong>: an explicit Arbiter would handle this cleanly', micro:'SEQ# + ROB = ordered, visible', delay:3200},
      ],
      summary: currentArch==='apex'
        ? 'Arbiter: SEQ# tags enable ROB ordering. Contention meter shows cost of serialization.'
        : 'Without an arbiter, atomics serialize hidden inside L2 ‚Äî no visibility, high latency. Switch to Apex to see the full arbiter system.'
    },
    reg_spill: { title:'Register Spill ‚Üí L1 ‚Üí L2', color:'#fb923c',
      steps:[
        {text:'<strong>Register pressure</strong> ‚Äî warp exceeds physical register file.', micro:'Compiler emits spill code', delay:0},
        {text:'<strong>SPILL to L1</strong> ‚Äî excess live value written to L1 cache.', micro:'SPILL Rx ‚Üí [L1 addr]', delay:700},
        {text:'<strong>L1 hit (best case)</strong> ‚Äî spill absorbed, ~28 cycle penalty.', micro:'L1 tag lookup ‚Üí hit', delay:1500},
        {text:'<strong>L1 full ‚Üí cascade to L2</strong> ‚Äî spill misses L1, goes to L2.', micro:'SPILL ‚Üí RdReq ‚Üí Bus ‚Üí L2', delay:2400},
        {text:'<strong>RELOAD</strong> ‚Äî value fetched back when needed.', micro:'RELOAD Rx ‚Üê [L1/L2 addr]', delay:3400},
        {text:'<strong>Warp resumes</strong> ‚Äî register restored, execution continues.', micro:'~28‚Äì200 cycle stall total', delay:4200},
      ], summary:'Register spills are invisible in source but devastating in perf ‚Äî they turn register accesses into cache traffic.'
    },
    cp_async: { title:'cp.async ‚Äî Global ‚Üí SMEM (No Register Stall)', color:'#22d3ee',
      steps:[
        {text:'<strong>Warp issues cp.async</strong> ‚Äî initiates async DMA.', micro:'cp.async.ca smem[addr], [gmem]', delay:0},
        {text:'<strong>Warp continues immediately</strong> ‚Äî no register stall.', micro:'Next compute instruction runs', delay:400},
        {text:'<strong>Data fetches from global memory</strong> ‚Äî in background.', micro:'LD global ‚Üí bypass registers', delay:900},
        {text:'<strong>L2 serves the line</strong> ‚Äî or DRAM on L2 miss.', micro:'L2 slice lookup', delay:1700},
        {text:'<strong>Data lands directly in SMEM</strong> ‚Äî no register touch.', micro:'DATA ‚Üí SMEM (bypass reg file)', delay:2600},
        {text:'<strong>Warp barrier</strong> ‚Äî commit point ensures data is ready.', micro:'cp.async.commit_group / wait', delay:3400},
      ], summary:'cp.async decouples memory latency from compute ‚Äî the key to software pipelining on Ampere and Hopper.'
    },
    tma_load: { title:'TMA Load ‚Äî Tensor Tile ‚Üí SMEM (Hardware DMA)', color:'#22d3ee',
      steps:[
        {text:'<strong>One thread issues TMA descriptor</strong>', micro:'cp.async.bulk.tensor ... smem', delay:0},
        {text:'<strong>TMA engine takes over</strong> ‚Äî threads completely free.', micro:'HW DMA: address calc offloaded', delay:500},
        {text:'<strong>All threads compute on prev tile</strong>', micro:'WGMMA / tensor core compute', delay:1000},
        {text:'<strong>TMA fetches tile from global memory</strong>', micro:'TILE ‚Üí NoC ‚Üí L2 ‚Üí Bus', delay:1600},
        {text:'<strong>Tile arrives in SMEM</strong> ‚Äî zero register pressure.', micro:'TILE ‚Üí SMEM direct deposit', delay:2700},
        {text:'<strong>Barrier completes</strong> ‚Äî next tile ready for compute.', micro:'mbarrier::arrive_and_expect_tx', delay:3500},
      ], summary:'TMA completely hides memory latency ‚Äî one thread drives bulk DMA while all other threads compute. The Hopper pipeline model.'
    }
  };
  return e[type];
}

function showExplanation(type) {
  var exp = getExplanation(type); if (!exp) return;
  stepTimers.forEach(function(t){clearTimeout(t);}); stepTimers=[];
  var titleEl=document.getElementById('explainer-title');
  titleEl.innerHTML='<span class="dot" style="background:'+exp.color+'"></span> '+exp.title;
  titleEl.style.color=exp.color;
  var listEl=document.getElementById('step-list'); listEl.innerHTML='';
  var sumEl=document.getElementById('explainer-summary'); sumEl.textContent=''; sumEl.classList.remove('visible');
  exp.steps.forEach(function(s,i) {
    var li=document.createElement('li');
    var microText = s.micro;
    var microHtml = microText.replace(/\b(LD\.E|ST\.E|LDS|STS|ST\.S|RdReq|INV|DATA|WR|WB|RMW|EVICT|STORE|DSMEM|cp\.async|SPILL|RELOAD|TILE)\b/g, function(m) {
      return '<span class="micro-instr" data-instr="'+m+'" style="cursor:help;text-decoration:underline dotted;text-decoration-color:rgba(255,255,255,0.3)">'+m+'</span>';
    });
    li.innerHTML='<span class="step-num" style="background:'+exp.color+'20;color:'+exp.color+'">'+(i+1)+'</span><span class="step-text">'+s.text+'<span class="micro">'+microHtml+'</span></span>';
    listEl.appendChild(li);
    stepTimers.push(setTimeout(function() {
      var actives=listEl.querySelectorAll('li.active');
      for(var k=0;k<actives.length;k++){actives[k].classList.remove('active');actives[k].classList.add('past');}
      li.classList.add('visible','active');
    }, s.delay));
  });
  stepTimers.push(setTimeout(function() {
    sumEl.textContent=exp.summary; sumEl.classList.add('visible');
    var actives=listEl.querySelectorAll('li.active');
    for(var k=0;k<actives.length;k++){actives[k].classList.remove('active');actives[k].classList.add('past');}
  }, exp.steps[exp.steps.length-1].delay+1000));
}

function logEvent(msg, color) {
  var log=document.getElementById('event-log');
  var e=document.createElement('div'); e.className='log-entry';
  e.innerHTML='<span class="tag" style="background:'+color+'30;color:'+color+'">'+new Date().toLocaleTimeString().slice(0,8)+'</span> '+msg;
  log.prepend(e); if(log.children.length>40) log.lastChild.remove();
}

// Show a user-facing toast when an operation cannot run in the current state.
// Appears below the buttons, auto-dismisses after 3.5s.
function notifyUser(msg, reason, color) {
  var existing = document.getElementById('op-notice');
  if (existing) existing.remove();
  var el = document.createElement('div');
  el.id = 'op-notice';
  el.style.cssText = [
    'position:fixed','bottom:24px','left:50%','transform:translateX(-50%)',
    'background:#12141a','border:1px solid '+(color||'#f06595')+'60',
    'color:'+(color||'#f06595'),'padding:10px 18px','border-radius:8px',
    'font-family:JetBrains Mono,monospace','font-size:.78rem',
    'z-index:9999','pointer-events:none','text-align:center',
    'box-shadow:0 4px 24px rgba(0,0,0,.5)',
    'animation:fadeInUp .18s ease'
  ].join(';');
  el.innerHTML = '<strong>' + msg + '</strong>'
    + (reason ? '<br><span style="opacity:.65;font-size:.72rem">' + reason + '</span>' : '');
  document.body.appendChild(el);
  clearTimeout(notifyUser._timer);
  notifyUser._timer = setTimeout(function() {
    if (el.parentNode) el.remove();
  }, 3500);
}
// Inject the fadeInUp keyframe once
(function() {
  if (document.getElementById('op-notice-style')) return;
  var s = document.createElement('style');
  s.id = 'op-notice-style';
  s.textContent = '@keyframes fadeInUp{from{opacity:0;transform:translateX(-50%) translateY(10px)}to{opacity:1;transform:translateX(-50%) translateY(0)}}';
  document.head.appendChild(s);
})();

function updateStats() {
  document.getElementById('stat-hits').textContent=stats.hits;
  document.getElementById('stat-misses').textContent=stats.misses;
  document.getElementById('stat-inv').textContent=stats.inv;
  document.getElementById('stat-wb').textContent=stats.wb;
}

function triggerScenario(type, silent) {
  if (paused) togglePause();

  var si = Math.floor(Math.random()*layout.sms.length);
  showExplanation(type);
  var sm = layout.sms[si];

  // For write on non-Pascal, prefer an SM that has a Shared line so the write is meaningful
  if (type === 'write' && currentArch !== 'pascal') {
    for (var wi0 = 0; wi0 < layout.sms.length; wi0++) {
      if (layout.sms[wi0].l1.state === 'shared') { si = wi0; sm = layout.sms[si]; break; }
    }
  }

  // ‚îÄ‚îÄ Precondition enforcement ‚îÄ‚îÄ
  // Each scenario has requirements. If not met, tell the user clearly and abort.
  // In silent (auto) mode we abort silently ‚Äî no toast shown.
  if (type === 'write' && currentArch !== 'pascal') {
    var anyShared = layout.sms.some(function(s){ return s.l1.state === 'shared'; });
    if (!anyShared) {
      if (!silent) notifyUser('SM Write needs cached data first',
        'No SM has a Shared line in L1. Run SM Read first to populate the cache, then write.', '#51cf66');
      return;
    }
  }
  if (type === 'invalidate') {
    var anyValid = layout.sms.some(function(s){ return s.l1.state !== 'invalid'; });
    if (!anyValid) {
      if (!silent) notifyUser('Nothing to invalidate',
        'All L1 caches are already empty (Invalid). Run SM Read first to put data in L1.', '#f06595');
      return;
    }
  }
  if (type === 'writeback') {
    var anyModified = layout.sms.some(function(s){ return s.l1.state === 'modified'; });
    if (!anyModified) {
      if (!silent) notifyUser('No dirty data to write back',
        'Write-back needs a Modified (dirty) L1 line. Run SM Write first to dirty a line.', '#ffa94d');
      return;
    }
    for (var mi = 0; mi < layout.sms.length; mi++) {
      if (layout.sms[mi].l1.state === 'modified') { si = mi; sm = layout.sms[si]; break; }
    }
  }
  if (type === 'atomic' && currentArch === 'apex' && arbiterState.active) {
    if (!silent) notifyUser('Arbiter busy',
      'An atomic sequence is already in flight. Wait for it to complete or Reset.', '#f59e0b');
    return;
  }

  switch(type) {
    case 'read':
      if (sm.l1.state !== 'invalid') { sm.l1.state = 'invalid'; }
      stats.misses++;
      logEvent('SM'+si+': L1 read miss ‚Üí L2','#ff6b6b');
      bubble(l1Pos(si).x,l1Pos(si).y,'cache miss','#ff6b6b',{sub:'not in L1'});
      particles.push(new Particle(l1Pos(si),busP(si),'#ff6b6b','RdReq',2,function(){
        bubble(busP(si).x,busP(si).y,'going to L2','#ff6b6b',{life:1.4,sub:'fetch from below'});
        spawnPassthrough(si,'#ff6b6b','RdReq',2.5,function(){
          logEvent('L2: Hit ‚Üí data returning to SM'+si,'#ffa94d');
          l2AbsorbOne();
          bubble(l2Top().x,l2Top().y,'L2 found it','#51cf66',{life:1.5,sub:'data ready'});
          spawnParticle(l2Top(), l1Pos(si), '#ffa94d', 'DATA', 2, function(){
            sm.l1.state='shared'; fillL1Random(si, false); flash(sm.l1,'#339af0');
            bubble(l1Pos(si).x,l1Pos(si).y,'line cached','#339af0',{life:1.6,sub:'now Shared'});
            logEvent('SM'+si+': L1 ‚Üí Shared','#339af0');
            stats.hits++;
          }, [busP(si)]);
        });
      }));
      break;
    case 'write':
      if (currentArch==='pascal') {
        logEvent('SM'+si+': Write ‚Üí bus (L1 bypassed)','#51cf66');
        stats.hits++;
        var warpSrc = { x: sm.x + sm.w/2, y: sm.y + 18 };
        bubble(warpSrc.x, warpSrc.y, 'write bypass','#51cf66',{sub:'L1 read-only'});
        spawnParticle(warpSrc, l2Top(), '#51cf66', 'WR', 2, function(){
          flash(layout.l2,'#ffa94d'); l2AbsorbDirty();
          bubble(l2Top().x,l2Top().y,'L2 updated','#ffa94d',{life:1.5,sub:'write absorbed (dirty)'});
          logEvent('L2: Write-through received ‚Äî line dirty','#ffa94d');
        }, [busP(si)]);
      } else {
        stats.hits++;
        logEvent('SM'+si+': Write ‚Üí L1 Modified, INV others','#51cf66');
        bubble(l1Pos(si).x,l1Pos(si).y,'write hit','#51cf66',{sub:'L1 ‚Üí Modified'});
        var staleSMs = [];
        for (var wi=0;wi<layout.sms.length;wi++) {
          if (wi!==si && layout.sms[wi].l1.state==='shared') staleSMs.push(wi);
        }
        sm.l1.state='modified'; setL1Dirty(si); flash(sm.l1,'#51cf66');
        particles.push(new Particle(l1Pos(si),busP(si),'#51cf66','WR',2,function(){
          bubble(busP(si).x,busP(si).y,'announcing write','#51cf66',{life:1.2,sub:'INV outgoing'});
          if (staleSMs.length === 0) {
            logEvent('SM'+si+': No other sharers ‚Äî no INV needed','#51cf66');
            return;
          }
          if (currentArch === 'apex' && layout.cohDir) {
            var cdCentre = { x: layout.cohDir.x + layout.cohDir.w/2, y: layout.cohDir.y + layout.cohDir.h/2 };
            particles.push(new Particle(busP(si), l2Top(), '#f06595', 'WR‚ÜíDIR', 2.5, function(){
              flash(layout.cohDir, '#f06595');
              bubble(cdCentre.x, cdCentre.y, 'dir lookup','#f06595',{life:1.3,sub:'checking sharers'});
              logEvent('CohDir: '+staleSMs.length+' sharer(s) found ‚Üí targeted INV','#f06595');
              for (var wj=0;wj<staleSMs.length;wj++) {
                (function(idx){
                  setTimeout(function(){
                    spawnParticle(l2Top(), l1Pos(idx), '#f06595', 'INV', 2.8, function(){
                      layout.sms[idx].l1.state='invalid';
                      invalidateL1Lines(idx, 1 + Math.floor(Math.random()*2));
                      flash(layout.sms[idx].l1,'#f06595');
                      bubble(l1Pos(idx).x,l1Pos(idx).y,'line dropped','#f06595',{life:1.3,sub:'targeted INV'});
                      logEvent('SM'+idx+': 1-2 lines invalidated (targeted)','#f06595');
                      stats.inv++; updateStats();
                    }, [busP(idx)]);
                  }, wj*180);
                })(staleSMs[wj]);
              }
            }));
          } else {
            for (var wj=0;wj<staleSMs.length;wj++) {
              (function(idx){
                setTimeout(function(){
                  particles.push(new Particle(busP(si),busP(idx),'#f06595','INV',3,function(){
                    particles.push(new Particle(busP(idx),l1Pos(idx),'#f06595','INV',2,function(){
                      layout.sms[idx].l1.state='invalid';
                      invalidateL1Lines(idx, 1 + Math.floor(Math.random()*2));
                      flash(layout.sms[idx].l1,'#f06595');
                      bubble(l1Pos(idx).x,l1Pos(idx).y,'line dropped','#f06595',{life:1.3,sub:'addr match'});
                      logEvent('SM'+idx+': 1-2 lines invalidated','#f06595');
                      stats.inv++; updateStats();
                    }));
                  }));
                }, wj*180 + Math.round(Math.random()*60));
              })(staleSMs[wj]);
            }
          }
        }));
      }
      break;
    case 'invalidate':
      // validSMs already verified non-empty by precondition above
      var validSMs = [];
      for (var ii=0;ii<layout.sms.length;ii++) {
        if (layout.sms[ii].l1.state !== 'invalid') validSMs.push(ii);
      }
      stats.inv++;
      logEvent('Broadcast INV ‚Üí '+validSMs.length+' SM(s) with valid lines','#f06595');
      bubble((layout.bus.x1+layout.bus.x2)/2,layout.bus.y,'INV broadcast','#f06595',{sub:validSMs.length+' SM(s) targeted'});
      if (currentArch === 'apex' && layout.cohDir) {
        var cdPos2 = { x: layout.cohDir.x + layout.cohDir.w/2, y: layout.cohDir.y + layout.cohDir.h/2 };
        var busCenter = {x:(layout.bus.x1+layout.bus.x2)/2, y:layout.bus.y};
        particles.push(new Particle(busCenter, l2Top(), '#f06595', 'INV', 2.5, function(){
          flash(layout.cohDir, '#f06595');
          bubble(cdPos2.x, cdPos2.y, 'dir lookup','#f06595',{life:1.3,sub:validSMs.length+' sharer(s)'});
          logEvent('CohDir: targeted INV to '+validSMs.length+' SM(s)','#f06595');
          for (var vi=0;vi<validSMs.length;vi++) {
            (function(idx){
              setTimeout(function(){
                spawnParticle(l2Top(), l1Pos(idx), '#f06595', 'INV', 2.8, function(){
                  layout.sms[idx].l1.state = 'invalid';
                  invalidateL1Lines(idx, 1 + Math.floor(Math.random()*2));
                  flash(layout.sms[idx].l1,'#f06595');
                  bubble(l1Pos(idx).x,l1Pos(idx).y,'line(s) dropped','#f06595',{life:1.2,sub:'targeted'});
                }, [busP(idx)]);
              }, vi*140);
            })(validSMs[vi]);
          }
        }));
      } else {
        for (var vi=0;vi<validSMs.length;vi++) {
          (function(idx){
            setTimeout(function(){
              var from={x:(layout.bus.x1+layout.bus.x2)/2,y:layout.bus.y};
              particles.push(new Particle(from,busP(idx),'#f06595','INV',3,function(){
                particles.push(new Particle(busP(idx),l1Pos(idx),'#f06595','INV',2,function(){
                  layout.sms[idx].l1.state='invalid';
                  invalidateL1Lines(idx, 1 + Math.floor(Math.random()*2));
                  flash(layout.sms[idx].l1,'#f06595');
                  bubble(l1Pos(idx).x,l1Pos(idx).y,'line(s) dropped','#f06595',{life:1.2,sub:'addr match'});
                  logEvent('SM'+idx+': L1 line(s) invalidated','#f06595');
                }));
              }));
            }, vi*120 + Math.round(Math.random()*60));
          })(validSMs[vi]);
        }
      }
      break;
    case 'writeback':
      // Precondition already ensures sm is Modified ‚Äî only coerce lines if not already dirty
      if (sm.l1.state !== 'modified') { sm.l1.state='modified'; setL1Dirty(si); }
      logEvent('SM'+si+': Write-back ‚Üí L2','#ffa94d');
      bubble(l1Pos(si).x,l1Pos(si).y,'dirty evict','#ffa94d',{sub:'must flush out'});
      particles.push(new Particle(l1Pos(si),busP(si),'#ffa94d','WB',2,function(){
        spawnPassthrough(si,'#ffa94d','WB',2.5,function(){
          // WB arrives at L2: mark L1 evicted, dirty line now lives in L2
          sm.l1.state='invalid'; invalidateL1(si); l2Dirty(); stats.wb++;
          flash(layout.l2,'#ffa94d');
          bubble(l2Top().x,l2Top().y,'L2 absorbed','#ffa94d',{life:1.4,sub:'dirty ‚Üí L2'});
          logEvent('L2: Write-back received ‚Äî line dirty in L2','#ffa94d');
          // Eviction only fires if L2 is >75% full (realistic pressure)
          var l2FilledCount = 0;
          for (var li=0;li<NUM_L2_LINES;li++) if(l2Lines[li]>0) l2FilledCount++;
          if (l2FilledCount / NUM_L2_LINES > 0.75) {
            setTimeout(function(){
              l2Evict();
              bubble(l2Bot().x,l2Bot().y,'L2 evicting','#339af0',{life:1.3,sub:'victim to DRAM'});
              particles.push(new Particle(l2Bot(),cbP(),'#339af0','EVICT',2,function(){
                particles.push(new Particle(cbP(),gmTop(),'#339af0','WR',2,function(){
                  flash(layout.globalMem,'#339af0');
                  bubble(gmTop().x,gmTop().y,'queued MC','#339af0',{life:1.2,sub:'scheduling write'});
                  particles.push(new Particle(gmTop(),gmBot(),'#339af0','WR',2,function(){
                    particles.push(new Particle(gmBot(),hbmTop(),'#845ef7','STORE',1.5,function(){
                      flash(layout.hbm,'#845ef7');
                      bubble(hbmTop().x,hbmTop().y,'persisted','#845ef7',{life:1.5,sub:'written to DRAM'});
                      logEvent(ARCHS[currentArch].blocks.hbm.label+': Stored','#845ef7');
                    }));
                  }));
                }));
              }));
            },500);
          } else {
            logEvent('L2: Dirty line retained ‚Äî no eviction needed','#ffa94d');
          }
        });
      }));
      break;
    case 'shared':
      var smemBlock=null;
      for(var sbi=0;sbi<sm.sub.length;sbi++){if(sm.sub[sbi].type==='smem')smemBlock=sm.sub[sbi];}
      if(!smemBlock) break;
      logEvent('SM'+si+': SMEM access','#51cf66');
      flash(smemBlock,'#51cf66'); stats.hits++;
      fillSmem(si);
      bubble(sm.x+sm.w/2,sm.y+14,'no coherency','#51cf66',{sub:'SM-private scratchpad'});
      var regsBlockEl=null;
      for(var ri=0;ri<sm.sub.length;ri++){if(sm.sub[ri].type==='regs')regsBlockEl=sm.sub[ri];}
      var sfrom={x:sm.x+sm.w/2,y:regsBlockEl?regsBlockEl.y+3:sm.y+40};
      particles.push(new Particle(sfrom,{x:smemBlock.x+smemBlock.w/2,y:smemBlock.y+smemBlock.h/2},'#51cf66','ST.S',1.5,function(){
        bubble(smemBlock.x+smemBlock.w/2,smemBlock.y,'~20 cycles','#51cf66',{life:1.4,sub:'fast SRAM hit'});
      }));
      if (currentArch==='hopper'&&layout.sms.length>1) {
        var other=(si+1)%layout.sms.length;
        var otherDsmem=null, myDsmem=null;
        for(var od=0;od<layout.sms[other].sub.length;od++){if(layout.sms[other].sub[od].type==='dsmem')otherDsmem=layout.sms[other].sub[od];}
        for(var md=0;md<sm.sub.length;md++){if(sm.sub[md].type==='dsmem')myDsmem=sm.sub[md];}
        if(otherDsmem&&myDsmem){
          setTimeout(function(){
            logEvent('SM'+si+' ‚Üí SM'+other+': DSMEM read','#22d3ee');
            bubble(myDsmem.x+myDsmem.w/2,myDsmem.y,'peer read','#22d3ee',{sub:'cross-SM memory'});
            particles.push(new Particle(
              {x:myDsmem.x+myDsmem.w/2,y:myDsmem.y+myDsmem.h/2},
              {x:otherDsmem.x+otherDsmem.w/2,y:otherDsmem.y+otherDsmem.h/2},
              '#22d3ee','DSMEM',2,function(){
                flash(otherDsmem,'#22d3ee');
                bubble(otherDsmem.x+otherDsmem.w/2,otherDsmem.y,'cluster hit','#22d3ee',{life:1.4,sub:'no bus needed'});
              }
            ));
          },800);
        }
      }
      break;
    case 'atomic':
      triggerAtomic();
      return;

    case 'reg_spill': {
      var regsP = regsPos(si);
      var l1B = layout.sms[si].l1;
      var l1P = l1Pos(si);
      logEvent('SM'+si+': register pressure ‚Äî spilling to L1', '#fb923c');
      bubble(regsP.x, regsP.y, 'reg pressure', '#fb923c', {sub:'out of registers'});
      stats.misses++;
      setRegPressure(si, 1.10);
      spawnParticle(regsP, l1P, '#fb923c', 'SPILL', 2.2, function() {
        var l1Full = (function() {
          var cs = cacheState[si]; if (!cs) return false;
          var filled = 0; for (var i=0;i<NUM_LINES;i++) if(cs.l1[i]>0) filled++;
          return filled >= NUM_LINES - 2;
        })();
        if (!l1Full) {
          fillL1Random(si, false); flash(l1B, '#fb923c');
          bubble(l1P.x, l1P.y, 'spill hit L1', '#fb923c', {sub:'~28 cycle penalty'});
          logEvent('SM'+si+': spill ‚Üí L1 hit (~28 cycles)', '#fb923c');
          setTimeout(function() {
            logEvent('SM'+si+': RELOAD ‚Üê L1', '#fb923c');
            spawnParticle(l1P, regsP, '#fb923c', 'RELOAD', 2.2, function() {
              flash(regsBlock(si) || layout.sms[si], '#fb923c');
              bubble(regsP.x, regsP.y, 'reg restored', '#51cf66', {sub:'warp resumes', life:1.8});
              logEvent('SM'+si+': register restored ‚Äî warp resumes', '#51cf66');
              setRegPressure(si, 0.72 + Math.random() * 0.08);
              stats.hits++; updateStats();
            });
          }, 800);
        } else {
          bubble(l1P.x, l1P.y, 'L1 full!', '#ff6b6b', {sub:'spill ‚Üí L2'});
          logEvent('SM'+si+': L1 full ‚Äî spill cascades to L2 (~200 cycles)', '#ff6b6b');
          spawnPassthrough(si, '#fb923c', 'SPILL', 2.2, function() {
            l2AbsorbOne(); flash(layout.l2, '#fb923c');
            bubble(l2Top().x, l2Top().y, 'spill in L2', '#fb923c', {sub:'~200 cycle penalty'});
            logEvent('L2: spill absorbed', '#fb923c');
            setTimeout(function() {
              logEvent('SM'+si+': RELOAD ‚Üê L2', '#fb923c');
              spawnParticle(l2Top(), l1P, '#fb923c', 'RELOAD', 2, function() {
                spawnParticle(l1P, regsP, '#fb923c', 'RELOAD', 2.2, function() {
                  flash(regsBlock(si) || layout.sms[si], '#fb923c');
                  bubble(regsP.x, regsP.y, 'reg restored', '#51cf66', {sub:'~200 cyc stall', life:1.8});
                  logEvent('SM'+si+': register restored from L2', '#51cf66');
                  setRegPressure(si, 0.72 + Math.random() * 0.08);
                  stats.hits++; updateStats();
                });
              }, [busP(si)]);
            }, 700);
          });
        }
      });
      break;
    }

    case 'cp_async': {
      var smemB = subBlock(si, 'smem');
      var asyncB = subBlock(si, 'async');
      if (!smemB) { logEvent('No SMEM block found', '#ff6b6b'); break; }
      var smemCentre = { x: smemB.x + smemB.w/2, y: smemB.y + smemB.h/2 };
      var asyncSrc   = asyncB
        ? { x: asyncB.x + asyncB.w/2, y: asyncB.y + asyncB.h/2 }
        : { x: layout.sms[si].x + layout.sms[si].w/2, y: layout.sms[si].y + layout.sms[si].h - 8 };
      logEvent('SM'+si+': cp.async issued ‚Äî warp continues immediately', '#22d3ee');
      bubble(asyncSrc.x, asyncSrc.y, 'cp.async issued', '#22d3ee', {sub:'warp not stalled'});
      if (asyncB) flash(asyncB, '#22d3ee');
      stats.misses++;
      setRegPressure(si, 0.80 + Math.random() * 0.08);
      setTimeout(function() {
        var rb = regsBlock(si);
        if (rb) {
          flash(rb, '#a78bfa');
          bubble(regsPos(si).x, regsPos(si).y, 'computing‚Ä¶', '#a78bfa', {sub:'warp not stalled', life:2.0});
          logEvent('SM'+si+': warp computes on prev tile while data fetches', '#a78bfa');
        }
      }, 300);
      spawnParticle(gmTop(), l2Top(), '#22d3ee', 'cp.async', 2.0, function() {
        l2AbsorbOne(); flash(layout.l2, '#22d3ee');
        bubble(l2Top().x, l2Top().y, 'L2 serving', '#22d3ee', {sub:'async DMA path'});
        spawnParticle(l2Top(), smemCentre, '#22d3ee', 'DATA', 2.2, function() {
          fillSmem(si); flash(smemB, '#22d3ee');
          bubble(smemCentre.x, smemCentre.y, 'data in SMEM', '#22d3ee', {sub:'regs untouched!', life:1.8});
          logEvent('SM'+si+': cp.async complete ‚Äî SMEM filled, no register used', '#22d3ee');
          stats.hits++; updateStats();
          setTimeout(function() {
            if (asyncB) flash(asyncB, '#51cf66');
            bubble(asyncSrc.x, asyncSrc.y, 'barrier done', '#51cf66', {sub:'tile committed', life:1.4});
            logEvent('SM'+si+': cp.async.wait complete ‚Äî tile ready', '#51cf66');
          }, 400);
        }, [busP(si)]);
      }, [cbP()]);
      break;
    }

    case 'tma_load': {
      var tmaB = subBlock(si, 'tma');
      var smemBt = subBlock(si, 'smem');
      if (!tmaB || !smemBt) { logEvent('TMA/SMEM block not found', '#ff6b6b'); break; }
      var tmaCentre   = { x: tmaB.x + tmaB.w/2, y: tmaB.y + tmaB.h/2 };
      var smemCentreT = { x: smemBt.x + smemBt.w/2, y: smemBt.y + smemBt.h/2 };
      logEvent('SM'+si+': TMA descriptor issued ‚Äî HW DMA takes over', '#22d3ee');
      bubble(tmaCentre.x, tmaCentre.y, 'TMA issued', '#22d3ee', {sub:'HW DMA starts'});
      flash(tmaB, '#22d3ee');
      stats.misses++;
      setTimeout(function() {
        for (var ti = 0; ti < layout.sms.length; ti++) {
          var rb2 = regsBlock(ti); if (rb2) flash(rb2, '#a78bfa');
          setRegPressure(ti, 0.82 + Math.random() * 0.08);
        }
        bubble(regsPos(si).x, regsPos(si).y, 'all threads', '#a78bfa', {sub:'computing prev tile', life:2.2});
        logEvent('All SM'+si+' threads: computing on prev tile', '#a78bfa');
      }, 200);
      var tileCount = 2 + Math.floor(Math.random() * 2);
      (function fetchTile(tileIdx) {
        if (tileIdx >= tileCount) return;
        setTimeout(function() {
          logEvent('TMA: fetching tile '+tileIdx+' from global memory', '#22d3ee');
          spawnParticle(gmTop(), l2Top(), '#22d3ee', 'TILE', 2.2, function() {
            l2AbsorbOne();
            bubble(l2Top().x, l2Top().y, 'tile '+tileIdx+' from L2', '#22d3ee', {sub:'DMA path', life:1.2});
            spawnParticle(l2Top(), smemCentreT, '#22d3ee', 'TILE', 2.4, function() {
              fillSmem(si); flash(smemBt, '#22d3ee');
              bubble(smemCentreT.x, smemCentreT.y, 'tile '+tileIdx+' ready', '#22d3ee', {sub:'SMEM filled', life:1.4});
              logEvent('SM'+si+': tile '+tileIdx+' landed in SMEM', '#22d3ee');
              if (tileIdx === tileCount - 1) {
                stats.hits++; updateStats();
                setTimeout(function() {
                  flash(tmaB, '#51cf66');
                  bubble(tmaCentre.x, tmaCentre.y, 'mbarrier done', '#51cf66', {sub:'all tiles ready', life:1.6});
                  logEvent('SM'+si+': TMA complete ‚Äî mbarrier arrived', '#51cf66');
                }, 300);
              }
            }, [busP(si)]);
          }, [cbP()]);
          fetchTile(tileIdx + 1);
        }, tileIdx * 900);
      })(0);
      break;
    }
  }
  updateStats();
}


// arbiter.js ‚Äî GPU Cache Coherency Demo

// Atomic arbiter state machine, ROB, spawn helpers, app utils

function toggleAuto() {
  autoMode=!autoMode;
  document.getElementById('btn-auto').classList.toggle('active',autoMode);
}

function resetAll(silent) {
  particles=[]; flashEffects=[]; bubbles=[];
  stats={hits:0,misses:0,inv:0,wb:0}; updateStats();
  for(var ri=0;ri<layout.sms.length;ri++){layout.sms[ri].l1.state='invalid';}
  initCacheState();
  document.getElementById('event-log').innerHTML='';
  stepTimers.forEach(function(t){clearTimeout(t);}); stepTimers=[];
  document.getElementById('explainer-title').innerHTML='<span class="dot" style="background:#6b7094"></span> Click a scenario or wait for auto...';
  document.getElementById('explainer-title').style.color='#6b7094';
  document.getElementById('step-list').innerHTML='';
  var s=document.getElementById('explainer-summary'); s.textContent=''; s.classList.remove('visible');
  autoTimer=0;
  // Also unpause on reset
  if (paused) togglePause();
  resetArbiter();
  if(!silent) logEvent('Reset ‚Äî all caches invalidated','#6b7094');
}

function buildInstrChips() {
  var container = document.getElementById('instr-chips');
  if (!container) return;
  container.innerHTML = '';
  var keys = Object.keys(INSTRUCTION_INFO);
  keys.forEach(function(key) {
    var info = INSTRUCTION_INFO[key];
    var chip = document.createElement('span');
    chip.className = 'instr-chip';
    chip.textContent = key;
    chip.style.background = info.color + '18';
    chip.style.color = info.color;
    chip.style.borderColor = info.color + '50';
    chip.addEventListener('mouseenter', function(e) {
      showInstrTooltip(key, e.clientX, e.clientY);
    });
    chip.addEventListener('mousemove', function(e) {
      positionInstrTooltip(e.clientX, e.clientY);
    });
    chip.addEventListener('mouseleave', function() {
      hideInstrTooltip();
    });
    container.appendChild(chip);
  });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// APEX ARBITER STATE SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
var QUEUE_CAPACITY = 6;  // hard limit ‚Äî arrivals beyond this stall at the bus interface

var arbiterState = {
  seqCounter: 0,
  queue: [],       // pending requests waiting for grant (arrival order = grant order)
  rob: [],         // reorder buffer: [{seq, smIdx, state:'pending'|'complete'|'retiring'|'done'}]
  activeOps: [],   // [{seq, smIdx, phase, phaseName, phaseStart}] ‚Äî live phase tracking
  grantCount: 0,
  contentionLevel: 0,
  recentGrants: [],
  active: false,
  retireTimerPending: false,  // guards against duplicate ghost timers in arbiterTryRetire
};


function resetArbiter() {
  arbiterState.seqCounter = 0;
  arbiterState.queue = [];
  arbiterState.rob = [];
  arbiterState.activeOps = [];
  arbiterState.grantCount = 0;
  arbiterState.contentionLevel = 0;
  arbiterState.recentGrants = [];
  arbiterState.active = false;
  arbiterState.retireTimerPending = false;
  updateArbiterDom();
}

function arbiterEnqueue(smIdx, type) {
  if (currentArch !== 'apex') return -1;
  // Queue full ‚Üí back-pressure. Caller stalls the particle at the bus interface.
  if (arbiterState.queue.length >= QUEUE_CAPACITY) return -1;
  var seq = arbiterState.seqCounter++;
  arbiterState.queue.push({ seq: seq, smIdx: smIdx, type: type || 'ATOM' });
  arbiterState.rob.push({ seq: seq, smIdx: smIdx, state: 'pending' });
  arbiterState.activeOps.push({ seq: seq, smIdx: smIdx, phase: 'queued', phaseName: ARB_PHASES.queued.label, phaseStart: Date.now() });
  arbiterState.contentionLevel = Math.min(1, arbiterState.queue.length / QUEUE_CAPACITY);
  arbiterState.active = true;
  var qPos = queueSlotPos(arbiterState.queue.length - 1);
  bubble(qPos.x, qPos.y, '#'+seq, '#f59e0b', { sub:'SM'+smIdx+' queued', life:1.1 });
  var rPos = robSlotPos(arbiterState.rob.length - 1);
  bubble(rPos.x, rPos.y, '#'+seq, '#f59e0b', { sub:'‚è≥ pending', life:1.0 });
  updateArbiterDom();
  return seq;
}

function arbiterGrant(seq) {
  if (currentArch !== 'apex') return;
  // Mark as granted ‚Äî change phase and show bubble, but KEEP the queue slot.
  // The slot stays visible until the RMW physically enters the arbiter (arbiterDequeue).
  // This way the queue shows the full occupancy picture: pending + in-transit.
  var qIdx = -1;
  for (var qi = 0; qi < arbiterState.queue.length; qi++) {
    if (arbiterState.queue[qi].seq === seq) { qIdx = qi; break; }
  }
  if (qIdx >= 0) {
    arbiterState.queue[qIdx].granted = true;  // visually distinguish granted-but-not-entered
    var qPos = queueSlotPos(qIdx);
    bubble(qPos.x, qPos.y, '#'+seq+' granted', '#51cf66', { sub:'‚Üí RMW', life:1.0 });
  }
  for (var ao = 0; ao < arbiterState.activeOps.length; ao++) {
    if (arbiterState.activeOps[ao].seq === seq) {
      arbiterState.activeOps[ao].phase = 'granted';
      arbiterState.activeOps[ao].phaseName = ARB_PHASES.granted.label;
      arbiterState.activeOps[ao].phaseStart = Date.now();
      break;
    }
  }
  arbiterState.grantCount++;
  var cycles = Math.round(2 + arbiterState.queue.length * 8 + Math.random() * 6);
  arbiterState.recentGrants.unshift({ seq: seq, cycles: cycles });
  if (arbiterState.recentGrants.length > 4) arbiterState.recentGrants.pop();
  updateArbiterDom();
}

// Called when the granted RMW particle physically enters the arbiter top.
// Only now does the queue slot free up ‚Äî back-pressure lifts here.
function arbiterDequeue(seq) {
  if (currentArch !== 'apex') return;
  arbiterState.queue = arbiterState.queue.filter(function(e){ return e.seq !== seq; });
  arbiterState.contentionLevel = Math.min(1, arbiterState.queue.length / QUEUE_CAPACITY);
  updateArbiterDom();
}

// Called when ACK physically arrives back from L2 for a given SEQ#
// Marks ROB slot 'complete' but does NOT send DATA yet ‚Äî that waits for in-order retirement
// Returns a callback that the caller should invoke to actually send DATA when retirement is allowed
function arbiterAckFromL2(seq, onRetired) {
  if (currentArch !== 'apex') { if (onRetired) onRetired(); return; }
  var robIdx = -1;
  for (var ri = 0; ri < arbiterState.rob.length; ri++) {
    if (arbiterState.rob[ri].seq === seq) {
      arbiterState.rob[ri].state = 'complete';
      arbiterState.rob[ri].onRetired = onRetired;
      robIdx = ri;
      break;
    }
  }
  // Bubble on the exact ROB slot that just flipped to 'complete'
  if (robIdx >= 0) {
    var rPos = robSlotPos(robIdx);
    var isHead = robIdx === 0;
    bubble(rPos.x, rPos.y, '#'+seq+' ‚ú¶', '#339af0', { sub: isHead ? 'head‚Üíretire' : 'waiting‚Ä¶', life:1.1 });
  }
  for (var ao = 0; ao < arbiterState.activeOps.length; ao++) {
    if (arbiterState.activeOps[ao].seq === seq) {
      arbiterState.activeOps[ao].phase = 'retiring';
      arbiterState.activeOps[ao].phaseName = ARB_PHASES.retiring.label;
      arbiterState.activeOps[ao].phaseStart = Date.now();
      break;
    }
  }
  updateArbiterDom();
  arbiterTryRetire();
}

// Drain ROB head: retire all consecutive 'complete' entries in SEQ order.
// This is the actual reordering ‚Äî if #3 finishes before #2, it waits here.
//
// Fix Bug #1: replaced `changed = true` + while-loop continuation with an
//   immediate `return` after marking a head 'done'. The removal setTimeout
//   calls arbiterTryRetire() itself once the slot is gone, so the chain
//   continues correctly without racing the while loop.
//
// Fix Bug #3: `retireTimerPending` flag prevents accumulating duplicate
//   ghost timers when arbiterTryRetire() is called while the head is still
//   in its 600ms removal window (state === 'done').
function arbiterTryRetire() {
  if (arbiterState.rob.length === 0) return;

  var head = arbiterState.rob[0];

  // Head is already marked 'done' but not yet removed ‚Äî removal timer is
  // running. Guard against scheduling duplicate re-check timers.
  if (head.state === 'done') {
    if (!arbiterState.retireTimerPending) {
      arbiterState.retireTimerPending = true;
      setTimeout(function() {
        arbiterState.retireTimerPending = false;
        arbiterTryRetire();
      }, 650);
    }
    return;
  }

  // Head not yet complete ‚Äî nothing to retire right now.
  if (head.state !== 'complete') return;

  // Retire the head: mark done, fire callback, schedule removal.
  head.state = 'done';
  var rPos = robSlotPos(0);
  bubble(rPos.x, rPos.y, '#'+head.seq+' ‚úì', '#51cf66', { sub:'retired‚ÜíDATA', life:1.2 });
  updateArbiterDom();

  var cb = head.onRetired;
  if (cb) cb();  // send DATA to SM ‚Äî fires immediately (correct: retirement is the trigger)

  (function(entry) {
    setTimeout(function() {
      arbiterState.rob = arbiterState.rob.filter(function(e){ return e.seq !== entry.seq; });
      arbiterState.activeOps = arbiterState.activeOps.filter(function(e){ return e.seq !== entry.seq; });
      if (arbiterState.queue.length === 0 && arbiterState.rob.length === 0) {
        arbiterState.active = false;
        arbiterState.contentionLevel = 0;
      }
      updateArbiterDom();
      // Try to retire the next head now that this slot is removed.
      arbiterTryRetire();
    }, 600);
  })(head);
  // Do NOT continue the loop here ‚Äî the 600ms setTimeout above will call
  // arbiterTryRetire() for the next entry once this slot is fully removed.
}

// Legacy wrapper kept for any remaining call sites
function arbiterRetire(seq) {
  // No-op ‚Äî retirement now handled by arbiterAckFromL2 + arbiterTryRetire
}

function updateArbiterDom() {
  // State-only update ‚Äî rendering is done entirely on canvas
  // Nothing to update in DOM since we removed the arbiter panel
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LATENCY ANNOTATION TOASTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// APEX HELPERS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function arbiterPos() {
  if (!layout.arbiter) return l2Top();
  return { x: layout.arbiter.x + layout.arbiter.w/2, y: layout.arbiter.y + layout.arbiter.h/2 };
}
function arbiterBot() {
  if (!layout.arbiter) return l2Top();
  return { x: layout.arbiter.x + layout.arbiter.w/2, y: layout.arbiter.y + layout.arbiter.h };
}
function arbiterTop() {
  if (!layout.arbiter) return l2Top();
  return { x: layout.arbiter.x + layout.arbiter.w/2, y: layout.arbiter.y };
}
// Point on the coherency bus directly above arbiter centre ‚Äî waypoint for routed particles
function arbiterBusEntry() {
  if (!layout.arbiter || !layout.bus) return arbiterTop();
  return { x: layout.arbiter.x + layout.arbiter.w/2, y: layout.bus.y };
}
// ‚îÄ‚îÄ Slot pixel-position helpers ‚îÄ‚îÄ
// Return {x,y} centre of a queue slot or ROB slot so bubbles appear ON the slot itself.
// Uses the same layout arithmetic as the canvas draw loop.
function queueSlotPos(slotIdx) {
  if (!layout.arbiter) return arbiterPos();
  var arb = layout.arbiter;
  var divX    = arb.x + arb.w * 0.48;
  var qLabelX = arb.x + 12;
  var innerY  = arb.y + 21;
  var slotH2  = 15, slotGap2 = 4, qSlotW2 = 24;
  var qSlotY  = innerY + 11;
  var sx = qLabelX + slotIdx * (qSlotW2 + slotGap2);
  return { x: sx + qSlotW2 / 2, y: qSlotY + slotH2 / 2 };
}
function robSlotPos(slotIdx) {
  if (!layout.arbiter) return arbiterPos();
  var arb = layout.arbiter;
  var divX     = arb.x + arb.w * 0.48;
  var robLabelX= divX + 18;
  var innerY   = arb.y + 21;
  var slotH2   = 15, slotGap2 = 4;
  var robSlotW2= Math.max(Math.floor((arb.x + arb.w - robLabelX - 12) / 6) - slotGap2, 18);
  var robSlotY = innerY + 11;
  var rx = robLabelX + slotIdx * (robSlotW2 + slotGap2);
  return { x: rx + robSlotW2 / 2, y: robSlotY + slotH2 / 2 };
}
// Route a particle through the bus correctly:
// from l1 ‚Üí busP(smIdx) ‚Üí arbiterBusEntry ‚Üí arbiterTop (two right-angle turns, no diagonals)
function spawnRoutedToArbiter(smIdx, color, label, speed, onArrival) {
  var fromPos  = l1Pos(smIdx);
  var busJunct = busP(smIdx);
  var busAbove = arbiterBusEntry();
  var dest     = arbiterTop();
  // leg 1: L1 ‚Üí bus junction (vertical up)
  particles.push(new Particle(fromPos, busJunct, color, label, speed, function() {
    // leg 2: bus junction ‚Üí arbiter bus entry (horizontal along bus)
    particles.push(new Particle(busJunct, busAbove, color, label, speed * 1.1, function() {
      // leg 3: bus entry ‚Üí arbiter top (vertical down)
      particles.push(new Particle(busAbove, dest, color, label, speed, function() {
        if (onArrival) onArrival();
      }));
    }));
  }));
}
// Route a GRANT signal from arbiter back to SM.
// GRANT is a control signal received by the warp scheduler ‚Äî it travels all the
// way down to the SM's warp scheduler block so it's visually clear which SM got the grant.
function spawnGrantToSM(smIdx, onArrival) {
  var busAbove = arbiterBusEntry();
  var busJunct = busP(smIdx);
  // Find the warp scheduler block for this SM so GRANT visibly lands there
  var warpDest = busJunct; // fallback: stop at bus junction
  var sm = layout.sms[smIdx];
  if (sm) {
    for (var bi = 0; bi < sm.sub.length; bi++) {
      if (sm.sub[bi].type === 'warpScheduler') {
        warpDest = { x: sm.sub[bi].x + sm.sub[bi].w/2, y: sm.sub[bi].y + sm.sub[bi].h/2 };
        break;
      }
    }
    // If no warp scheduler block, land at bottom of SM
    if (warpDest === busJunct) {
      warpDest = { x: sm.x + sm.w/2, y: sm.y + sm.h - 8 };
    }
  }
  // Route: arbiterBusEntry (bus level) ‚Üí busP(smIdx) ‚Üí warpDest (inside SM)
  particles.push(new Particle(busAbove, busJunct, '#51cf66', 'GRANT', 3.0, function() {
    particles.push(new Particle(busJunct, warpDest, '#51cf66', 'GRANT', 2.5, function() {
      if (onArrival) onArrival();
    }));
  }));
}
// Route DATA from arbiter back to SM's L1 via the bus.
// Starts from arbiterBusEntry (bus level above arbiter) ‚Äî NOT from arbiterTop ‚Äî
// so the particle never visually passes back through the arbiter block body.
function spawnRoutedFromArbiter(smIdx, color, label, speed, onArrival) {
  var busAbove = arbiterBusEntry();
  var busJunct = busP(smIdx);
  var dest     = l1Pos(smIdx);
  // Route: arbiterBusEntry ‚Üí busP(smIdx) ‚Üí l1Pos(smIdx)
  particles.push(new Particle(busAbove, busJunct, color, label, speed * 1.1, function() {
    particles.push(new Particle(busJunct, dest, color, label, speed, function() {
      if (onArrival) onArrival();
    }));
  }));
}
// Passthrough: flash arbiter briefly when a non-atomic op crosses it on Apex
// Shows a dim pulse and a small label ‚Äî particles routed through it as a waypoint
function spawnPassthrough(smIdx, color, label, speed, onArrival) {
  if (currentArch !== 'apex' || !layout.arbiter) {
    // Non-Apex: go straight bus ‚Üí L2 as before
    particles.push(new Particle(busP(smIdx), l2Top(), color, label, speed, onArrival));
    return;
  }
  var busJunct  = busP(smIdx);
  var busAbove  = arbiterBusEntry();
  var arbEntry  = arbiterTop();
  var arbExit   = arbiterBot();
  var l2dest    = l2Top();
  // leg 1: bus junction ‚Üí bus-above-arbiter (horizontal)
  particles.push(new Particle(busJunct, busAbove, color, label, speed * 1.1, function() {
    // leg 2: bus above ‚Üí arbiter top (enter arbiter ‚Äî vertical down)
    particles.push(new Particle(busAbove, arbEntry, color, label, speed, function() {
      // Passthrough pulse on arbiter
      flashEffects.push({ x:layout.arbiter.x, y:layout.arbiter.y, w:layout.arbiter.w, h:layout.arbiter.h,
        c: color, t:0, dur:0.35 });
      // leg 3: arbiter top ‚Üí arbiter bottom (pass through ‚Äî very short, vertical)
      particles.push(new Particle(arbEntry, arbExit, color, 'PASS', speed * 1.5, function() {
        // leg 4: arbiter bottom ‚Üí L2 top (exit to L2)
        particles.push(new Particle(arbExit, l2dest, color, label, speed, function() {
          if (onArrival) onArrival();
        }));
      }));
    }));
  }));
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ATOMIC SCENARIO
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// atomic.js ‚Äî GPU Cache Coherency Demo

// Atomic scenario, app startup, canvas event listeners

function triggerAtomic() {
  if (paused) togglePause();
  var smCount2 = layout.sms.length;
  var isApex = currentArch === 'apex';
  showExplanation('atomic');

  if (isApex) {
    // ‚îÄ‚îÄ APEX: Arbiter-serialized atomicAdd ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if (arbiterState.active) return;
    logEvent('atomicAdd: ' + smCount2 + ' SMs ‚Üí Arbiter', '#f59e0b');
    bubble((layout.bus.x1+layout.bus.x2)/2, layout.bus.y-12, 'atomic storm', '#f59e0b', { sub: smCount2+' reqs inbound', life:2.0 });
    resetArbiter();

    // Grant serialization: only one grant is outstanding at a time.
    // The ATOM is already physically inside the arbiter when granted ‚Äî
    // we just need to route it arbEntry‚ÜíarbExit‚ÜíL2, not re-traverse the bus.
    var pendingGrants = [];   // {seq, smIdx} ‚Äî fifo, head gets issued next
    var grantInFlight = false; // only one grant+RMW in flight through arbiter at once

    function tryNextGrant() {
      if (grantInFlight || pendingGrants.length === 0) return;
      var head = pendingGrants.shift();
      grantInFlight = true;
      issueGrant(head.seq, head.smIdx);
    }

    function issueGrant(seq, smIdx) {
      arbiterGrant(seq);
      logEvent('ARBITER: GRANT SEQ#'+seq+' ‚Üí SM'+smIdx, '#51cf66');

      // Step 1: Send GRANT signal down to SM (control signal only, no data)
      spawnGrantToSM(smIdx, function() {
        // GRANT arrived at SM's bus junction ‚Äî warp scheduler ACKs.
        // The ATOM is already at arbiterTop waiting ‚Äî now route it through arbiter ‚Üí L2.
        (function(capturedSeq, capturedIdx) {
          for (var pa = 0; pa < arbiterState.activeOps.length; pa++) {
            if (arbiterState.activeOps[pa].seq === capturedSeq) {
              arbiterState.activeOps[pa].phase = 'rmw';
              arbiterState.activeOps[pa].phaseName = ARB_PHASES.rmw.label;
              arbiterState.activeOps[pa].phaseStart = Date.now();
              break;
            }
          }

          // Dequeue now ‚Äî slot frees as the ATOM proceeds
          arbiterDequeue(capturedSeq);

          var arbEntry = arbiterTop();
          var arbExit  = arbiterBot();
          var l2dest   = l2Top();

          // Step 2: RMW travels through arbiter body (arbEntry ‚Üí arbExit)
          particles.push(new Particle(arbEntry, arbExit, '#f59e0b', 'RMW', 2.0, function() {
            // Arbiter body exited ‚Äî next grant can now issue (queue slot freed above)
            grantInFlight = false;
            tryNextGrant();  // issue next grant now that arbiter body is clear

            // Step 3: RMW exits arbiter ‚Üí L2
            particles.push(new Particle(arbExit, l2dest, '#f59e0b', 'RMW', 2.0, function() {
              flash(layout.l2, '#f59e0b');
              logEvent('L2: RMW SEQ#'+capturedSeq+' complete', '#ffa94d');
              for (var pb = 0; pb < arbiterState.activeOps.length; pb++) {
                if (arbiterState.activeOps[pb].seq === capturedSeq) {
                  arbiterState.activeOps[pb].phase = 'ack';
                  arbiterState.activeOps[pb].phaseName = ARB_PHASES.ack.label;
                  arbiterState.activeOps[pb].phaseStart = Date.now();
                  break;
                }
              }
              // L2 jitter: bimodal ‚Äî 60% fast bank (50-180ms), 40% busy bank (320-600ms)
              var l2Jitter = Math.random() < 0.6
                ? 50  + Math.random() * 130
                : 320 + Math.random() * 280;
              setTimeout(function() {
                // Step 4: ACK returns from L2 ‚Üí up through arbiter ‚Üí bus level
                // l2Top ‚Üí arbExit (bottom of arbiter) ‚Üí arbiterBusEntry (bus level)
                // This makes the ACK visibly traverse the arbiter body upward
                particles.push(new Particle(l2Top(), arbExit, '#ffa94d', 'ACK#'+capturedSeq, 2.0, function() {
                  // ACK enters arbiter bottom ‚Äî travel up through arbiter body to bus level
                  particles.push(new Particle(arbExit, arbiterBusEntry(), '#ffa94d', 'ACK#'+capturedSeq, 2.0, function() {
                    flash(layout.arbiter, '#ffa94d');
                    arbiterAckFromL2(capturedSeq, function() {
                      logEvent('ROB: SEQ#'+capturedSeq+' retired ‚Üí DATA‚ÜíSM'+capturedIdx, '#a78bfa');
                      // Step 5: DATA routes from bus level ‚Üí SM bus junction ‚Üí L1
                      // spawnRoutedFromArbiter starts at arbiterBusEntry (bus level), no air-travel
                      spawnRoutedFromArbiter(capturedIdx, '#ffa94d', 'DATA', 2.2, function() {
                        layout.sms[capturedIdx].l1.state = 'modified';
                        setL1Dirty(capturedIdx);
                        flash(layout.sms[capturedIdx].l1, '#f59e0b');
                        stats.hits++; updateStats();
                      });
                    });
                  }));
                }));
              }, l2Jitter);
            }));
          }));
        })(seq, smIdx);
      });
    }

    // All SMs send their ATOMs toward the arbiter with a small spread (0-80ms)
    // ensuring they all arrive before any grant issues.
    for (var ai = 0; ai < smCount2; ai++) {
      (function(idx) {
        var launchDelay = idx * 18 + Math.random() * 25;  // staggered, not random overlap
        setTimeout(function() {
          stats.misses++;
          bubble(l1Pos(idx).x, l1Pos(idx).y, 'atomicAdd', '#f59e0b', { sub:'‚Üí arbiter', life:1.2 });
          // ATOM travels: L1 ‚Üí busP ‚Üí arbiterBusEntry ‚Üí arbiterTop (where it waits for grant)
          spawnRoutedToArbiter(idx, '#f59e0b', 'ATOM', 2.5, function() {
            // Particle is now physically AT arbiterTop. Enqueue it.
            function tryEnqueue() {
              var seq = arbiterEnqueue(idx, 'ATOM');
              if (seq === -1) {
                var iface = arbiterBusEntry();
                bubble(iface.x + (idx - 1.5) * 14, iface.y, 'STALLED', '#ff6b6b', { sub:'queue full', life:0.7 });
                setTimeout(tryEnqueue, 200);
                return;
              }
              logEvent('SM'+idx+': ATOM arrived ‚Üí SEQ#'+seq, '#f59e0b');
              flash(layout.arbiter, '#f59e0b');
              pendingGrants.push({ seq: seq, smIdx: idx });
              // Sort by SEQ# so grants always issue in strict sequence order,
              // regardless of which SM's particle arrived at arbiterTop first.
              // Without this, animation-timing jitter can invert grant order vs
              // the ROB, causing SEQ#1 to be granted before SEQ#0.
              pendingGrants.sort(function(a, b) { return a.seq - b.seq; });
              tryNextGrant();  // will only fire if nothing currently in flight
            }
            tryEnqueue();
          });
        }, launchDelay);
      })(ai);
    }
  } else {
    // Non-Apex: raw bus contention, no arbiter coordination
    logEvent('atomicAdd: raw bus contention (no arbiter)', '#f59e0b');
    bubble((layout.bus.x1+layout.bus.x2)/2, layout.bus.y, 'no arbiter!', '#ff6b6b', { sub:'serialized at L2 (slow)', life:2.2 });
    for (var ri = 0; ri < smCount2; ri++) {
      (function(idx2) {
        setTimeout(function() {
          stats.misses++;
          bubble(l1Pos(idx2).x, l1Pos(idx2).y, 'atomicAdd', '#f59e0b', { sub:'racing for bus', life:1.4 });
          particles.push(new Particle(l1Pos(idx2), busP(idx2), '#f59e0b', 'ATOM', 2.5, function() {
            particles.push(new Particle(busP(idx2), l2Top(), '#f59e0b', 'ATOM', 2.5, function() {
              flash(layout.l2, '#f59e0b');
              logEvent('L2: atomic locked (SM'+idx2+')', '#ffa94d');
              setTimeout(function() {
                // DATA returns: l2Top ‚Üí busP (horizontal) ‚Üí l1Pos (down to SM) ‚Äî no diagonals
                spawnParticle(l2Top(), l1Pos(idx2), '#ffa94d', 'DATA', 2, function() {
                  layout.sms[idx2].l1.state = 'modified'; setL1Dirty(idx2);
                  flash(layout.sms[idx2].l1, '#f59e0b');
                  stats.hits++; updateStats();
                }, [busP(idx2)]);
              }, 100 + Math.random() * 600); // random L2 lock contention
            }));
          }));
        }, Math.random() * 600); // random warp scheduler timing
      })(ri);
    }
  }
  updateStats();
}


function startApp() {
  dpr = window.devicePixelRatio || 1;
  // Try to get real layout dimensions first
  var r = canvas.getBoundingClientRect();
  W = (r.width > 10 ? r.width : 0) || canvas.offsetWidth || canvas.width || 900;
  H = (r.height > 10 ? r.height : 0) || canvas.offsetHeight || canvas.height || 640;
  // Always stamp the canvas pixel buffer to match ‚Äî never leave it zero
  canvas.width  = Math.round(W * dpr);
  canvas.height = Math.round(H * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  buildLayout();
  initialized = true;
  updateKeyCard();
  updateArchIntro();
  updateScenarioButtons();
  buildInstrChips();
  lastTime = performance.now();
  requestAnimationFrame(drawFrame);
}
requestAnimationFrame(startApp);

var explainerEl = document.getElementById('step-list');
explainerEl.addEventListener('mousemove', function(e) {
  var target = e.target.closest('.micro-instr');
  if (target) {
    var key = target.getAttribute('data-instr');
    showInstrTooltip(key, e.clientX, e.clientY);
  } else {
    hideInstrTooltip();
  }
});
explainerEl.addEventListener('mouseleave', function() { hideInstrTooltip(); });


  </script>
</body>
</html>
