<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GPU Cache Coherency ‚Äî Architecture Explorer</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Outfit:wght@300;400;600;700;800&display=swap');
:root {
  --bg: #0a0b0f; --surface: #12141a; --surface2: #1a1d26;
  --border: #2a2d3a; --text: #e0e2ec; --dim: #6b7094;
  --l1: #ff6b6b; --l2: #ffa94d; --smem: #51cf66;
  --global: #339af0; --dram: #845ef7; --coherency: #f06595;
  --new-block: #22d3ee; --changed: #facc15;
}
* { margin:0; padding:0; box-sizing:border-box; }
body { background:var(--bg); color:var(--text); font-family:'Outfit',sans-serif; min-height:100vh; overflow-x:hidden; }
.grain { position:fixed; inset:0; pointer-events:none; z-index:999; opacity:.03;
  background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E"); }

header { text-align:center; padding:20px 16px 10px; }
header h1 { font-size:clamp(1.6rem,3.5vw,2.6rem); font-weight:800; letter-spacing:-1px;
background:linear-gradient(135deg,#ff6b6b,#ffa94d,#51cf66,#339af0,#845ef7);
-webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text; }
header p { color:var(--dim); font-family:'JetBrains Mono',monospace; font-size:.75rem; margin-top:4px; letter-spacing:2px; text-transform:uppercase; }

.arch-tabs { display:flex; justify-content:center; gap:0; padding:10px 16px 6px; flex-wrap:wrap; }
.arch-tab {
background:var(--surface); border:1px solid var(--border); color:var(--dim);
font-family:'JetBrains Mono',monospace; font-size:.7rem; padding:8px 14px;
cursor:pointer; transition:all .2s; letter-spacing:.3px; position:relative;
border-right:none;
}
.arch-tab:first-child { border-radius:6px 0 0 6px; }
.arch-tab:last-child { border-radius:0 6px 6px 0; border-right:1px solid var(--border); }
.arch-tab:hover { color:var(--text); background:var(--surface2); }
.arch-tab.active { background:var(--surface2); color:#fff; border-color:var(--accent-color,var(--global)); }
.arch-tab.active::after { content:''; position:absolute; bottom:-1px; left:10%; right:10%; height:2px; background:var(--accent-color,var(--global)); border-radius:1px; }
.arch-tab .tab-gen { display:block; font-size:.55rem; color:var(--dim); margin-top:2px; font-weight:400; }
.arch-tab.active .tab-gen { color:var(--accent-color,var(--global)); }

.diff-banner {
max-width:1200px; margin:6px auto 0; padding:8px 14px;
background:var(--surface); border:1px solid var(--border); border-radius:8px;
font-size:.75rem; line-height:1.5; display:none; text-align:center;
}
.diff-banner.visible { display:block; }
.diff-banner .new-tag { color:var(--new-block); font-weight:600; }
.diff-banner .changed-tag { color:var(--changed); font-weight:600; }
.diff-banner .removed-tag { color:#ff6b6b; font-weight:600; text-decoration:line-through; }

.controls { display:flex; justify-content:center; gap:12px; padding:12px 20px; flex-wrap:wrap; }
.controls button {
background:var(--surface2); border:1px solid var(--border); color:var(--text);
font-family:'JetBrains Mono',monospace; font-size:.75rem; padding:8px 16px;
border-radius:6px; cursor:pointer; transition:all .2s; letter-spacing:.5px;
}
.controls button:hover { border-color:var(--coherency); color:#fff; }
.controls button.active { background:var(--coherency); border-color:var(--coherency); color:#fff; }
.controls button.reset-btn { background:transparent; border-color:#ff6b6b50; color:#ff6b6b; }
.controls button.reset-btn:hover { background:#ff6b6b20; border-color:#ff6b6b; }

.main-container { display:flex; gap:24px; padding:12px 20px; max-width:1200px; margin:0 auto; align-items:flex-start; }
.viz-area { flex:1; min-width:0; max-width:700px; position:relative; }
canvas { width:100%; height:520px; background:var(--surface); border-radius:12px; border:1px solid var(--border); display:block; cursor:default; }
@media(max-width:500px){ canvas { height:500px; } .viz-area { max-width:none; } }

/* ‚îÄ‚îÄ Tooltip ‚îÄ‚îÄ */
#block-tooltip {
  position:absolute; pointer-events:none; z-index:100;
  background:#0d0f16; border:1px solid var(--border);
  border-radius:10px; padding:11px 14px; max-width:240px;
  box-shadow: 0 8px 32px rgba(0,0,0,.7);
  opacity:0; transition:opacity .15s;
  font-size:.75rem; line-height:1.55;
}
#block-tooltip.visible { opacity:1; }
#block-tooltip .tt-title { font-weight:700; font-size:.85rem; margin-bottom:6px; display:flex; align-items:center; gap:7px; }
#block-tooltip .tt-dot { width:9px; height:9px; border-radius:3px; flex-shrink:0; }
#block-tooltip .tt-desc { color:var(--dim); margin-bottom:7px; }
#block-tooltip .tt-meta { display:flex; flex-wrap:wrap; gap:5px; }
#block-tooltip .tt-chip {
  font-family:'JetBrains Mono',monospace; font-size:.6rem; font-weight:600;
  padding:2px 7px; border-radius:4px;
}
#block-tooltip .tt-hint {
  margin-top:8px; padding-top:6px; border-top:1px solid var(--border);
  font-size:.65rem; color:#6b7094; font-family:'JetBrains Mono',monospace;
  display:flex; align-items:center; gap:5px;
}
#block-tooltip .tt-hint::before { content:'‚óâ'; font-size:.7rem; }

/* ‚îÄ‚îÄ Instruction tooltip ‚îÄ‚îÄ */
#instr-tooltip {
  position:fixed; pointer-events:none; z-index:200;
  background:#080a10; border:1px solid var(--border);
  border-radius:12px; padding:14px 16px; max-width:310px; min-width:240px;
  box-shadow: 0 12px 40px rgba(0,0,0,.85);
  opacity:0; transition:opacity .15s, transform .15s;
  transform:translateY(4px);
  font-size:.75rem; line-height:1.6;
}
#instr-tooltip.visible { opacity:1; transform:translateY(0); }
#instr-tooltip .it-name {
  font-family:'JetBrains Mono',monospace; font-weight:700; font-size:.82rem;
  margin-bottom:8px; display:flex; align-items:center; gap:8px;
}
#instr-tooltip .it-dot { width:8px; height:8px; border-radius:2px; flex-shrink:0; }
#instr-tooltip .it-section { margin-bottom:8px; }
#instr-tooltip .it-label {
  font-family:'JetBrains Mono',monospace; font-size:.55rem; font-weight:700;
  text-transform:uppercase; letter-spacing:1.5px; color:#6b7094; margin-bottom:3px;
}
#instr-tooltip .it-text { color:#c8cce0; font-size:.74rem; line-height:1.55; }
#instr-tooltip .it-why-box {
  background:#0f1a12; border:1px solid #51cf6625; border-radius:7px;
  padding:8px 10px; margin-top:6px;
}
#instr-tooltip .it-why-box .it-label { color:#51cf6699; }
#instr-tooltip .it-why-box .it-text { color:#a0dbb0; }

/* ‚îÄ‚îÄ Selection panel ‚îÄ‚îÄ */
#sel-panel {
  background:var(--surface); border:1px solid var(--border); border-radius:10px;
  padding:14px; display:none; margin-top:12px;
}
#sel-panel.visible { display:block; }
#sel-panel h4 { font-size:.65rem; font-family:'JetBrains Mono',monospace; text-transform:uppercase; letter-spacing:2px; color:var(--dim); margin-bottom:10px; }
#sel-panel .sel-name { font-weight:700; font-size:.95rem; margin-bottom:6px; }
#sel-panel .sel-desc { font-size:.78rem; color:var(--dim); line-height:1.55; margin-bottom:10px; }
#sel-panel .sel-connections { }
#sel-panel .sel-connections h5 { font-size:.6rem; font-family:'JetBrains Mono',monospace; text-transform:uppercase; letter-spacing:1.5px; color:var(--dim); margin-bottom:7px; }
#sel-panel .conn-list { display:flex; flex-direction:column; gap:5px; }
#sel-panel .conn-item {
  display:flex; align-items:flex-start; gap:8px; padding:7px 10px;
  background:var(--bg); border-radius:6px; border:1px solid var(--border);
  font-size:.75rem; line-height:1.45; cursor:pointer; transition:border-color .15s;
}
#sel-panel .conn-item:hover { border-color: #4a4d5a; }
#sel-panel .conn-item .ci-arrow { font-family:'JetBrains Mono',monospace; font-size:.7rem; flex-shrink:0; margin-top:1px; }
#sel-panel .conn-item .ci-body { flex:1; }
#sel-panel .conn-item .ci-target { font-weight:600; }
#sel-panel .conn-item .ci-why { color:var(--dim); font-size:.7rem; display:block; }
#sel-panel .close-btn { float:right; font-size:.7rem; color:var(--dim); cursor:pointer; font-family:'JetBrains Mono',monospace; padding:2px 6px; border:1px solid var(--border); border-radius:4px; }
#sel-panel .close-btn:hover { color:var(--text); }

.info-panel { width:360px; flex-shrink:0; display:flex; flex-direction:column; gap:12px; }
.info-card { background:var(--surface); border:1px solid var(--border); border-radius:10px; padding:14px; }
.info-card h3 { font-size:.65rem; font-family:'JetBrains Mono',monospace; text-transform:uppercase; letter-spacing:2px; color:var(--dim); margin-bottom:10px; }

/* Instruction reference chips */
.instr-section { margin-top:0; }
.instr-chips { display:flex; flex-wrap:wrap; gap:8px; }
.instr-chip {
  font-family:'JetBrains Mono',monospace; font-size:.72rem; font-weight:700;
  padding:5px 11px; border-radius:6px; cursor:pointer;
  border:1px solid transparent; transition:all .15s;
  user-select:none;
}
.instr-chip:hover { transform:translateY(-1px); box-shadow:0 4px 14px rgba(0,0,0,.4); }

.bottom-section { max-width:1200px; margin:0 auto; padding:0 20px 30px; }
.bottom-grid { display:grid; grid-template-columns:1fr 1fr; gap:16px; }

@media(min-width:1101px) {
.perf-bars { height:32px; }
.perf-bar-val { font-size:.58rem; }
.perf-label { min-width:70px; font-size:.75rem; }
}

.acc-item { border-bottom:1px solid var(--border); }
.acc-item:last-child { border-bottom:none; }
.acc-head { display:flex; align-items:center; gap:8px; padding:8px 0; cursor:pointer; user-select:none; -webkit-user-select:none; }
.acc-head:active { opacity:.7; }
.acc-dot { width:8px; height:8px; border-radius:3px; flex-shrink:0; }
.acc-title { flex:1; font-weight:600; font-size:.8rem; }
.acc-meta { font-family:'JetBrains Mono',monospace; font-size:.6rem; color:var(--dim); }
.acc-chev { font-size:.65rem; color:var(--dim); transition:transform .25s; }
.acc-item.open .acc-chev { transform:rotate(90deg); }
.acc-body { max-height:0; overflow:hidden; transition:max-height .3s,padding .3s; padding:0 0 0 16px; }
.acc-item.open .acc-body { max-height:350px; padding:0 0 8px 16px; }
.acc-body p { font-size:.75rem; line-height:1.5; color:var(--dim); margin:0; }
.acc-body p strong { color:var(--text); }
.acc-badge-new { font-size:.55rem; background:var(--new-block); color:#000; padding:1px 5px; border-radius:3px; font-weight:700; margin-left:4px; }
.acc-badge-changed { font-size:.55rem; background:var(--changed); color:#000; padding:1px 5px; border-radius:3px; font-weight:700; margin-left:4px; }

.stats-grid { display:grid; grid-template-columns:1fr 1fr; gap:6px; }
.stat-item { background:var(--bg); border-radius:6px; padding:8px; text-align:center; }
.stat-value { font-size:1.3rem; font-weight:700; font-family:'JetBrains Mono',monospace; }
.stat-label { font-size:.6rem; color:var(--dim); text-transform:uppercase; letter-spacing:1px; margin-top:1px; }

.state-row { display:flex; align-items:center; gap:8px; margin-bottom:6px; font-size:.8rem; }
.state-dot { width:8px; height:8px; border-radius:50%; flex-shrink:0; }
.state-label { font-weight:600; min-width:70px; }
.state-desc { color:var(--dim); font-size:.73rem; }

.explainer { position:relative; overflow:hidden; min-height:100px; max-height:400px; }
.explainer::before { content:''; position:absolute; top:0; left:0; right:0; height:3px;
background:linear-gradient(90deg,var(--l1),var(--l2),var(--smem),var(--global),var(--dram)); border-radius:10px 10px 0 0; opacity:.6; }
.explainer-title { font-weight:700; font-size:.95rem; margin-bottom:8px; display:flex; align-items:center; gap:8px; }
.explainer-title .dot { width:8px; height:8px; border-radius:50%; animation:pulse-dot 1.5s ease-in-out infinite; }
@keyframes pulse-dot { 0%,100%{opacity:.5;transform:scale(1)} 50%{opacity:1;transform:scale(1.3)} }
.step-list { list-style:none; max-height:220px; overflow-y:auto; overscroll-behavior:contain; scrollbar-width:thin; scrollbar-color:var(--border) transparent; }
.step-list::-webkit-scrollbar{width:4px} .step-list::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px}
.step-list li { display:flex; align-items:flex-start; gap:8px; padding:5px 0; font-size:.78rem; line-height:1.4; opacity:0; transform:translateX(-6px); transition:opacity .4s,transform .4s; }
.step-list li.visible { opacity:1; transform:translateX(0); }
.step-list li.active { opacity:1; transform:translateX(0); }
.step-list li.past { opacity:.4; }
.step-num { font-family:'JetBrains Mono',monospace; font-size:.65rem; font-weight:600; min-width:18px; height:18px; display:flex; align-items:center; justify-content:center; border-radius:4px; flex-shrink:0; }
.step-text { flex:1; }
.step-text .micro { display:block; font-size:.68rem; color:var(--dim); font-family:'JetBrains Mono',monospace; margin-top:1px; }
.explainer-summary { margin-top:8px; padding-top:8px; border-top:1px solid var(--border); font-size:.73rem; color:var(--dim); font-style:italic; opacity:0; transition:opacity .5s; }
.explainer-summary.visible { opacity:1; }

.event-log { max-height:160px; overflow-y:auto; overscroll-behavior:contain; scrollbar-width:thin; scrollbar-color:var(--border) transparent; }
.event-log::-webkit-scrollbar{width:4px} .event-log::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px}
.log-entry { font-family:'JetBrains Mono',monospace; font-size:.65rem; padding:3px 0; border-bottom:1px solid rgba(42,45,58,.5); color:var(--dim); animation:fadeIn .3s; }
.log-entry .tag { display:inline-block; padding:1px 5px; border-radius:3px; font-size:.6rem; margin-right:3px; }
@keyframes fadeIn { from{opacity:0;transform:translateY(-4px)} to{opacity:1;transform:translateY(0)} }

.arch-intro { max-width:1200px; margin:6px auto 0; padding:0 20px; }
.arch-intro-inner {
background:var(--surface); border:1px solid var(--border); border-radius:10px;
padding:14px 16px; display:flex; gap:14px; align-items:flex-start;
}
.arch-intro-badge {
font-family:'JetBrains Mono',monospace; font-size:.6rem; font-weight:700;
padding:4px 10px; border-radius:5px; white-space:nowrap; flex-shrink:0; margin-top:2px;
}
.arch-intro-text { font-size:.8rem; line-height:1.55; color:var(--dim); }
.arch-intro-text strong { color:var(--text); }

.easy-card { border-left:3px solid var(--smem); }
.easy-card h3 span { color:var(--smem); font-size:.6rem; margin-left:6px; font-weight:400; }
.easy-q { padding:8px 0; border-bottom:1px solid var(--border); cursor:pointer; user-select:none; -webkit-user-select:none; }
.easy-q:last-child { border-bottom:none; }
.easy-q:active { opacity:.7; }
.easy-head { display:flex; align-items:center; gap:8px; }
.easy-emoji { font-size:1rem; flex-shrink:0; width:22px; text-align:center; }
.easy-title { flex:1; font-weight:600; font-size:.82rem; }
.easy-chev { font-size:.65rem; color:var(--dim); transition:transform .25s; }
.easy-q.open .easy-chev { transform:rotate(90deg); }
.easy-body { max-height:0; overflow:hidden; transition:max-height .3s,padding .3s; padding:0 0 0 30px; }
.easy-q.open .easy-body { max-height:500px; padding:4px 0 6px 30px; }
.easy-body p { font-size:.78rem; line-height:1.6; color:var(--dim); margin:0 0 6px; }
.easy-body p strong { color:var(--text); }
.easy-body .analogy { font-style:italic; color:var(--smem); font-size:.73rem; }

.perf-card h3 { margin-bottom:12px; }
.perf-row { display:flex; align-items:center; gap:8px; margin-bottom:8px; }
.perf-label { font-size:.7rem; font-family:'JetBrains Mono',monospace; color:var(--dim); min-width:65px; flex-shrink:0; }
.perf-bars { flex:1; display:flex; gap:2px; height:28px; align-items:flex-end; }
.perf-bar {
flex:1; border-radius:2px 2px 0 0; position:relative; min-height:2px;
transition:height .4s ease; display:flex; align-items:flex-end; justify-content:center;
}
.perf-bar-val {
font-family:'JetBrains Mono',monospace; font-size:.5rem; font-weight:600;
position:absolute; top:-12px; width:100%; text-align:center; white-space:nowrap;
}
.perf-bar.active { outline:1px solid #fff3; outline-offset:1px; }
.perf-legend { display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; justify-content:center; }
.perf-legend-item { display:flex; align-items:center; gap:4px; font-size:.6rem; font-family:'JetBrains Mono',monospace; color:var(--dim); }
.perf-legend-dot { width:8px; height:8px; border-radius:2px; }

@media(max-width:1100px) {
.main-container { flex-direction:column; }
.info-panel { width:100%; flex-direction:row; flex-wrap:wrap; }
.info-card { flex:1; min-width:260px; }
.bottom-grid { grid-template-columns:1fr; }
}
</style>
</head>
<body>
<div class="grain"></div>

<header>
  <h1>GPU Cache Coherency</h1>
  <p>Architecture Explorer ¬∑ Memory Hierarchy ¬∑ Data Flow</p>
</header>

<div class="arch-tabs" id="arch-tabs">
  <div class="arch-tab active" data-arch="pascal" style="--accent-color:#51cf66" onclick="switchArch('pascal')">Pascal<span class="tab-gen">SM 6.1 ¬∑ 2016</span></div>
  <div class="arch-tab" data-arch="volta" style="--accent-color:#339af0" onclick="switchArch('volta')">Volta<span class="tab-gen">SM 7.0 ¬∑ 2017</span></div>
  <div class="arch-tab" data-arch="ampere" style="--accent-color:#ffa94d" onclick="switchArch('ampere')">Ampere<span class="tab-gen">SM 8.0 ¬∑ 2020</span></div>
  <div class="arch-tab" data-arch="hopper" style="--accent-color:#845ef7" onclick="switchArch('hopper')">Hopper<span class="tab-gen">SM 9.0 ¬∑ 2022</span></div>
</div>

<div class="diff-banner" id="diff-banner"></div>
<div class="arch-intro"><div class="arch-intro-inner" id="arch-intro"></div></div>

<div class="controls">
  <button onclick="triggerScenario('read')">SM Read</button>
  <button onclick="triggerScenario('write')">SM Write</button>
  <button onclick="triggerScenario('invalidate')">Invalidate</button>
  <button onclick="triggerScenario('writeback')">Write-Back</button>
  <button onclick="triggerScenario('shared')">Shared Mem</button>
  <button id="btn-auto" class="active" onclick="toggleAuto()">Auto</button>
  <button class="reset-btn" onclick="resetAll()">Reset</button>
</div>

<div class="main-container">
  <div class="viz-area">
    <canvas id="canvas"></canvas>
    <!-- Block tooltip -->
    <div id="block-tooltip">
      <div class="tt-title"><div class="tt-dot" id="tt-dot"></div><span id="tt-name"></span></div>
      <div class="tt-desc" id="tt-desc"></div>
      <div class="tt-meta" id="tt-meta"></div>
      <div class="tt-hint" id="tt-hint">Click to explore connections</div>
    </div>
    <!-- Selection panel -->
    <div id="sel-panel">
      <span class="close-btn" onclick="clearSelection()">‚úï close</span>
      <h4>Block Selected</h4>
      <div class="sel-name" id="sel-name"></div>
      <div class="sel-desc" id="sel-desc"></div>
      <div class="sel-connections">
        <h5>Connects To</h5>
        <div class="conn-list" id="conn-list"></div>
      </div>
    </div>
  </div>
  <div class="info-panel">
    <div class="info-card" id="key-card"></div>
    <div class="info-card">
      <h3>Cache States (MSI)</h3>
      <div class="state-row"><div class="state-dot" style="background:#51cf66"></div><span class="state-label">Modified</span><span class="state-desc">Dirty, exclusive</span></div>
      <div class="state-row"><div class="state-dot" style="background:#339af0"></div><span class="state-label">Shared</span><span class="state-desc">Clean, multi-reader</span></div>
      <div class="state-row"><div class="state-dot" style="background:#555"></div><span class="state-label">Invalid</span><span class="state-desc">Stale / absent</span></div>
    </div>
    <div class="info-card">
      <h3>Live Stats</h3>
      <div class="stats-grid">
        <div class="stat-item"><div class="stat-value" id="stat-hits" style="color:var(--smem)">0</div><div class="stat-label">Hits</div></div>
        <div class="stat-item"><div class="stat-value" id="stat-misses" style="color:var(--l1)">0</div><div class="stat-label">Misses</div></div>
        <div class="stat-item"><div class="stat-value" id="stat-inv" style="color:var(--coherency)">0</div><div class="stat-label">Invalidations</div></div>
        <div class="stat-item"><div class="stat-value" id="stat-wb" style="color:var(--l2)">0</div><div class="stat-label">Write-Backs</div></div>
      </div>
    </div>
    <div class="info-card explainer" id="explainer-card">
      <h3>What's Happening</h3>
      <div id="explainer-title" class="explainer-title" style="color:var(--dim)"><span class="dot" style="background:var(--dim)"></span>Click a scenario or wait for auto...</div>
      <ol class="step-list" id="step-list"></ol>
      <div class="explainer-summary" id="explainer-summary"></div>
    </div>
    <div class="info-card">
      <h3>Event Log</h3>
      <div class="event-log" id="event-log"></div>
    </div>
  </div>
</div>

<div class="bottom-section">
  <div class="bottom-grid">
    <div class="info-card easy-card">
      <h3>Easy Explain <span>for beginners</span></h3>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">üè†</span><span class="easy-title">What is a cache?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p>A cache is a <strong>small, fast storage</strong> that keeps copies of frequently used data close to where it's needed.</p><p class="analogy">Analogy: Your desk (cache) vs the library (main memory). You keep the books you're reading on your desk so you don't have to walk to the library every time.</p></div>
      </div>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">ü§ù</span><span class="easy-title">What is cache coherency?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p>When <strong>multiple processors</strong> (SMs) each have their own cache, they might hold different copies of the same data. Cache coherency keeps everyone's copies consistent.</p></div>
      </div>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">üì¶</span><span class="easy-title">What is an SM?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p>A <strong>Streaming Multiprocessor</strong> is the GPU's core compute unit. Each SM runs thousands of threads in parallel using "warps" (groups of 32 threads).</p></div>
      </div>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">‚ö°</span><span class="easy-title">Shared memory vs L1?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p><strong>L1</strong> is automatic ‚Äî hardware decides what to cache. <strong>Shared memory</strong> is manual ‚Äî programmer explicitly loads data. Faster and predictable, but more work.</p></div>
      </div>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">üö´</span><span class="easy-title">What does "invalidate" mean?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p>When one SM writes, others' cached copies become <strong>outdated</strong>. Invalidation says "throw away your copy." Next access fetches fresh from L2.</p></div>
      </div>
      <div class="easy-q" onclick="this.classList.toggle('open')">
        <div class="easy-head"><span class="easy-emoji">üîÑ</span><span class="easy-title">What does "write-evict" mean?</span><span class="easy-chev">‚ñ∏</span></div>
        <div class="easy-body"><p>Instead of keeping a dirty copy in L1, the SM <strong>drops the L1 copy entirely</strong> and writes straight to L2. Simpler than CPU write-back but more L2 traffic.</p></div>
      </div>
    </div>
  </div>
</div>

<div class="bottom-section instr-section">
  <div class="bottom-grid">
    <div class="info-card" id="instr-ref-card">
      <h3>Instruction Reference <span style="font-size:.6rem;color:var(--dim);font-weight:400;font-family:'JetBrains Mono',monospace;text-transform:uppercase;letter-spacing:1px">‚Äî hover any chip</span></h3>
      <div class="instr-chips" id="instr-chips"></div>
    </div>
  </div>
</div>
<script>
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
var W, H, dpr;
var initialized = false;

function resize() {
  dpr = window.devicePixelRatio || 1;
  var r = canvas.getBoundingClientRect();
  var newW = r.width || canvas.offsetWidth || 640;
  var newH = r.height || canvas.offsetHeight || 520;
  if (newW === W && newH === H) return; // nothing changed
  W = newW; H = newH;
  canvas.width  = Math.round(W * dpr);
  canvas.height = Math.round(H * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  if (initialized) buildLayout();
}

// Resize will be called by the deferred init block below
window.addEventListener('resize', resize);

function rrect(x, y, w, h, r) {
  r = Math.min(r, w/2, h/2);
  ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y);
  ctx.arcTo(x+w,y,x+w,y+r,r); ctx.lineTo(x+w,y+h-r);
  ctx.arcTo(x+w,y+h,x+w-r,y+h,r); ctx.lineTo(x+r,y+h);
  ctx.arcTo(x,y+h,x,y+h-r,r); ctx.lineTo(x,y+r);
  ctx.arcTo(x,y,x+r,y,r); ctx.closePath();
}

// ‚îÄ‚îÄ‚îÄ Block metadata: purpose, latency, size, connections ‚îÄ‚îÄ‚îÄ
var BLOCK_INFO = {
  regs:      { name:'Register File', color:'#a8b0d0', desc:'Fastest storage on the chip. Each thread gets its own private registers ‚Äî no sharing, no coherency needed. 32-bit per lane, ~255 per thread.', chips:[{t:'~1 cycle',c:'#51cf66'},{t:'private',c:'#339af0'}], connects:[{to:'l1',arrow:'‚Üí',why:'Spill registers to L1 when exhausted (register spilling)'},{to:'smem',arrow:'‚Üî',why:'Threads read/write shared mem via LDS/STS instructions'}] },
  l1:        { name:'L1 Cache (unified)', color:'#ff6b6b', desc:'Per-SM cache. Pascal: read-only for global data ‚Äî zero coherency overhead. Volta+: caches writes too, requires invalidation protocol when another SM writes to the same address.', chips:[{t:'~28 cycles',c:'#ffa94d'},{t:'per-SM',c:'#339af0'}], connects:[{to:'bus',arrow:'‚Üí',why:'Miss ‚Üí sends RdReq or INV across coherency bus'},{to:'smem',arrow:'‚Üî',why:'Shares physical SRAM pool (Volta+); split is software-configurable'},{to:'regs',arrow:'‚Üê',why:'Fills data into thread registers on cache hit/fill'}] },
  texCache:  { name:'Texture Cache (TEX$)', color:'#e599f7', desc:'Separate read-only cache optimized for 2D spatial locality. Used for sampled textures. Pascal keeps this distinct from L1; Volta+ merged them.', chips:[{t:'read-only',c:'#e599f7'},{t:'~24KB',c:'#a0a0a0'}], connects:[{to:'l2',arrow:'‚Üí',why:'All misses fetch from L2'},{to:'regs',arrow:'‚Üê',why:'Filtered/sampled results go into registers'}] },
  smem:      { name:'Shared Memory (SMEM)', color:'#51cf66', desc:'Software-managed on-chip SRAM. Threads in the same CTA (thread block) share this scratchpad. No coherency protocol ‚Äî programmer controls all reads/writes explicitly. 32 memory banks.', chips:[{t:'~20 cycles',c:'#51cf66'},{t:'per-CTA',c:'#339af0'},{t:'no coherency',c:'#f06595'}], connects:[{to:'regs',arrow:'‚Üî',why:'LDS/STS instructions move data between threads and SMEM'},{to:'l1',arrow:'‚Üî',why:'Shares the same physical SRAM as L1 (Volta+), split is configurable'},{to:'async',arrow:'‚Üê',why:'cp.async loads data from global memory directly into SMEM (Ampere+)'}] },
  tma:       { name:'Tensor Memory Accelerator (TMA)', color:'#22d3ee', desc:'Hopper hardware DMA engine. Handles bulk multi-dimensional tensor transfers between global memory and SMEM. Offloads address calculation from threads, freeing them for compute.', chips:[{t:'NEW: Hopper',c:'#22d3ee'},{t:'hardware DMA',c:'#845ef7'}], connects:[{to:'smem',arrow:'‚Üí',why:'Deposits tensor tiles directly into SMEM with tensor-aware addressing'},{to:'globalMem',arrow:'‚Üê',why:'Reads from global memory with N-D tensor coordinate logic'}] },
  dsmem:     { name:'Distributed Shared Memory (DSMEM)', color:'#22d3ee', desc:'Hopper feature. SMs within the same Thread Block Cluster can directly read each other\'s shared memory ‚Äî at roughly SMEM latency ‚Äî without going through L2. Enables tighter SM cooperation.', chips:[{t:'NEW: Hopper',c:'#22d3ee'},{t:'cluster-scope',c:'#845ef7'},{t:'~20 cycles',c:'#51cf66'}], connects:[{to:'smem',arrow:'‚Üî',why:'DSMEM is a window into another SM\'s SMEM within the cluster'},{to:'bus',arrow:'‚Üî',why:'Cluster bus carries cross-SM DSMEM traffic'}] },
  async:     { name:'Async Copy (cp.async)', color:'#22d3ee', desc:'Ampere+ instruction that moves data from global to shared memory without occupying registers or stalling the warp. Like a mini-DMA per thread, enabling compute-memory overlap.', chips:[{t:'Ampere+',c:'#ffa94d'},{t:'bypass regs',c:'#51cf66'}], connects:[{to:'smem',arrow:'‚Üí',why:'Destination: deposits data directly into SMEM'},{to:'globalMem',arrow:'‚Üê',why:'Source: reads from global memory without touching registers'}] },
  bus:       { name:'Coherency Bus / Crossbar', color:'#f06595', desc:'The shared interconnect between all SMs and the L2. Carries read requests, data responses, and invalidation messages. Pascal uses a simple crossbar (L1 is read-only). Volta+ must broadcast INV messages when writes occur.', chips:[{t:'shared fabric',c:'#f06595'},{t:'broadcast INV',c:'#339af0'}], connects:[{to:'l1',arrow:'‚Üî',why:'Delivers RdReq/DATA/INV messages to each SM\'s L1'},{to:'l2',arrow:'‚Üî',why:'Connects all SMs to the shared L2 cache'}] },
  l2:        { name:'L2 Cache (unified)', color:'#ffa94d', desc:'Shared by all SMs ‚Äî the point of coherence. All cache lines must pass through L2. Ampere introduced 10√ó larger L2 (40 MB) with software-controlled persistence windows. Hopper: 50 MB.', chips:[{t:'~200 cycles',c:'#ffa94d'},{t:'unified',c:'#339af0'},{t:'coherence point',c:'#f06595'}], connects:[{to:'bus',arrow:'‚Üî',why:'Serves read/write requests from all SMs via the coherency bus'},{to:'globalMem',arrow:'‚Üî',why:'Evicts dirty lines down to DRAM; fetches missing lines up on miss'}] },
  l2Persist: { name:'L2 Persistence Window', color:'#ffa94d', desc:'Ampere+ feature. You can pin a set of addresses to always stay in L2. Useful for weights or lookup tables accessed repeatedly across many kernels. Set via cudaAccessPolicyWindow.', chips:[{t:'Ampere+',c:'#ffa94d'},{t:'software ctrl',c:'#51cf66'}], connects:[{to:'l2',arrow:'‚Üî',why:'A sub-region of the L2 pinned via CUDA API policy'},{to:'globalMem',arrow:'‚Üê',why:'Persistently caches frequently-read global data in L2'}] },
  globalMem: { name:'Global Memory Interface', color:'#339af0', desc:'The on-chip logic (memory controllers + NoC) that bridges L2 to physical DRAM. Handles address translation, ECC, and row/bank scheduling. Multiple controllers run in parallel for bandwidth.', chips:[{t:'memory ctrl',c:'#339af0'},{t:'multi-channel',c:'#845ef7'}], connects:[{to:'l2',arrow:'‚Üî',why:'Receives evictions from L2; returns fetched DRAM data to L2'},{to:'hbm',arrow:'‚Üî',why:'Issues actual read/write commands to HBM stacks'}] },
  hbm:       { name:'HBM / GDDR (DRAM)', color:'#845ef7', desc:'Off-chip high-bandwidth memory. HBM stacks dies vertically connected via micro-bumps. Hopper HBM3 = 3.35 TB/s. Slowest in the hierarchy but largest ‚Äî all GPU memory ultimately lives here.', chips:[{t:'~400 cycles',c:'#ff6b6b'},{t:'off-chip',c:'#845ef7'},{t:'largest',c:'#6b7094'}], connects:[{to:'globalMem',arrow:'‚Üî',why:'Memory controllers read/write HBM banks via wide parallel buses'}] },
};

// ‚îÄ‚îÄ Instruction tooltips ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Shown when hovering a flying particle label OR the micro-code chips in the explainer
var INSTRUCTION_INFO = {
  'LD.E':   { name:'LD.E  (global load)', color:'#ff6b6b',
    what:'Load from global memory into registers. The .E suffix = "extended addressing" (64-bit). Each thread in the warp loads from its own address ‚Äî if addresses are contiguous the hardware coalesces them into one wide transaction.',
    why:'You need this any time you read from a __device__ pointer or cudaMalloc\'d buffer. It\'s the bread-and-butter read path for all GPGPU work ‚Äî matrix rows, activation tensors, weight arrays, etc.' },
  'ST.E':   { name:'ST.E  (global store)', color:'#51cf66',
    what:'Store from registers to global memory. On Pascal, bypasses L1 entirely (write-through). On Volta+ it evicts the L1 line and writes to L2 (write-evict), then broadcasts INV to other SMs.',
    why:'Writing results back to global memory after a kernel computation ‚Äî output matrices, reduction results, feature maps. Write-evict keeps coherency cheap: only one SM "owns" a dirty line at a time.' },
  'LDS':    { name:'LDS  (load from shared)', color:'#51cf66',
    what:'Load from shared memory (SMEM) into registers. ~20 cycles ‚Äî far cheaper than global. Hardware checks 32 memory banks; accesses to the same bank by different threads in a warp are serialised (bank conflict).',
    why:'The classic CUDA optimization: load a tile from global into SMEM once, then all threads reuse it from LDS repeatedly. MatMul tiling, stencil kernels, and reductions all rely on this.' },
  'STS':    { name:'STS  (store to shared)', color:'#51cf66',
    what:'Store from registers to shared memory. Same 32-bank structure as LDS. Used to cooperatively build a shared tile that other threads in the block will then read via LDS.',
    why:'Tiling patterns: one thread loads from global, stores into SMEM with STS, then all threads read with LDS. Also used for warp-level reductions ‚Äî each thread stores its partial sum then reads neighbours.' },
  'ST.S':   { name:'ST.S  (store to shared, alt form)', color:'#51cf66',
    what:'Alternate encoding for shared memory store. Functionally equivalent to STS ‚Äî same 20-cycle latency, same 32-bank conflict rules.',
    why:'Same use cases as STS ‚Äî cooperative data staging, tiling, reductions. The assembler may emit either form.' },
  'RdReq':  { name:'RdReq  (read request packet)', color:'#ff6b6b',
    what:'Not an ISA instruction ‚Äî a cache coherency protocol message sent from an SM\'s L1 to the L2 on a cache miss. Carries the missed cache line address. The L2 either serves it or forwards it to DRAM.',
    why:'Every L1 cache miss generates one. High miss rates flood the coherency bus and stall warps waiting for data ‚Äî the root cause of memory-bound kernel performance.' },
  'INV':    { name:'INV  (invalidation message)', color:'#f06595',
    what:'Coherency protocol message broadcast from the L2 to all SMs after a write. Any SM holding a Shared or Modified copy of the written cache line must drop it (set to Invalid). Happens on every write in Volta+ write-evict policy.',
    why:'Essential for correctness in multi-SM workloads sharing the same address. Without invalidation, SM 0 could read a stale cached copy of data that SM 1 just wrote. The cost is bus bandwidth ‚Äî atomic-heavy kernels saturate the bus with INVs.' },
  'DATA':   { name:'DATA  (cache line fill)', color:'#ffa94d',
    what:'The response to an RdReq ‚Äî the actual 128-byte cache line payload travelling back from L2 (or DRAM) to the requesting SM\'s L1. On arrival, the L1 fills the line and transitions its state to Shared.',
    why:'This latency is what the GPU hides with warp switching (latency tolerance). If a warp stalls on DATA, the scheduler immediately runs another ready warp. More resident warps = more latency hiding.' },
  'WR':     { name:'WR  (write request)', color:'#51cf66',
    what:'Cache-level write packet flowing from L1 down to L2 on a write-evict event, or from L2 down to the memory controller. Carries both the address and dirty data payload.',
    why:'Part of the write-evict chain: thread writes to L1 ‚Üí L1 drops the dirty line ‚Üí WR packet carries it to L2. If L2 is also full, another WR goes all the way to DRAM. Write-heavy kernels generate a constant stream of these.' },
  'WB':     { name:'WB  (write-back)', color:'#ffa94d',
    what:'Write-Back ‚Äî a dirty L1 line is being evicted and its contents written back to L2. Different from a regular write in that it\'s triggered by cache capacity pressure, not the thread actively storing. Carries Modified ‚Üí Shared state transition.',
    why:'Happens automatically when the L1 is full and a new line must enter. Frequent write-backs indicate working sets larger than L1 ‚Äî a sign you should either reduce data reuse distances or tune the SMEM/L1 split.' },
  'EVICT':  { name:'EVICT  (L2 victim eviction)', color:'#339af0',
    what:'An L2 cache line is being evicted to DRAM because L2 is full. The victim line (chosen by LRU policy) travels through the NoC to the memory controller. Ampere\'s persistence window lets you protect chosen lines from eviction.',
    why:'L2 evictions to DRAM are slow (~400+ cycles). If your kernel constantly evicts from L2 it\'s DRAM-bandwidth-bound. Ampere\'s cudaAccessPolicyWindow lets you pin hot data (e.g., a weight matrix) to resist eviction.' },
  'STORE':  { name:'STORE  (DRAM write)', color:'#845ef7',
    what:'The final write command issued from a memory controller to an HBM/GDDR bank. At this point data leaves the on-chip world entirely. Row-activation (tRCD), column write (tCL), and precharge (tRP) timing all apply.',
    why:'DRAM writes are the slowest path in the hierarchy. You want kernels to rarely reach here ‚Äî maximize L2 residency and use cp.async or TMA to overlap DRAM reads with compute rather than blocking on them.' },
  'DSMEM':  { name:'DSMEM  (distributed shared memory)', color:'#22d3ee',
    what:'Hopper-only packet. An SM reads from another SM\'s shared memory within the same Thread Block Cluster. The request travels the cluster bus ‚Äî but stays entirely on-chip, never touching L2 or DRAM. ~20 cycle latency.',
    why:'Enables sub-L2 communication between cooperating SMs: e.g., overlapping tiles in FlashAttention-style kernels, or producer-consumer pipelines where one SM generates data another immediately consumes.' },
  'cp.async':{ name:'cp.async  (async global‚Üíshared copy)', color:'#22d3ee',
    what:'Ampere instruction. Initiates a DMA-style transfer from global memory directly into SMEM ‚Äî without allocating registers, without stalling the issuing warp. Multiple cp.async loads can be in flight simultaneously.',
    why:'The key to software pipelining (double-buffering) on Ampere+: issue cp.async for tile N+1 while computing on tile N. Completely hides DRAM latency. Critical for reaching peak FLOPS on matrix multiply kernels.' },
};

var ARCHS = {
  pascal: {
    name:'Pascal', gen:'SM 6.1', year:2016, color:'#51cf66', example:'GTX 1080 Ti',
    smLabel:'SM',
    intro:"The last generation before unified L1. Pascal keeps things simple ‚Äî L1 is read-only for global memory, so there's zero coherency overhead at L1. Writes go straight to L2. Great for understanding the baseline before things got complex.",
    perf:{ smCount:28, l1Size:24, smemSize:96, l2Size:4096, bw:484, flops:11.3, memType:'GDDR5X', vram:11, tdp:250, l1Latency:28, l2Latency:200, dramLatency:400 },
    blocks:{
      l1:{ label:'L1 (24KB)', desc:'Read-only texture/data cache. NOT coherent with global stores.', state:true },
      texCache:{ label:'TEX$', desc:'Separate texture cache, read-only, ~24KB.' },
      sharedMem:{ label:'SMEM (48‚Äì96KB)', desc:'Separate physical SRAM from L1. Configurable split.', state:false },
      l2:{ label:'L2 Cache (3‚Äì4MB)', desc:'Unified, coherent. Point of coherence for all SMs.', size:'3‚Äì4MB' },
      coherencyBus:{ label:'Crossbar', desc:'Simple crossbar ‚Äî minimal coherency traffic since L1 is read-only.' },
      globalMem:{ label:'Global Memory', desc:'GDDR5/GDDR5X memory interface.' },
      hbm:{ label:'GDDR5X', desc:'High-speed GDDR, ~480 GB/s on 1080 Ti.' },
    },
    writePolicy:'Write-through (L1 is read-only for globals)',
    coherency:'None at L1 ‚Äî L2 is sole coherence point',
    keyChange:null,
  },
  volta: {
    name:'Volta', gen:'SM 7.0', year:2017, color:'#339af0', example:'V100',
    smLabel:'SM',
    intro:"The big unification. Volta merged L1 and texture cache into a single 128KB SRAM that's also shared with SMEM. L1 now caches global writes too, which means coherency actually matters ‚Äî enter write-evict and invalidation.",
    perf:{ smCount:80, l1Size:128, smemSize:96, l2Size:6144, bw:900, flops:15.7, memType:'HBM2', vram:32, tdp:300, l1Latency:28, l2Latency:193, dramLatency:370 },
    blocks:{
      l1:{ label:'L1 + TEX (unified, 128KB)', desc:'L1 and texture cache merged.', state:true, changed:true },
      texCache:null,
      sharedMem:{ label:'SMEM (up to 96KB)', desc:'Shares the 128KB SRAM pool with L1.', changed:true },
      l2:{ label:'L2 Cache (6MB)', desc:'Larger L2. Write-evict policy from L1.', size:'6MB', changed:true },
      coherencyBus:{ label:'Coherency Bus', desc:'Now carries invalidation messages.' },
      globalMem:{ label:'Global Memory', desc:'HBM2 interface. 4 stacks.' },
      hbm:{ label:'HBM2', desc:'900 GB/s. Stacked DRAM.', changed:true },
    },
    writePolicy:'Write-evict (dirty L1 line dropped, write goes to L2)',
    coherency:'L1 invalidation via bus, L2 is coherence point',
    keyChange:'L1 + TEX unified, shared SRAM pool with SMEM, HBM2',
  },
  ampere: {
    name:'Ampere', gen:'SM 8.0', year:2020, color:'#ffa94d', example:'A100',
    smLabel:'SM',
    intro:"Ampere's headline: 10x larger L2 (40MB!) with software-controlled persistence, and async copy (cp.async) that moves data from global to shared memory without burning registers.",
    perf:{ smCount:108, l1Size:192, smemSize:164, l2Size:40960, bw:2039, flops:19.5, memType:'HBM2e', vram:80, tdp:400, l1Latency:33, l2Latency:200, dramLatency:400 },
    blocks:{
      l1:{ label:'L1 + TEX (192KB)', desc:'Larger unified L1/TEX cache.', state:true, changed:true },
      texCache:null,
      sharedMem:{ label:'SMEM (up to 164KB)', desc:'Larger SMEM. cp.async bypasses register file.', changed:true },
      asyncCopy:{ label:'ASYNC COPY', desc:'cp.async: DMA-like transfer from global to shared, bypassing registers.', isNew:true },
      l2:{ label:'L2 Cache (40MB)', desc:'Massive L2. Persistence controls via cudaAccessPolicyWindow.', size:'40MB', changed:true },
      l2Persist:{ label:'L2 PERSIST', desc:'Software-controlled L2 data persistence.', isNew:true },
      coherencyBus:{ label:'Coherency Bus', desc:'Same write-evict L1 coherency as Volta.' },
      globalMem:{ label:'Global Memory', desc:'HBM2e interface. 5 stacks.' },
      hbm:{ label:'HBM2e', desc:'2 TB/s. 80GB.', changed:true },
    },
    writePolicy:'Write-evict (same as Volta)',
    coherency:'L1 write-evict + invalidation, L2 persistence controls',
    keyChange:'Async copy (cp.async), 10√ó larger L2 with persistence',
  },
  hopper: {
    name:'Hopper', gen:'SM 9.0', year:2022, color:'#845ef7', example:'H100',
    smLabel:'SM',
    intro:"Hopper introduces TMA (Tensor Memory Accelerator) ‚Äî a hardware DMA engine for complex tensor addressing ‚Äî and DSMEM, where SMs in a cluster can directly read each other's shared memory.",
    perf:{ smCount:132, l1Size:256, smemSize:228, l2Size:51200, bw:3352, flops:66.9, memType:'HBM3', vram:80, tdp:700, l1Latency:33, l2Latency:200, dramLatency:380 },
    blocks:{
      l1:{ label:'L1 + TEX (256KB)', desc:'Even larger unified cache with TMA support.', state:true, changed:true },
      texCache:null,
      sharedMem:{ label:'SMEM (up to 228KB)', desc:'Largest SMEM. DSMEM for cross-SM shared memory access.', changed:true },
      dsmem:{ label:'DSMEM', desc:'Distributed Shared Memory. SMs within a cluster can directly access each other\'s shared memory.', isNew:true },
      tma:{ label:'TMA', desc:'Tensor Memory Accelerator. Hardware DMA for bulk data transfers with tensor-aware addressing.', isNew:true },
      asyncCopy:{ label:'ASYNC COPY', desc:'Enhanced from Ampere with TMA integration.' },
      l2:{ label:'L2 Cache (50MB)', desc:'Larger still with improved persistence controls.', size:'50MB', changed:true },
      l2Persist:{ label:'L2 PERSIST', desc:'Refined from Ampere with better granularity.' },
      coherencyBus:{ label:'Cluster Bus', desc:'New cluster-level interconnect for DSMEM.', changed:true },
      globalMem:{ label:'Global Memory', desc:'HBM3 interface.' },
      hbm:{ label:'HBM3', desc:'3.35 TB/s. 80GB.', changed:true },
    },
    writePolicy:'Write-evict + TMA bulk transfers',
    coherency:'Cluster-level DSMEM coherency + L2 global coherence',
    keyChange:'TMA engine, Distributed Shared Memory (DSMEM), HBM3',
  }
};

var currentArch = 'pascal';
var prevArch = null;
var stats = { hits:0, misses:0, inv:0, wb:0 };
var autoMode = true, autoTimer = 0;
var particles = [], flashEffects = [], stepTimers = [], bubbles = [];
var layout = {};

// ‚îÄ‚îÄ Cache line state per SM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Each SM has: l1Lines[16] and smemLines[16]
// Each slot: 0=empty, 1=valid/clean, 2=dirty/modified
var NUM_LINES = 16;
var cacheState = [];  // indexed by smIdx: { l1: [], smem: [] }

function initCacheState() {
  cacheState = [];
  var n = layout.sms ? layout.sms.length : 4;
  for (var i = 0; i < n; i++) {
    cacheState.push({
      l1:   new Array(NUM_LINES).fill(0),
      smem: new Array(NUM_LINES).fill(0),
    });
  }
}

// Randomise a realistic partial fill for an SM's L1 (after a read)
function fillL1Random(smIdx, dirty) {
  if (!cacheState[smIdx]) return;
  var lines = cacheState[smIdx].l1;
  // Fill 6-13 random lines
  var count = 6 + Math.floor(Math.random() * 8);
  for (var i = 0; i < NUM_LINES; i++) {
    lines[i] = i < count ? (dirty ? 2 : 1) : 0;
  }
  // Shuffle
  for (var j = NUM_LINES - 1; j > 0; j--) {
    var k = Math.floor(Math.random() * (j + 1));
    var tmp = lines[j]; lines[j] = lines[k]; lines[k] = tmp;
  }
}

function setL1Dirty(smIdx) {
  if (!cacheState[smIdx]) return;
  var lines = cacheState[smIdx].l1;
  var filled = lines.filter(function(v){ return v > 0; }).length;
  if (filled < 4) { fillL1Random(smIdx, false); }
  // Mark 1-3 random clean lines as dirty
  var dirtied = 0;
  for (var i = 0; i < NUM_LINES && dirtied < 3; i++) {
    if (lines[i] === 1 && Math.random() > 0.5) { lines[i] = 2; dirtied++; }
  }
  if (dirtied === 0) { lines[Math.floor(Math.random()*NUM_LINES)] = 2; }
}

function invalidateL1(smIdx) {
  if (!cacheState[smIdx]) return;
  cacheState[smIdx].l1 = new Array(NUM_LINES).fill(0);
}

function writebackL1(smIdx) {
  if (!cacheState[smIdx]) return;
  // Dirty ‚Üí clean on writeback
  var lines = cacheState[smIdx].l1;
  for (var i = 0; i < NUM_LINES; i++) { if (lines[i] === 2) lines[i] = 1; }
}

function fillSmem(smIdx) {
  if (!cacheState[smIdx]) return;
  var lines = cacheState[smIdx].smem;
  var count = 8 + Math.floor(Math.random() * 7);
  for (var i = 0; i < NUM_LINES; i++) lines[i] = i < count ? 1 : 0;
  for (var j = NUM_LINES - 1; j > 0; j--) {
    var kk = Math.floor(Math.random() * (j + 1));
    var tt = lines[j]; lines[j] = lines[kk]; lines[kk] = tt;
  }
}

function getCacheStats(smIdx, kind) {
  if (!cacheState[smIdx]) return { filled:0, dirty:0, empty:NUM_LINES };
  var arr = cacheState[smIdx][kind];
  var filled = 0, dirty = 0;
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === 1) filled++;
    else if (arr[i] === 2) { filled++; dirty++; }
  }
  return { filled: filled, dirty: dirty, empty: NUM_LINES - filled };
}

// ‚îÄ‚îÄ‚îÄ Hover / selection state ‚îÄ‚îÄ‚îÄ
var hoveredBlock = null;
var selectedBlock = null;
var connLines = [];
var mouseX = 0, mouseY = 0;
var lastClientX = 0, lastClientY = 0;  // for live tooltip refresh from drawFrame

// ‚îÄ‚îÄ‚îÄ All "hit" rectangles (rebuilt each buildLayout) ‚îÄ‚îÄ‚îÄ
var hitRects = []; // [{type, x, y, w, h, smIdx}]

function buildHitRects() {
  hitRects = [];
  // SM sub-blocks
  for (var si = 0; si < layout.sms.length; si++) {
    var sm = layout.sms[si];
    for (var bi = 0; bi < sm.sub.length; bi++) {
      var b = sm.sub[bi];
      hitRects.push({ type: b.type, x: b.x, y: b.y, w: b.w, h: b.h, smIdx: si, label: b.label });
    }
  }
  // L2
  if (layout.l2) hitRects.push({ type: 'l2', x: layout.l2.x, y: layout.l2.y, w: layout.l2.w, h: layout.l2.h });
  // L2 persist
  if (layout.l2Persist) hitRects.push({ type: 'l2Persist', x: layout.l2Persist.x, y: layout.l2Persist.y, w: layout.l2Persist.w, h: layout.l2Persist.h });
  // Bus (thin strip)
  if (layout.bus) hitRects.push({ type: 'bus', x: layout.bus.x1, y: layout.bus.y - 12, w: layout.bus.x2 - layout.bus.x1, h: 24 });
  // Global mem
  if (layout.globalMem) hitRects.push({ type: 'globalMem', x: layout.globalMem.x, y: layout.globalMem.y, w: layout.globalMem.w, h: layout.globalMem.h });
  // HBM
  if (layout.hbm) hitRects.push({ type: 'hbm', x: layout.hbm.x, y: layout.hbm.y, w: layout.hbm.w, h: layout.hbm.h });
}

function hitTest(mx, my) {
  for (var i = hitRects.length - 1; i >= 0; i--) {
    var r = hitRects[i];
    if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) return r;
  }
  return null;
}

function getBlockCenter(type, smIdx) {
  if (type === 'l2') return { x: layout.l2.x + layout.l2.w/2, y: layout.l2.y + layout.l2.h/2 };
  if (type === 'l2Persist') return { x: layout.l2Persist.x + layout.l2Persist.w/2, y: layout.l2Persist.y + layout.l2Persist.h/2 };
  if (type === 'bus') return { x: (layout.bus.x1 + layout.bus.x2)/2, y: layout.bus.y };
  if (type === 'globalMem') return { x: layout.globalMem.x + layout.globalMem.w/2, y: layout.globalMem.y + layout.globalMem.h/2 };
  if (type === 'hbm') return { x: layout.hbm.x + layout.hbm.w/2, y: layout.hbm.y + layout.hbm.h/2 };
  // SM sub-block
  var targetSmIdx = (smIdx !== undefined && smIdx !== null) ? smIdx : 0;
  for (var si = 0; si < layout.sms.length; si++) {
    var sm = layout.sms[si];
    for (var bi = 0; bi < sm.sub.length; bi++) {
      var b = sm.sub[bi];
      if (b.type === type && si === targetSmIdx) return { x: b.x + b.w/2, y: b.y + b.h/2 };
    }
  }
  // Any SM with that type
  for (var si2 = 0; si2 < layout.sms.length; si2++) {
    for (var bi2 = 0; bi2 < layout.sms[si2].sub.length; bi2++) {
      if (layout.sms[si2].sub[bi2].type === type) {
        var bb = layout.sms[si2].sub[bi2];
        return { x: bb.x + bb.w/2, y: bb.y + bb.h/2 };
      }
    }
  }
  return null;
}

function getBlockRect(type, smIdx) {
  for (var i = 0; i < hitRects.length; i++) {
    var r = hitRects[i];
    if (r.type === type && (smIdx === undefined || r.smIdx === smIdx)) return r;
  }
  return null;
}

// ‚îÄ‚îÄ‚îÄ Connection line animation ‚îÄ‚îÄ‚îÄ
var connLineAnim = 0;
var SM_LOCAL_TYPES = { regs:1, l1:1, texCache:1, smem:1, tma:1, dsmem:1, async:1 };

function buildConnLines(blockType, smIdx) {
  var info = BLOCK_INFO[blockType];
  if (!info || !info.connects) return;
  connLines = [];
  var from = getBlockCenter(blockType, smIdx);
  if (!from) return;
  for (var i = 0; i < info.connects.length; i++) {
    var conn = info.connects[i];
    var isGlobal = !SM_LOCAL_TYPES[conn.to];
    if (isGlobal) {
      // Global target (l2, bus, globalMem, hbm, l2Persist) ‚Äî single line
      var tc = getBlockCenter(conn.to, smIdx);
      if (tc) connLines.push({ from: from, to: tc, why: conn.why, arrow: conn.arrow, color: info.color });
    } else {
      // SM-local target ‚Äî only connect to the SAME SM, not all SMs
      var tc2 = getBlockCenter(conn.to, smIdx);
      if (tc2) connLines.push({ from: from, to: tc2, why: conn.why, arrow: conn.arrow, color: info.color });
    }
  }
  connLineAnim = 0;
}

// Canvas mouse handlers
canvas.addEventListener('mousemove', function(e) {
  var r = canvas.getBoundingClientRect();
  mouseX = e.clientX - r.left;
  mouseY = e.clientY - r.top;
  lastClientX = e.clientX;
  lastClientY = e.clientY;

  // Check particle label hover first (higher priority when labels are near)
  var pHit = hitTestParticleLabels(mouseX, mouseY);
  if (pHit && INSTRUCTION_INFO[pHit.key]) {
    showInstrTooltip(pHit.key, pHit.clientX, pHit.clientY - 20);
    hoveredBlock = null;
    hideTooltip();
    canvas.style.cursor = 'help';
    return;
  }
  hideInstrTooltip();

  var hit = hitTest(mouseX, mouseY);
  hoveredBlock = hit;
  canvas.style.cursor = hit ? 'pointer' : 'default';
  updateTooltip(hit, e.clientX, e.clientY);
});

canvas.addEventListener('mouseleave', function() {
  hoveredBlock = null;
  hideTooltip();
  hideInstrTooltip();
});

canvas.addEventListener('click', function(e) {
  var r = canvas.getBoundingClientRect();
  var mx = e.clientX - r.left;
  var my = e.clientY - r.top;
  var hit = hitTest(mx, my);
  if (hit) {
    if (selectedBlock && selectedBlock.type === hit.type && selectedBlock.smIdx === hit.smIdx) {
      clearSelection();
    } else {
      selectBlock(hit);
    }
  } else {
    clearSelection();
  }
});

function selectBlock(hit) {
  selectedBlock = hit;
  buildConnLines(hit.type, hit.smIdx);
  updateSelPanel(hit);
}

function clearSelection() {
  selectedBlock = null;
  connLines = [];
  document.getElementById('sel-panel').classList.remove('visible');
}

function updateSelPanel(hit) {
  var info = BLOCK_INFO[hit.type];
  if (!info) return;
  var panel = document.getElementById('sel-panel');
  panel.classList.add('visible');
  document.getElementById('sel-name').innerHTML = '<span style="color:' + info.color + '">' + info.name + '</span>';
  document.getElementById('sel-desc').textContent = info.desc;
  var connList = document.getElementById('conn-list');
  connList.innerHTML = '';
  if (!info.connects || info.connects.length === 0) {
    connList.innerHTML = '<div style="font-size:.75rem;color:var(--dim);padding:6px 0">No direct connections defined.</div>';
    return;
  }
  for (var i = 0; i < info.connects.length; i++) {
    var c = info.connects[i];
    var targetInfo = BLOCK_INFO[c.to] || {};
    var el = document.createElement('div');
    el.className = 'conn-item';
    el.innerHTML = '<span class="ci-arrow" style="color:' + (targetInfo.color||'#6b7094') + '">' + c.arrow + '</span><div class="ci-body"><span class="ci-target" style="color:' + (targetInfo.color||'#aaa') + '">' + (targetInfo.name || c.to) + '</span><span class="ci-why">' + c.why + '</span></div>';
    // Clicking a connection item highlights that target
    (function(connTo) {
      el.addEventListener('click', function(e) {
        e.stopPropagation();
        var targetHit = getBlockRect(connTo, hit.smIdx) || getBlockRect(connTo);
        if (targetHit) selectBlock(targetHit);
      });
    })(c.to);
    connList.appendChild(el);
  }
}

var tooltipEl = document.getElementById('block-tooltip');
var ttName = document.getElementById('tt-name');
var ttDot = document.getElementById('tt-dot');
var ttDesc = document.getElementById('tt-desc');
var ttMeta = document.getElementById('tt-meta');
var ttHint = document.getElementById('tt-hint');

// ‚îÄ‚îÄ Instruction tooltip ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
var instrTooltipEl = null;
var instrHovered = null;

function getInstrEl() {
  if (!instrTooltipEl) instrTooltipEl = document.getElementById('instr-tooltip');
  return instrTooltipEl;
}

function showInstrTooltip(key, clientX, clientY) {
  var info = INSTRUCTION_INFO[key];
  if (!info) return;
  var el = getInstrEl();
  if (!el) return;
  if (instrHovered === key) { positionInstrTooltip(clientX, clientY); return; }
  instrHovered = key;
  document.getElementById('it-dot').style.background = info.color;
  el.style.borderColor = info.color + '40';
  document.getElementById('it-name').textContent = info.name;
  document.getElementById('it-what').textContent = info.what;
  document.getElementById('it-why').textContent = info.why;
  el.querySelector('.it-why-box').style.borderColor = info.color + '30';
  positionInstrTooltip(clientX, clientY);
  el.classList.add('visible');
}

function hideInstrTooltip() {
  instrHovered = null;
  var el = getInstrEl();
  if (el) el.classList.remove('visible');
}

function positionInstrTooltip(clientX, clientY) {
  var el = getInstrEl();
  if (!el) return;
  var tw = 320, th = 220;
  var vw = window.innerWidth, vh = window.innerHeight;
  var tx = clientX + 18;
  var ty = clientY - 24;
  if (tx + tw > vw - 10) tx = clientX - tw - 18;
  if (ty + th > vh - 10) ty = clientY - th + 10;
  if (ty < 8) ty = 8;
  el.style.left = tx + 'px';
  el.style.top  = ty + 'px';
}

// Particle label hit-rects rebuilt each frame for hover detection
var particleLabelRects = [];

function buildParticleLabelRects() {
  particleLabelRects = [];
  var cr = canvas.getBoundingClientRect();
  for (var i = 0; i < particles.length; i++) {
    var p = particles[i];
    if (!p.label || !p.alive) continue;
    var cx2 = p.from.x + (p.to.x - p.from.x) * p.t;
    var cy2 = p.from.y + (p.to.y - p.from.y) * p.t;
    // Also store absolute client coords for tooltip positioning
    var clientX = cr.left + cx2;
    var clientY = cr.top  + cy2;
    particleLabelRects.push({ key: p.label, cx: cx2, cy: cy2, clientX: clientX, clientY: clientY });
  }
}

// mx/my in canvas CSS-pixel coords
function hitTestParticleLabels(mx, my) {
  var HIT_R = 36; // large radius ‚Äî particles move fast
  for (var i = 0; i < particleLabelRects.length; i++) {
    var r = particleLabelRects[i];
    var dx = mx - r.cx;
    var dy = my - (r.cy - 12); // label drawn 12px above dot
    if (dx*dx + dy*dy < HIT_R*HIT_R) return r;
  }
  return null;
}
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function updateTooltip(hit, clientX, clientY) {
  if (!hit) { hideTooltip(); return; }
  var info = BLOCK_INFO[hit.type];
  if (!info) { hideTooltip(); return; }

  // Static content (only set on block change, not every frame)
  ttName.textContent = info.name;
  ttDot.style.background = info.color;
  tooltipEl.style.borderColor = info.color + '50';
  ttDesc.textContent = info.desc;

  var isCacheBlock = (hit.type === 'l1' || hit.type === 'smem') && hit.smIdx !== undefined;

  if (isCacheBlock) {
    // Build stable DOM structure with IDs for per-frame refresh
    ttMeta.innerHTML =
      '<div style="margin-bottom:2px">' +
        '<div style="display:flex;align-items:center;gap:6px;margin-bottom:5px">' +
          '<span style="font-family:JetBrains Mono,monospace;font-size:.6rem;color:#9095b0;text-transform:uppercase;letter-spacing:1px">Cache Lines</span>' +
          '<span id="tt-fill-label" style="font-family:JetBrains Mono,monospace;font-size:.68rem;font-weight:700;color:'+info.color+'"></span>' +
          '<span id="tt-dirty-label" style="font-family:JetBrains Mono,monospace;font-size:.62rem;color:#51cf66"></span>' +
        '</div>' +
        '<div id="tt-line-grid" style="display:flex;gap:2px;height:10px;margin-bottom:5px"></div>' +
        '<div id="tt-state-label" style="font-size:.66rem;font-family:JetBrains Mono,monospace"></div>' +
      '</div>';
    refreshTooltipCacheData(hit, info);
  } else {
    ttMeta.innerHTML = '';
    if (info.chips) {
      for (var i = 0; i < info.chips.length; i++) {
        var chip = info.chips[i];
        var span = document.createElement('span');
        span.className = 'tt-chip';
        span.style.background = chip.c + '20';
        span.style.color = chip.c;
        span.textContent = chip.t;
        ttMeta.appendChild(span);
      }
    }
  }

  ttHint.style.display = (selectedBlock && selectedBlock.type === hit.type) ? 'none' : 'flex';
  positionTooltip(clientX, clientY);
  tooltipEl.classList.add('visible');
}

// Called every frame while hovering a cache block ‚Äî updates just the live data
function refreshTooltipCacheData(hit, info) {
  if (!hit) return;
  var inf = info || BLOCK_INFO[hit.type];
  if (!inf) return;
  var kind = hit.type === 'l1' ? 'l1' : 'smem';
  if (hit.type !== 'l1' && hit.type !== 'smem') return;

  var cs = getCacheStats(hit.smIdx, kind);
  var arr = cacheState[hit.smIdx] ? cacheState[hit.smIdx][kind] : [];

  // Update fill label
  var fillLbl = document.getElementById('tt-fill-label');
  if (fillLbl) fillLbl.textContent = cs.filled + '/' + NUM_LINES + ' filled';

  // Update dirty label
  var dirtyLbl = document.getElementById('tt-dirty-label');
  if (dirtyLbl) dirtyLbl.textContent = cs.dirty > 0 ? cs.dirty + ' dirty' : '';

  // Rebuild line grid squares (fast ‚Äî just fill colors)
  var grid = document.getElementById('tt-line-grid');
  if (grid) {
    // Only rebuild if child count changed or on first pass
    if (grid.children.length !== NUM_LINES) {
      grid.innerHTML = '';
      for (var li = 0; li < NUM_LINES; li++) {
        var sq = document.createElement('div');
        sq.style.cssText = 'flex:1;border-radius:2px;transition:background .12s';
        grid.appendChild(sq);
      }
    }
    for (var li2 = 0; li2 < NUM_LINES; li2++) {
      var lv = arr[li2] || 0;
      var lc;
      if (lv === 2)      lc = '#51cf66';
      else if (lv === 1) lc = hit.type === 'l1' ? inf.color + 'cc' : '#51cf6688';
      else               lc = '#1e2030';
      grid.children[li2].style.background = lc;
    }
  }

  // Update state label (L1 only)
  var stateLbl = document.getElementById('tt-state-label');
  if (stateLbl && hit.type === 'l1') {
    var l1b = null;
    if (layout.sms[hit.smIdx]) {
      for (var bi = 0; bi < layout.sms[hit.smIdx].sub.length; bi++) {
        if (layout.sms[hit.smIdx].sub[bi].type === 'l1') { l1b = layout.sms[hit.smIdx].sub[bi]; break; }
      }
    }
    var st = l1b ? l1b.state : 'invalid';
    var stateLabel, stateColor;
    if (st === 'modified')      { stateLabel = '‚óè Modified ‚Äî has dirty data';  stateColor = '#51cf66'; }
    else if (st === 'shared')   { stateLabel = '‚óè Shared ‚Äî clean copy';        stateColor = '#5ab0f8'; }
    else                        { stateLabel = '‚óè Invalid ‚Äî empty';            stateColor = '#6b7090'; }
    stateLbl.style.color = stateColor;
    stateLbl.textContent = stateLabel;
  } else if (stateLbl && hit.type === 'smem') {
    var smFilled = cs.filled;
    stateLbl.style.color = smFilled > 0 ? '#6ee09a' : '#6b7090';
    stateLbl.textContent = smFilled > 0 ? '‚óè Active ‚Äî ' + smFilled + ' slots used' : '‚óè Empty ‚Äî no data loaded';
  }
}

function positionTooltip(clientX, clientY) {
  var vizRect = canvas.parentElement.getBoundingClientRect();
  var tx = clientX - vizRect.left + 14;
  var ty = clientY - vizRect.top - 12;
  var tw = 250, th = 160;
  if (tx + tw > vizRect.width - 10)  tx = clientX - vizRect.left - tw - 14;
  if (ty + th > vizRect.height - 10) ty = clientY - vizRect.top - th - 12;
  if (ty < 4) ty = 4;
  tooltipEl.style.left = tx + 'px';
  tooltipEl.style.top  = ty + 'px';
}

function hideTooltip() {
  tooltipEl.classList.remove('visible');
}

// Floating bubble system
function bubble(x, y, text, color, opts) {
  var o = opts || {};
  bubbles.push({ x:x, y:y-8, text:text, sub:o.sub||null, color:color, bg:(o.bg||color.slice(0,7))+'18', age:0, life:o.life||1.9, rise:o.rise||18, wobble:Math.random()*6 });
}

function updateDiffBanner() {
  var banner = document.getElementById('diff-banner');
  if (!prevArch || prevArch === currentArch) { banner.classList.remove('visible'); return; }
  var prev = ARCHS[prevArch], curr = ARCHS[currentArch];
  var parts = [];
  for (var k in curr.blocks) {
    var v = curr.blocks[k]; if (!v) continue;
    var prevBlock = prev.blocks[k];
    if (!prevBlock && v) parts.push('<span class="new-tag">+ ' + v.label + '</span>');
    else if (prevBlock && v.changed) parts.push('<span class="changed-tag">‚Üë ' + v.label + '</span>');
  }
  for (var k2 in prev.blocks) {
    var v2 = prev.blocks[k2]; if (!v2) continue;
    if (!curr.blocks[k2] || curr.blocks[k2] === null) parts.push('<span class="removed-tag">' + v2.label + '</span>');
  }
  if (curr.keyChange) parts.push('<br><span style="color:var(--dim)">Key: ' + curr.keyChange + '</span>');
  if (parts.length) {
    banner.innerHTML = '<strong style="color:' + curr.color + '">' + prev.name + ' ‚Üí ' + curr.name + ':</strong> ' + parts.join(' ¬∑ ');
    banner.classList.add('visible');
  } else { banner.classList.remove('visible'); }
}

function updateKeyCard() {
  var arch = ARCHS[currentArch];
  var prev = prevArch ? ARCHS[prevArch] : null;
  var html = '<h3>Diagram Key ‚Äî ' + arch.name + ' <span style="color:' + arch.color + ';font-weight:600">' + arch.example + '</span></h3>';
  var items = [
    { key:'l1', color:'var(--l1)', meta:'per-SM' },
    { key:'texCache', color:'#e599f7', meta:'per-SM' },
    { key:'sharedMem', color:'var(--smem)', meta:'per-SM' },
    { key:'dsmem', color:'var(--new-block)', meta:'cluster' },
    { key:'tma', color:'var(--new-block)', meta:'per-SM' },
    { key:'asyncCopy', color:'var(--new-block)', meta:'engine' },
    { key:'coherencyBus', color:'var(--coherency)', meta:'fabric' },
    { key:'l2', color:'var(--l2)', meta:'unified' },
    { key:'l2Persist', color:'var(--l2)', meta:'L2 ctrl' },
    { key:'globalMem', color:'var(--global)', meta:'interface' },
    { key:'hbm', color:'var(--dram)', meta:'off-chip' },
  ];
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    var block = arch.blocks[item.key];
    if (!block) continue;
    var badge = '';
    if (block.isNew) badge = '<span class="acc-badge-new">NEW</span>';
    else if (block.changed && prev) badge = '<span class="acc-badge-changed">CHANGED</span>';
    html += '<div class="acc-item" onclick="this.classList.toggle(\'open\')"><div class="acc-head"><div class="acc-dot" style="background:' + item.color + '"></div><span class="acc-title">' + block.label + badge + '</span><span class="acc-meta">' + item.meta + '</span><span class="acc-chev">‚ñ∏</span></div><div class="acc-body"><p>' + block.desc + '</p></div></div>';
  }
  html += '<div style="margin-top:10px;padding-top:8px;border-top:1px solid var(--border);font-size:.72rem;color:var(--dim)"><strong style="color:var(--text)">Write policy:</strong> ' + arch.writePolicy + '<br><strong style="color:var(--text)">Coherency:</strong> ' + arch.coherency + '</div>';
  document.getElementById('key-card').innerHTML = html;
}

function switchArch(arch) {
  if (arch === currentArch) return;
  prevArch = currentArch;
  currentArch = arch;
  var tabs = document.querySelectorAll('.arch-tab');
  for (var i = 0; i < tabs.length; i++) { tabs[i].classList.toggle('active', tabs[i].dataset.arch === arch); }
  clearSelection();
  resetAll(true);
  buildLayout();
  updateDiffBanner();
  updateKeyCard();
  updateArchIntro();
  
  logEvent('Switched to ' + ARCHS[arch].name + ' (' + ARCHS[arch].gen + ')', ARCHS[arch].color);
}

function updateArchIntro() {
  var arch = ARCHS[currentArch];
  document.getElementById('arch-intro').innerHTML = '<div class="arch-intro-badge" style="background:' + arch.color + '20;color:' + arch.color + '">' + arch.name + ' ¬∑ ' + arch.example + '</div><div class="arch-intro-text">' + arch.intro + '</div>';
}



function buildLayout() {
  if (!W || !H) return;
  var cx = W/2;
  var mob = W < 500;
  var arch = ARCHS[currentArch];
  var smCount = mob ? 2 : (currentArch === 'hopper' ? 4 : (currentArch === 'pascal' ? 3 : 4));
  var margin = mob ? 12 : 30;
  var usable = W - margin*2;
  var smGap = mob ? 12 : 20;
  var smW = Math.min(110, (usable - (smCount-1)*smGap)/smCount);
  var smSubBlocks = 2;
  if (arch.blocks.texCache) smSubBlocks++;
  if (arch.blocks.tma) smSubBlocks++;
  if (arch.blocks.dsmem) smSubBlocks++;
  if (arch.blocks.asyncCopy && arch.blocks.asyncCopy.isNew) smSubBlocks++;
  var smH = mob ? (80+smSubBlocks*18) : (90+smSubBlocks*22);
  var totalSmW = smCount*smW + (smCount-1)*smGap;
  var smStartX = cx - totalSmW/2;
  var smY = mob ? 16 : 30;

  layout.sms = [];
  for (var i = 0; i < smCount; i++) {
    var x = smStartX + i*(smW+smGap);
    var subY = smY + (mob ? 32 : 38);
    var subH = mob ? 18 : 22;
    var subPad = mob ? 4 : 5;
    var sub = [];
    sub.push({ type:'regs', x:x+6, y:subY, w:smW-12, h:6 });
    subY += 10;
    if (arch.blocks.texCache) {
      sub.push({ type:'texCache', x:x+6, y:subY, w:smW-12, h:subH, label:'TEX$' });
      subY += subH+subPad;
    }
    sub.push({ type:'l1', x:x+6, y:subY, w:smW-12, h:subH, label:arch.blocks.l1.label.split('(')[0].trim(), state:'invalid' });
    var l1Ref = sub[sub.length-1];
    subY += subH+subPad;
    sub.push({ type:'smem', x:x+6, y:subY, w:smW-12, h:subH, label:'SMEM' });
    subY += subH+subPad;
    if (arch.blocks.tma) {
      sub.push({ type:'tma', x:x+6, y:subY, w:smW-12, h:subH, label:'TMA' });
      subY += subH+subPad;
    }
    if (arch.blocks.dsmem) {
      sub.push({ type:'dsmem', x:x+6, y:subY, w:smW-12, h:subH, label:'DSMEM' });
      subY += subH+subPad;
    }
    if (arch.blocks.asyncCopy && (currentArch === 'ampere' || currentArch === 'hopper')) {
      sub.push({ type:'async', x:x+6, y:subY, w:smW-12, h:14, label:'cp.async' });
      subY += 14+subPad;
    }
    var actualH = Math.max(smH, subY-smY+8);
    layout.sms.push({ x:x, y:smY, w:smW, h:actualH, label:arch.smLabel+' '+i, sub:sub, l1:l1Ref });
  }

  var maxSmBottom = 0;
  for (var j = 0; j < layout.sms.length; j++) { maxSmBottom = Math.max(maxSmBottom, layout.sms[j].y+layout.sms[j].h); }

  if (currentArch === 'hopper' && smCount > 1) {
    layout.cluster = { x1:smStartX-6, x2:smStartX+totalSmW+6, y1:smY-8, y2:maxSmBottom+8 };
  } else { layout.cluster = null; }

  var busY = maxSmBottom + (mob ? 30 : 40);
  layout.bus = { y:busY, x1:smStartX-15, x2:smStartX+totalSmW+15, label:currentArch==='hopper' ? 'CLUSTER BUS + COHERENCY' : (currentArch==='pascal' ? 'CROSSBAR' : 'COHERENCY BUS') };

  var l2W = Math.min(totalSmW*0.85, usable*0.78);
  var l2Y = busY + (mob ? 35 : 45);
  var l2H = mob ? 42 : 52;
  layout.l2 = { x:cx-l2W/2, y:l2Y, w:l2W, h:l2H };
  layout.l2Persist = (currentArch==='ampere'||currentArch==='hopper') ? { x:cx-l2W/2+6, y:l2Y+l2H-12, w:l2W-12, h:8 } : null;

  var cbY = l2Y+l2H+(mob ? 22 : 30);
  layout.crossbar = { y:cbY, x1:cx-l2W/2-8, x2:cx+l2W/2+8 };

  var gmW = Math.min(totalSmW*0.85, usable*0.82);
  var gmY = cbY + (mob ? 28 : 38);
  var gmH = mob ? 52 : 62;
  layout.globalMem = { x:cx-gmW/2, y:gmY, w:gmW, h:gmH };

  var mcCount = mob ? 2 : (currentArch==='pascal' ? 3 : 4);
  var mcW = mob ? 36 : 44;
  var mcGap2 = (gmW - mcCount*mcW)/(mcCount+1);
  layout.mcs = [];
  for (var mi = 0; mi < mcCount; mi++) {
    layout.mcs.push({ x:layout.globalMem.x+mcGap2+mi*(mcW+mcGap2), y:gmY+24, w:mcW, h:14 });
  }

  var hbmY = gmY+gmH+(mob ? 16 : 22);
  var hbmW = gmW*0.88;
  layout.hbm = { x:cx-hbmW/2, y:hbmY, w:hbmW, h:mob ? 34 : 42, label:ARCHS[currentArch].blocks.hbm.label };

  buildHitRects();
  initCacheState();
}

function bezierPoint(p0, cp1, cp2, p1, t) {
  var mt = 1 - t;
  return {
    x: mt*mt*mt*p0.x + 3*mt*mt*t*cp1.x + 3*mt*t*t*cp2.x + t*t*t*p1.x,
    y: mt*mt*mt*p0.y + 3*mt*mt*t*cp1.y + 3*mt*t*t*cp2.y + t*t*t*p1.y,
  };
}

function drawConnLines(time) {
  if (connLines.length === 0) return;
  connLineAnim += 0.022;
  for (var i = 0; i < connLines.length; i++) {
    var cl = connLines[i];
    var dx = cl.to.x - cl.from.x;
    var dy = cl.to.y - cl.from.y;
    var dist = Math.sqrt(dx*dx + dy*dy);

    // Build smooth bezier control points
    // For vertical-dominant paths: slight horizontal bow; for horizontal: slight vertical bow
    var isVertical = Math.abs(dy) > Math.abs(dx);
    var bow = Math.min(dist * 0.35, 60) * (i % 2 === 0 ? 1 : -1);
    var cp1, cp2;
    if (isVertical) {
      cp1 = { x: cl.from.x + bow, y: cl.from.y + dy * 0.3 };
      cp2 = { x: cl.to.x + bow,   y: cl.to.y   - dy * 0.3 };
    } else {
      cp1 = { x: cl.from.x + dx * 0.3, y: cl.from.y + bow };
      cp2 = { x: cl.to.x   - dx * 0.3, y: cl.to.y   + bow };
    }

    var alpha = 0.55 + Math.sin(connLineAnim * 2.5 + i * 1.2) * 0.2;
    var colorHex = cl.color + Math.round(alpha * 255).toString(16).padStart(2,'0');

    ctx.save();
    // Glow pass
    ctx.beginPath();
    ctx.moveTo(cl.from.x, cl.from.y);
    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, cl.to.x, cl.to.y);
    ctx.strokeStyle = cl.color + '18';
    ctx.lineWidth = 7;
    ctx.setLineDash([]);
    ctx.stroke();

    // Main dashed line
    ctx.beginPath();
    ctx.moveTo(cl.from.x, cl.from.y);
    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, cl.to.x, cl.to.y);
    ctx.strokeStyle = colorHex;
    ctx.lineWidth = 1.8;
    ctx.setLineDash([7, 5]);
    ctx.lineDashOffset = -connLineAnim * 28;
    ctx.stroke();
    ctx.setLineDash([]);

    // Source dot
    ctx.beginPath(); ctx.arc(cl.from.x, cl.from.y, 3.5, 0, Math.PI*2);
    ctx.fillStyle = cl.color; ctx.fill();
    ctx.beginPath(); ctx.arc(cl.from.x, cl.from.y, 6, 0, Math.PI*2);
    ctx.fillStyle = cl.color + '30'; ctx.fill();

    // Arrowhead at destination ‚Äî compute bezier tangent at t=0.97
    var tip  = bezierPoint({x:cl.from.x,y:cl.from.y}, cp1, cp2, {x:cl.to.x,y:cl.to.y}, 0.98);
    var tang = bezierPoint({x:cl.from.x,y:cl.from.y}, cp1, cp2, {x:cl.to.x,y:cl.to.y}, 0.93);
    var angle = Math.atan2(cl.to.y - tang.y, cl.to.x - tang.x);
    ctx.translate(cl.to.x, cl.to.y);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-9, -4.5);
    ctx.lineTo(-9, 4.5);
    ctx.closePath();
    ctx.fillStyle = cl.color + 'dd';
    ctx.fill();

    // Traveling dot along bezier
    var travelT = (connLineAnim * 0.55 + i * 0.28) % 1.0;
    ctx.restore();
    var tp = bezierPoint({x:cl.from.x,y:cl.from.y}, cp1, cp2, {x:cl.to.x,y:cl.to.y}, travelT);
    ctx.beginPath(); ctx.arc(tp.x, tp.y, 4, 0, Math.PI*2);
    ctx.fillStyle = cl.color; ctx.fill();
    ctx.beginPath(); ctx.arc(tp.x, tp.y, 8, 0, Math.PI*2);
    ctx.fillStyle = cl.color + '28'; ctx.fill();
  }
}

function drawHoverHighlight() {
  if (!hoveredBlock) return;
  var r = hoveredBlock;
  ctx.save();
  rrect(r.x-3, r.y-3, r.w+6, r.h+6, 6);
  var info = BLOCK_INFO[r.type];
  var hcolor = info ? info.color : '#ffffff';
  ctx.strokeStyle = hcolor + 'cc';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.fillStyle = hcolor + '10';
  ctx.fill();
  ctx.restore();
}

function drawSelectionHighlight() {
  if (!selectedBlock) return;
  var r = selectedBlock;
  ctx.save();
  rrect(r.x-4, r.y-4, r.w+8, r.h+8, 7);
  var info = BLOCK_INFO[r.type];
  var scolor = info ? info.color : '#ffffff';
  var pulse = 0.6 + Math.sin(Date.now()/300) * 0.4;
  ctx.strokeStyle = scolor + Math.round(pulse * 255).toString(16).padStart(2,'0');
  ctx.lineWidth = 2.5;
  ctx.stroke();
  ctx.fillStyle = scolor + '15';
  ctx.fill();
  ctx.restore();
}

function drawFrame(time) {
  if (!initialized || !layout.sms) { requestAnimationFrame(drawFrame); return; }
  var dt = Math.min((time - lastTime)/1000, 0.05);
  lastTime = time;
  ctx.clearRect(0, 0, W, H);
  var arch = ARCHS[currentArch];
  var mob = W < 500;
  // fs scales fonts but with a firm minimum so text stays legible at small widths
  var fs = mob ? 0.88 : 1;
  // Minimum font sizes (px) for key labels
  var FONT_SM_LABEL  = Math.max(10, 10*fs);
  var FONT_SM_WARP   = Math.max(7,  7*fs);
  var FONT_BLOCK_LG  = Math.max(8,  8*fs);   // L1 label with state
  var FONT_BLOCK_SM  = Math.max(7.5, 7.5*fs); // Other sub-block labels
  var FONT_BLOCK_XS  = Math.max(7,  7*fs);    // cp.async etc
  var FONT_L2        = Math.max(11, 11*fs);
  var FONT_LABEL_MED = Math.max(10, 10*fs);
  var FONT_LABEL_SM  = Math.max(7,  7*fs);
  var FONT_HBM       = Math.max(11, 11*fs);

  if (layout.cluster) {
    var c = layout.cluster;
    ctx.setLineDash([4,4]);
    rrect(c.x1, c.y1, c.x2-c.x1, c.y2-c.y1, 10);
    ctx.strokeStyle = arch.color+'40'; ctx.lineWidth=1.5; ctx.stroke();
    ctx.setLineDash([]);
    ctx.font='bold '+Math.max(8,8*fs)+'px "JetBrains Mono"';
    ctx.fillStyle=arch.color+'90'; ctx.textAlign='center';
    ctx.fillText('THREAD BLOCK CLUSTER', (c.x1+c.x2)/2, c.y1-2);
  }

  for (var si = 0; si < layout.sms.length; si++) {
    var sm = layout.sms[si];
    rrect(sm.x, sm.y, sm.w, sm.h, 7);
    ctx.fillStyle='#0f1118'; ctx.fill();
    ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1; ctx.stroke();
    ctx.font='700 '+FONT_SM_LABEL+'px "Outfit"';
    ctx.fillStyle='#e8eaf6'; ctx.textAlign='center';
    ctx.fillText(sm.label, sm.x+sm.w/2, sm.y+14*fs);
    ctx.font='400 '+FONT_SM_WARP+'px "JetBrains Mono"';
    ctx.fillStyle='#8890b0';
    ctx.fillText('Warps ‚ñ∏‚ñ∏‚ñ∏', sm.x+sm.w/2, sm.y+24*fs);

    for (var bi = 0; bi < sm.sub.length; bi++) {
      var b = sm.sub[bi];
      if (b.type === 'regs') {
        var barC = Math.max(4, Math.floor(b.w/10));
        for (var rj = 0; rj < barC; rj++) {
          ctx.fillStyle='hsl(220,30%,'+(19+Math.sin(Date.now()/800+rj+si)*3)+'%)';
          ctx.fillRect(b.x+rj*(b.w/barC), b.y, b.w/barC-1.5, b.h);
        }
        continue;
      }
      rrect(b.x, b.y, b.w, b.h, 3);
      if (b.type === 'l1' && b.state) {
        var stColors = { modified:'#51cf66', shared:'#339af0', invalid:'#6b7090' };
        var sc = stColors[b.state]||'#6b7090';
        // For invalid, use a slightly lighter fill so text pops
        ctx.fillStyle = b.state === 'invalid' ? '#6b709018' : sc+'22'; ctx.fill();
        ctx.strokeStyle = b.state === 'invalid' ? '#5a5e78' : sc; ctx.lineWidth=1.5; ctx.stroke();

        // ‚îÄ‚îÄ Cache line grid ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        var csm2 = cacheState[si];
        if (csm2) {
          var lines2 = csm2.l1;
          var gx = b.x + 4, gw = b.w - 8;
          var slotW = gw / NUM_LINES;
          var gy = b.y + b.h - 6;
          for (var li = 0; li < NUM_LINES; li++) {
            var lv = lines2[li];
            var lc = lv === 2 ? '#51cf66' : (lv === 1 ? (b.state==='shared'?'#339af0':'#51cf6688') : '#2a2d3a');
            ctx.fillStyle = lc;
            ctx.fillRect(gx + li*slotW + 0.5, gy, slotW - 1, 4);
          }
        }
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        ctx.font='600 '+FONT_BLOCK_LG+'px "JetBrains Mono"';
        ctx.fillStyle = b.state === 'invalid' ? '#9095b0' : sc;
        ctx.textAlign='center';
        ctx.fillText(b.label+' ['+b.state.charAt(0).toUpperCase()+']', b.x+b.w/2, b.y+b.h/2+1);
      } else {
        var cBg, cBr, cLbl;
        if (b.type==='texCache')             { cBg='#e599f712'; cBr='#e599f760'; cLbl='#e599f7'; }
        else if (b.type==='tma')             { cBg='#22d3ee12'; cBr='#22d3ee70'; cLbl='#22d3ee'; }
        else if (b.type==='dsmem')           { cBg='#22d3ee10'; cBr='#22d3ee60'; cLbl='#22d3ee'; }
        else if (b.type==='async')           { cBg='#22d3ee0a'; cBr='#22d3ee45'; cLbl='#6de8f0'; }
        else /* smem */                      { cBg='#51cf660a'; cBr='#51cf6660'; cLbl='#6ee09a'; }
        ctx.fillStyle=cBg; ctx.fill();
        ctx.strokeStyle=cBr; ctx.lineWidth=1; ctx.stroke();

        // ‚îÄ‚îÄ SMEM line grid ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (b.type === 'smem') {
          var csm3 = cacheState[si];
          if (csm3) {
            var slines = csm3.smem;
            var sgx = b.x + 4, sgw = b.w - 8;
            var sslotW = sgw / NUM_LINES;
            var sgy = b.y + b.h - 5;
            for (var sli2 = 0; sli2 < NUM_LINES; sli2++) {
              ctx.fillStyle = slines[sli2] === 1 ? '#51cf6680' : '#1e2030';
              ctx.fillRect(sgx + sli2*sslotW + 0.5, sgy, sslotW - 1, 3);
            }
          }
        }
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        var lblFs = (b.type==='async') ? FONT_BLOCK_XS : FONT_BLOCK_SM;
        ctx.font='600 '+lblFs+'px "JetBrains Mono"';
        ctx.fillStyle=cLbl; ctx.textAlign='center';
        ctx.fillText(b.label, b.x+b.w/2, b.y+b.h/2+1);
      }
    }
  }

  // Hover / selection overlays
  drawHoverHighlight();
  drawSelectionHighlight();

  // Connection lines (drawn before particles, after blocks)
  drawConnLines(time);

  for (var ci = 0; ci < layout.sms.length; ci++) {
    var csm = layout.sms[ci];
    ctx.beginPath(); ctx.moveTo(csm.x+csm.w/2, csm.y+csm.h);
    ctx.lineTo(csm.x+csm.w/2, layout.bus.y);
    ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1; ctx.stroke();
  }

  if (currentArch==='hopper' && layout.sms.length>1) {
    var dsPulse = Math.sin(Date.now()/500)*0.3+0.5;
    for (var di = 0; di < layout.sms.length-1; di++) {
      var dsA=null, dsB=null;
      for (var ds1=0;ds1<layout.sms[di].sub.length;ds1++) { if(layout.sms[di].sub[ds1].type==='dsmem') dsA=layout.sms[di].sub[ds1]; }
      for (var ds2=0;ds2<layout.sms[di+1].sub.length;ds2++) { if(layout.sms[di+1].sub[ds2].type==='dsmem') dsB=layout.sms[di+1].sub[ds2]; }
      if (dsA&&dsB) {
        ctx.beginPath(); ctx.moveTo(dsA.x+dsA.w, dsA.y+dsA.h/2);
        ctx.lineTo(dsB.x, dsB.y+dsB.h/2);
        ctx.strokeStyle='rgba(34,211,238,'+(dsPulse*0.5)+')';
        ctx.lineWidth=1.5; ctx.setLineDash([3,3]); ctx.stroke(); ctx.setLineDash([]);
      }
    }
  }

  var bus = layout.bus;
  var busPulse = Math.sin(Date.now()/400)*0.3+0.5;
  ctx.setLineDash([5,3]);
  ctx.beginPath(); ctx.moveTo(bus.x1, bus.y); ctx.lineTo(bus.x2, bus.y);
  ctx.strokeStyle='#f0659550'; ctx.lineWidth=2; ctx.stroke(); ctx.setLineDash([]);
  ctx.beginPath(); ctx.moveTo(bus.x1, bus.y); ctx.lineTo(bus.x2, bus.y);
  ctx.strokeStyle='rgba(240,101,149,'+(busPulse*0.15)+')'; ctx.lineWidth=8; ctx.stroke();
  ctx.font='600 '+Math.max(8,8*fs)+'px "JetBrains Mono"';
  ctx.fillStyle='#f06595e0'; ctx.textAlign='center';
  ctx.fillText(bus.label, (bus.x1+bus.x2)/2, bus.y-9);

  ctx.beginPath(); ctx.moveTo(W/2, bus.y); ctx.lineTo(W/2, layout.l2.y);
  ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1.5; ctx.stroke();

  var l2 = layout.l2;
  rrect(l2.x, l2.y, l2.w, l2.h, 7);
  ctx.fillStyle='#1a1408'; ctx.fill();
  ctx.strokeStyle='#ffa94d60'; ctx.lineWidth=1.5; ctx.stroke();
  ctx.font='700 '+Math.max(11,11*fs)+'px "Outfit"';
  ctx.fillStyle='#ffb55a'; ctx.textAlign='center';
  ctx.fillText(arch.blocks.l2.label, l2.x+l2.w/2, l2.y+18*fs);
  var slices = mob ? 8 : 12;
  var slW = (l2.w-20)/slices;
  for (var sli=0;sli<slices;sli++) {
    ctx.fillStyle='hsl(32,40%,'+(15+Math.sin(Date.now()/600+sli*.5)*5)+'%)';
    ctx.fillRect(l2.x+10+sli*slW, l2.y+24*fs, slW-2, 10*fs);
  }

  if (layout.l2Persist) {
    var p = layout.l2Persist;
    rrect(p.x,p.y,p.w,p.h,2);
    var grad = ctx.createLinearGradient(p.x,0,p.x+p.w,0);
    grad.addColorStop(0,'#ffa94d35'); grad.addColorStop(0.6,'#ffa94d18'); grad.addColorStop(1,'#ffa94d05');
    ctx.fillStyle=grad; ctx.fill();
    ctx.strokeStyle='#ffa94d35'; ctx.lineWidth=.5; ctx.stroke();
    ctx.font='600 '+Math.max(6,6*fs)+'px "JetBrains Mono"';
    ctx.fillStyle='#ffa94da0'; ctx.textAlign='center';
    ctx.fillText('PERSIST WINDOW', p.x+p.w/2, p.y+p.h/2+2);
  }

  ctx.beginPath(); ctx.moveTo(W/2,l2.y+l2.h); ctx.lineTo(W/2,layout.crossbar.y);
  ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1.5; ctx.stroke();

  var cb = layout.crossbar;
  ctx.setLineDash([3,3]);
  ctx.beginPath(); ctx.moveTo(cb.x1,cb.y); ctx.lineTo(cb.x2,cb.y);
  ctx.strokeStyle='#339af038'; ctx.lineWidth=1.5; ctx.stroke(); ctx.setLineDash([]);
  ctx.font='600 '+Math.max(7.5,7.5*fs)+'px "JetBrains Mono"';
  ctx.fillStyle='#339af0c0'; ctx.textAlign='center';
  ctx.fillText('MEMORY CROSSBAR / NoC', (cb.x1+cb.x2)/2, cb.y-6);

  ctx.beginPath(); ctx.moveTo(W/2,cb.y); ctx.lineTo(W/2,layout.globalMem.y);
  ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1.5; ctx.stroke();

  var gm = layout.globalMem;
  rrect(gm.x,gm.y,gm.w,gm.h,7);
  ctx.fillStyle='#0d1320'; ctx.fill();
  ctx.strokeStyle='#339af050'; ctx.lineWidth=1.5; ctx.stroke();
  // Title ‚Äî top of box, clear of MCs
  ctx.font='700 '+Math.max(10,10*fs)+'px "Outfit"';
  ctx.fillStyle='#5ab0f8'; ctx.textAlign='center';
  ctx.fillText('Global Memory Interface', gm.x+gm.w/2, gm.y+14);
  // MC blocks ‚Äî pushed to middle row (y+26 set in layout)
  for (var mci=0;mci<layout.mcs.length;mci++) {
    var mc=layout.mcs[mci];
    ctx.fillStyle='hsl(210,50%,'+(14+Math.sin(Date.now()/500+mci)*3)+'%)';
    ctx.fillRect(mc.x,mc.y,mc.w,mc.h);
    ctx.font='600 '+Math.max(6.5,6.5*fs)+'px "JetBrains Mono"';
    ctx.fillStyle='#339af090'; ctx.textAlign='center';
    ctx.fillText('MC'+mci, mc.x+mc.w/2, mc.y+mc.h/2+2.5);
  }
  // Footer label ‚Äî bottom of box
  ctx.font='500 '+Math.max(6.5,6.5*fs)+'px "JetBrains Mono"';
  ctx.fillStyle='#8890a8'; ctx.textAlign='center';
  ctx.fillText('MC ‚Üí '+arch.blocks.hbm.label, gm.x+gm.w/2, gm.y+gm.h-5);

  ctx.beginPath(); ctx.moveTo(W/2,gm.y+gm.h); ctx.lineTo(W/2,layout.hbm.y);
  ctx.strokeStyle='#2a2d3a'; ctx.lineWidth=1.5; ctx.stroke();

  var hbm = layout.hbm;
  rrect(hbm.x,hbm.y,hbm.w,hbm.h,7);
  ctx.fillStyle='#0d0a18'; ctx.fill();
  ctx.strokeStyle='#845ef740'; ctx.lineWidth=1.5; ctx.stroke();
  ctx.font='700 '+Math.max(11,11*fs)+'px "Outfit"';
  ctx.fillStyle='#a07af8'; ctx.textAlign='center';
  ctx.fillText(hbm.label, hbm.x+hbm.w/2, hbm.y+16*fs);
  var hbmStacks = mob ? 4 : 6;
  var hstW = (hbm.w-30)/hbmStacks;
  for (var hi=0;hi<hbmStacks;hi++) {
    for (var hl=0;hl<3;hl++) {
      ctx.fillStyle='hsl(260,40%,'+(12+hl*3+Math.sin(Date.now()/700+hi+hl)*2)+'%)';
      ctx.fillRect(hbm.x+15+hi*hstW, hbm.y+22*fs+hl*3.5, hstW-4, 3);
    }
  }

  flashEffects = flashEffects.filter(function(f) {
    f.t+=0.02;
    if (f.t>=f.dur) return false;
    rrect(f.x-2,f.y-2,f.w+4,f.h+4,5);
    ctx.strokeStyle=f.c+Math.round((1-f.t/f.dur)*0.3*255).toString(16).padStart(2,'0');
    ctx.lineWidth=2; ctx.stroke();
    return true;
  });

  bubbles = bubbles.filter(function(b) {
    b.age+=dt;
    if (b.age>b.life) return false;
    var progress=b.age/b.life;
    var fadeIn=Math.min(b.age/0.15,1);
    var fadeOut=progress>0.7?1-(progress-0.7)/0.3:1;
    var alpha=fadeIn*fadeOut;
    var bx=b.x+Math.sin(b.age*1.5+b.wobble)*3;
    var by=b.y-b.age*b.rise;
    var scale=0.8+fadeIn*0.2;

    // ‚îÄ‚îÄ Hover boost: if this bubble is over the currently hovered block, make it bigger ‚îÄ‚îÄ
    var isHovered = false;
    if (hoveredBlock) {
      var hr = hoveredBlock;
      // Check if bubble origin is inside or close to the hovered block
      if (b.x >= hr.x - 10 && b.x <= hr.x + hr.w + 10 &&
          b.y >= hr.y - 20 && b.y <= hr.y + hr.h + 20) {
        isHovered = true;
      }
    }
    var boostScale = isHovered ? 1.45 : 1.0;
    var boostAlpha = isHovered ? Math.min(alpha * 1.25, 1) : alpha;
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    ctx.save();
    ctx.globalAlpha=boostAlpha;

    // Measure both lines
    var fs2 = Math.max(8, 8*scale*boostScale);
    var subFs = Math.max(6.5, 6.5*scale*boostScale);
    ctx.font='700 '+fs2+'px "JetBrains Mono"';
    var tw = ctx.measureText(b.text).width + 14;
    var subTw = 0;
    if (b.sub) {
      ctx.font='500 '+subFs+'px "JetBrains Mono"';
      subTw = ctx.measureText(b.sub).width + 14;
    }
    var boxW = Math.max(tw, subTw);
    var lineH = fs2 + 3;
    var bh = b.sub ? (lineH + subFs + 7) : (lineH + 4);

    rrect(bx-boxW/2, by-bh/2-1, boxW, bh, 5);
    // Boosted background and border when hovered
    ctx.fillStyle = isHovered ? b.color + '28' : b.bg; ctx.fill();
    ctx.strokeStyle = isHovered ? b.color + 'cc' : b.color + '70';
    ctx.lineWidth = isHovered ? 1.8 : 1; ctx.stroke();

    // Extra outer glow ring when hovered
    if (isHovered) {
      rrect(bx-boxW/2-3, by-bh/2-4, boxW+6, bh+6, 7);
      ctx.strokeStyle = b.color + '30';
      ctx.lineWidth = 4; ctx.stroke();
    }

    // Pointer tail
    if (progress<0.35) {
      ctx.beginPath();
      ctx.moveTo(bx-3, by+bh/2-1);
      ctx.lineTo(bx, by+bh/2+5);
      ctx.lineTo(bx+3, by+bh/2-1);
      ctx.closePath(); ctx.fillStyle = isHovered ? b.color + '28' : b.bg; ctx.fill();
    }

    // Main label
    ctx.font='700 '+fs2+'px "JetBrains Mono"';
    ctx.fillStyle=b.color;
    ctx.textAlign='center';
    var textY = b.sub ? (by - bh/2 + fs2 + 3) : (by + fs2/2 - 1);
    ctx.fillText(b.text, bx, textY);

    // Subtitle
    if (b.sub) {
      ctx.font='500 '+subFs+'px "JetBrains Mono"';
      ctx.fillStyle = isHovered ? b.color + 'cc' : b.color + '99';
      ctx.fillText(b.sub, bx, textY + subFs + 2);
    }
    ctx.restore();
    return true;
  });

  particles.forEach(function(p) { p.update(dt); p.draw(ctx); });
  particles = particles.filter(function(p) { return p.alive; });

  // Rebuild particle label hit zones for mouse hover
  buildParticleLabelRects();

  // ‚îÄ‚îÄ Live tooltip refresh for cache blocks ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (hoveredBlock && (hoveredBlock.type === 'l1' || hoveredBlock.type === 'smem')) {
    refreshTooltipCacheData(hoveredBlock, BLOCK_INFO[hoveredBlock.type]);
  }
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  if (autoMode) {
    autoTimer+=dt;
    if (autoTimer>2.8) {
      autoTimer=0;
      var ops=['read','write','invalidate','writeback','shared'];
      triggerScenario(ops[Math.floor(Math.random()*ops.length)]);
    }
  }
  requestAnimationFrame(drawFrame);
}
var lastTime=0;
// animation loop started after init below

function Particle(from, to, color, label, speed, onDone) {
  this.from={x:from.x,y:from.y}; this.to={x:to.x,y:to.y}; this.color=color; this.label=label||'';
  this.t=0; this.speed=speed||2; this.alive=true; this.onDone=onDone;
  this.dist=Math.sqrt((to.x-from.x)*(to.x-from.x)+(to.y-from.y)*(to.y-from.y)); this.trail=[];
}
Particle.prototype.update = function(dt) {
  this.t+=(this.speed*dt*60)/Math.max(this.dist,1);
  if (this.t>=1) { this.t=1; this.alive=false; if (this.onDone) this.onDone(); }
  var cx=this.from.x+(this.to.x-this.from.x)*this.t;
  var cy=this.from.y+(this.to.y-this.from.y)*this.t;
  this.trail.push({x:cx,y:cy}); if (this.trail.length>16) this.trail.shift();
};
Particle.prototype.draw = function(ctx) {
  for (var i=0;i<this.trail.length;i++) {
    var p=this.trail[i], a=(1-i/this.trail.length)*0.5, r=2.5-i/this.trail.length*1.5;
    ctx.beginPath(); ctx.arc(p.x,p.y,Math.max(r,.5),0,Math.PI*2);
    ctx.fillStyle=this.color+Math.round(a*255).toString(16).padStart(2,'0'); ctx.fill();
  }
  var cx=this.from.x+(this.to.x-this.from.x)*this.t;
  var cy=this.from.y+(this.to.y-this.from.y)*this.t;
  ctx.beginPath(); ctx.arc(cx,cy,4,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill();
  ctx.beginPath(); ctx.arc(cx,cy,7,0,Math.PI*2); ctx.fillStyle=this.color+'28'; ctx.fill();
  if (this.label) {
    var hasInfo = !!INSTRUCTION_INFO[this.label];
    var lFont = (hasInfo ? '700' : '500') + ' 9px "JetBrains Mono"';
    ctx.font = lFont;
    var lw = ctx.measureText(this.label).width;
    var lx = cx, ly = cy - 12;

    if (hasInfo) {
      // Draw pill background so label is obviously hoverable
      var pw = lw + 10, ph = 13;
      rrect(lx - pw/2, ly - ph + 3, pw, ph, 3);
      ctx.fillStyle = this.color + '28'; ctx.fill();
      ctx.strokeStyle = this.color + '70'; ctx.lineWidth = 0.8; ctx.stroke();
    }

    ctx.font = lFont;
    ctx.fillStyle = this.color;
    ctx.textAlign = 'center';
    ctx.fillText(this.label, lx, ly);
  }
};

function l1Pos(i) { var l1=layout.sms[i].l1; return {x:l1.x+l1.w/2,y:l1.y+l1.h/2}; }
function busP(i) { var s=layout.sms[i]; return {x:s.x+s.w/2,y:layout.bus.y}; }
function l2Top() { return {x:layout.l2.x+layout.l2.w/2,y:layout.l2.y}; }
function l2Bot() { return {x:layout.l2.x+layout.l2.w/2,y:layout.l2.y+layout.l2.h}; }
function cbP() { return {x:W/2,y:layout.crossbar.y}; }
function gmTop() { return {x:layout.globalMem.x+layout.globalMem.w/2,y:layout.globalMem.y}; }
function gmBot() { return {x:layout.globalMem.x+layout.globalMem.w/2,y:layout.globalMem.y+layout.globalMem.h}; }
function hbmTop() { return {x:layout.hbm.x+layout.hbm.w/2,y:layout.hbm.y}; }
function flash(b,c) { flashEffects.push({x:b.x,y:b.y,w:b.w,h:b.h,c:c,t:0,dur:.5}); }

function getExplanation(type) {
  var arch = currentArch;
  var e = {
    read:{ title:'L1 Read Miss ‚Üí L2 Fetch', color:'#ff6b6b',
      steps:[
        {text:'<strong>Warp issues load</strong> ‚Äî global memory read.', micro:'LD.E Rx, [addr]', delay:0},
        {text:'<strong>L1 tag lookup: MISS</strong>', micro:'Tag compare ‚Üí miss', delay:700},
        {text:'<strong>Request to L2</strong>', micro:'RdReq ‚Üí Bus ‚Üí L2', delay:1500},
        {text:'<strong>L2 hit</strong> ‚Äî data read from L2.', micro:'L2 '+ARCHS[arch].blocks.l2.size+' slice lookup', delay:2500},
        {text:'<strong>Data returns</strong> ‚Äî cache line fills L1.', micro:'DATA ‚Üí SM L1 fill', delay:3300},
        {text:'<strong>L1 ‚Üí Shared</strong>', micro:'State: Invalid ‚Üí Shared', delay:4000},
      ], summary: arch==='pascal' ? 'Pascal L1 is read-only for globals.' : 'Standard read miss path.'
    },
    write:{ title: arch==='pascal' ? 'SM Write ‚Üí Direct to L2' : 'SM Write ‚Üí Invalidate Others', color:'#51cf66',
      steps: arch==='pascal' ? [
        {text:'<strong>Warp issues store</strong>', micro:'ST.E [addr], Rx', delay:0},
        {text:'<strong>L1 bypassed</strong> ‚Äî write goes directly to L2.', micro:'Write-through: skip L1', delay:500},
        {text:'<strong>L2 absorbs write</strong>', micro:'L2 SRAM write', delay:1200},
        {text:'<strong>No invalidation needed</strong>', micro:'No INV broadcast', delay:1800},
      ] : [
        {text:'<strong>Warp issues store</strong>', micro:'ST.E [addr], Rx', delay:0},
        {text:'<strong>L1 ‚Üí Modified</strong> ‚Äî write-evict policy.', micro:'Write-evict: L1 drop + L2 write', delay:500},
        {text:'<strong>Invalidation broadcast</strong>', micro:'INV ‚Üí all SMs via bus', delay:1200},
        {text:'<strong>Remote L1s invalidated</strong>', micro:'Other SMs: * ‚Üí Invalid', delay:2000},
        {text:'<strong>Coherency restored</strong>', micro:'Single-writer invariant', delay:2800},
      ], summary: arch==='pascal' ? 'Pascal: L1 read-only, writes go to L2.' : 'Write-evict: L1 line dropped, L2 gets the write.'
    },
    invalidate:{ title:'Broadcast Invalidation', color:'#f06595',
      steps:[
        {text:'<strong>Coherency event</strong>', micro:'SM write or host DMA', delay:0},
        {text:'<strong>Bus broadcasts INV</strong>', micro:'INV(addr) ‚Üí all SMs', delay:600},
        {text:'<strong>L1 tags probed</strong>', micro:'Parallel tag lookup', delay:1200},
        {text:'<strong>All copies dropped</strong>', micro:'All: * ‚Üí Invalid', delay:2200},
      ], summary:'Broadcast invalidation scales linearly with SM count.'
    },
    writeback:{ title:'Write-Back ‚Üí L2 ‚Üí '+ARCHS[currentArch].blocks.hbm.label, color:'#ffa94d',
      steps:[
        {text:'<strong>L1 eviction</strong> ‚Äî dirty line needs to leave L1.', micro:'Capacity eviction or flush', delay:0},
        {text:'<strong>Data ‚Üí L2</strong>', micro:'WB+DATA ‚Üí L2 slice', delay:800},
        {text:'<strong>L2 absorbs</strong>', micro:'L2 write', delay:1800},
        {text:'<strong>L2 eviction</strong> ‚Äî if full, victim evicted to DRAM.', micro:'LRU victim ‚Üí NoC ‚Üí MC', delay:3000},
        {text:'<strong>'+ARCHS[arch].blocks.hbm.label+' write</strong>', micro:'MC ‚Üí bank write', delay:4000},
        {text:'<strong>Stored in '+ARCHS[arch].blocks.hbm.label+'</strong>', micro:'~400+ cycles total', delay:4800},
      ], summary:'Full eviction cascade: L1‚ÜíL2‚ÜíMC‚ÜíDRAM.'
    },
    shared:{ title: currentArch==='hopper' ? 'Shared Mem + DSMEM' : 'Shared Memory Access', color:'#51cf66',
      steps: currentArch==='hopper' ? [
        {text:'<strong>Thread accesses __shared__</strong>', micro:'LDS Rx, [smem_addr]', delay:0},
        {text:'<strong>Direct SRAM access</strong> ‚Äî no coherency. 32 banks.', micro:'~20 cycles', delay:500},
        {text:'<strong>DSMEM option</strong> ‚Äî access other SMs\' shared memory.', micro:'dst_sm.smem[addr]', delay:1200},
        {text:'<strong>Cluster-local</strong> ‚Äî DSMEM at SMEM latency.', micro:'~20 cycles cross-SM', delay:1800},
      ] : [
        {text:'<strong>Thread accesses __shared__</strong>', micro:'LDS Rx, [smem_addr]', delay:0},
        {text:'<strong>Direct SRAM access</strong> ‚Äî no coherency.', micro:'~20 cycles, 32 banks', delay:500},
        {text:'<strong>Bank conflict check</strong>', micro:'Best: 1 cycle. Worst: 32-way', delay:1100},
        {text:'<strong>SM-local only</strong> ‚Äî no bus traffic.', micro:'Scope: CTA local', delay:1600},
      ], summary: currentArch==='hopper' ? 'DSMEM enables cross-SM shared memory within a cluster.' : 'Shared memory sidesteps coherency by being SM-private.'
    }
  };
  return e[type];
}

function showExplanation(type) {
  var exp = getExplanation(type); if (!exp) return;
  stepTimers.forEach(function(t){clearTimeout(t);}); stepTimers=[];
  var titleEl=document.getElementById('explainer-title');
  titleEl.innerHTML='<span class="dot" style="background:'+exp.color+'"></span> '+exp.title;
  titleEl.style.color=exp.color;
  var listEl=document.getElementById('step-list'); listEl.innerHTML='';
  var sumEl=document.getElementById('explainer-summary'); sumEl.textContent=''; sumEl.classList.remove('visible');
  exp.steps.forEach(function(s,i) {
    var li=document.createElement('li');
    // Parse micro text to find instruction keywords and make them hoverable
    var microText = s.micro;
    var microHtml = microText.replace(/\b(LD\.E|ST\.E|LDS|STS|ST\.S|RdReq|INV|DATA|WR|WB|EVICT|STORE|DSMEM|cp\.async)\b/g, function(m) {
      return '<span class="micro-instr" data-instr="'+m+'" style="cursor:help;text-decoration:underline dotted;text-decoration-color:rgba(255,255,255,0.3)">'+m+'</span>';
    });
    li.innerHTML='<span class="step-num" style="background:'+exp.color+'20;color:'+exp.color+'">'+(i+1)+'</span><span class="step-text">'+s.text+'<span class="micro">'+microHtml+'</span></span>';
    listEl.appendChild(li);
    stepTimers.push(setTimeout(function() {
      var actives=listEl.querySelectorAll('li.active');
      for(var k=0;k<actives.length;k++){actives[k].classList.remove('active');actives[k].classList.add('past');}
      li.classList.add('visible','active');
    }, s.delay));
  });
  stepTimers.push(setTimeout(function() {
    sumEl.textContent=exp.summary; sumEl.classList.add('visible');
    var actives=listEl.querySelectorAll('li.active');
    for(var k=0;k<actives.length;k++){actives[k].classList.remove('active');actives[k].classList.add('past');}
  }, exp.steps[exp.steps.length-1].delay+1000));
}

function logEvent(msg, color) {
  var log=document.getElementById('event-log');
  var e=document.createElement('div'); e.className='log-entry';
  e.innerHTML='<span class="tag" style="background:'+color+'30;color:'+color+'">'+new Date().toLocaleTimeString().slice(0,8)+'</span> '+msg;
  log.prepend(e); if(log.children.length>40) log.lastChild.remove();
}

function updateStats() {
  document.getElementById('stat-hits').textContent=stats.hits;
  document.getElementById('stat-misses').textContent=stats.misses;
  document.getElementById('stat-inv').textContent=stats.inv;
  document.getElementById('stat-wb').textContent=stats.wb;
}

function triggerScenario(type) {
  var si=Math.floor(Math.random()*layout.sms.length);
  showExplanation(type);
  var sm=layout.sms[si];

  switch(type) {
    case 'read':
      sm.l1.state='invalid'; invalidateL1(si); stats.misses++;
      logEvent('SM'+si+': L1 read miss ‚Üí L2','#ff6b6b');
      bubble(l1Pos(si).x,l1Pos(si).y,'cache miss','#ff6b6b',{sub:'not in L1'});
      particles.push(new Particle(l1Pos(si),busP(si),'#ff6b6b','RdReq',2,function(){
        bubble(busP(si).x,busP(si).y,'going to L2','#ff6b6b',{life:1.4,sub:'fetch from below'});
        particles.push(new Particle(busP(si),l2Top(),'#ff6b6b','RdReq',2.5,function(){
          stats.hits++; logEvent('L2: Hit ‚Üí data returning','#ffa94d');
          bubble(l2Top().x,l2Top().y,'L2 found it','#51cf66',{life:1.5,sub:'data ready'});
          particles.push(new Particle(l2Top(),busP(si),'#ffa94d','DATA',2,function(){
            particles.push(new Particle(busP(si),l1Pos(si),'#ffa94d','DATA',2,function(){
              sm.l1.state='shared'; fillL1Random(si, false); flash(sm.l1,'#339af0');
              bubble(l1Pos(si).x,l1Pos(si).y,'line cached','#339af0',{life:1.6,sub:'now Shared'});
              logEvent('SM'+si+': L1 ‚Üí Shared','#339af0');
            }));
          }));
        }));
      }));
      break;
    case 'write':
      if (currentArch==='pascal') {
        logEvent('SM'+si+': Write ‚Üí L2 (L1 bypassed)','#51cf66');
        stats.hits++;
        bubble(l1Pos(si).x,l1Pos(si).y,'write bypass','#51cf66',{sub:'L1 skipped'});
        particles.push(new Particle(l1Pos(si),busP(si),'#51cf66','WR',2,function(){
          bubble(busP(si).x,busP(si).y,'skip L1','#8890a8',{life:1.2,sub:'straight to L2'});
          particles.push(new Particle(busP(si),l2Top(),'#51cf66','WR',2.5,function(){
            flash(layout.l2,'#ffa94d');
            bubble(l2Top().x,l2Top().y,'L2 updated','#ffa94d',{life:1.5,sub:'write absorbed'});
            logEvent('L2: Write absorbed','#ffa94d');
          }));
        }));
      } else {
        sm.l1.state='modified'; setL1Dirty(si); stats.hits++;
        logEvent('SM'+si+': Write ‚Üí Modified + invalidate','#51cf66');
        flash(sm.l1,'#51cf66');
        bubble(l1Pos(si).x,l1Pos(si).y,'line dirty','#51cf66',{sub:'now Modified'});
        for (var wi=0;wi<layout.sms.length;wi++) {
          if (wi!==si && layout.sms[wi].l1.state!=='invalid') {
            (function(idx){
              setTimeout(function(){
                particles.push(new Particle(busP(si),busP(idx),'#f06595','INV',3,function(){
                  layout.sms[idx].l1.state='invalid'; invalidateL1(idx); stats.inv++;
                  flash(layout.sms[idx].l1,'#f06595');
                  bubble(l1Pos(idx).x,l1Pos(idx).y,'copy stale','#f06595',{life:1.3,sub:'lines cleared'});
                  logEvent('SM'+idx+': Invalidated','#f06595');
                  updateStats();
                }));
              }, idx*150);
            })(wi);
          }
        }
      }
      break;
    case 'invalidate':
      stats.inv++;
      logEvent('Broadcast INV','#f06595');
      bubble((layout.bus.x1+layout.bus.x2)/2,layout.bus.y,'broadcast flush','#f06595',{sub:'all SMs notified'});
      for (var ii=0;ii<layout.sms.length;ii++) {
        (function(idx){
          setTimeout(function(){
            var from={x:(layout.bus.x1+layout.bus.x2)/2,y:layout.bus.y};
            particles.push(new Particle(from,busP(idx),'#f06595','INV',3,function(){
              particles.push(new Particle(busP(idx),l1Pos(idx),'#f06595','INV',2,function(){
                layout.sms[idx].l1.state='invalid'; invalidateL1(idx);
                flash(layout.sms[idx].l1,'#f06595');
                bubble(l1Pos(idx).x,l1Pos(idx).y,'all cleared','#f06595',{life:1.2,sub:'lines dropped'});
              }));
            }));
          }, idx*180);
        })(ii);
      }
      break;
    case 'writeback':
      sm.l1.state='modified'; setL1Dirty(si); stats.wb++;
      logEvent('SM'+si+': Write-back ‚Üí L2','#ffa94d');
      bubble(l1Pos(si).x,l1Pos(si).y,'dirty evict','#ffa94d',{sub:'must flush out'});
      particles.push(new Particle(l1Pos(si),busP(si),'#ffa94d','WB',2,function(){
        particles.push(new Particle(busP(si),l2Top(),'#ffa94d','WB',2.5,function(){
          flash(layout.l2,'#ffa94d'); sm.l1.state='shared'; writebackL1(si);
          bubble(l2Top().x,l2Top().y,'L2 absorbed','#ffa94d',{life:1.4,sub:'dirty ‚Üí L2'});
          logEvent('L2: Write-back received','#ffa94d');
          setTimeout(function(){
            bubble(l2Bot().x,l2Bot().y,'L2 evicting','#339af0',{life:1.3,sub:'victim to DRAM'});
            particles.push(new Particle(l2Bot(),cbP(),'#339af0','EVICT',2,function(){
              particles.push(new Particle(cbP(),gmTop(),'#339af0','WR',2,function(){
                flash(layout.globalMem,'#339af0');
                bubble(gmTop().x,gmTop().y,'queued MC','#339af0',{life:1.2,sub:'scheduling write'});
                particles.push(new Particle(gmBot(),hbmTop(),'#845ef7','STORE',1.5,function(){
                  flash(layout.hbm,'#845ef7');
                  bubble(hbmTop().x,hbmTop().y,'persisted','#845ef7',{life:1.5,sub:'written to DRAM'});
                  logEvent(ARCHS[currentArch].blocks.hbm.label+': Stored','#845ef7');
                }));
              }));
            }));
          },500);
        }));
      }));
      break;
    case 'shared':
      var smemBlock=null;
      for(var sbi=0;sbi<sm.sub.length;sbi++){if(sm.sub[sbi].type==='smem')smemBlock=sm.sub[sbi];}
      if(!smemBlock) break;
      logEvent('SM'+si+': SMEM access','#51cf66');
      flash(smemBlock,'#51cf66'); stats.hits++;
      fillSmem(si);
      bubble(sm.x+sm.w/2,sm.y+14,'no coherency','#51cf66',{sub:'SM-private scratchpad'});
      var regsBlock=null;
      for(var ri=0;ri<sm.sub.length;ri++){if(sm.sub[ri].type==='regs')regsBlock=sm.sub[ri];}
      var sfrom={x:sm.x+sm.w/2,y:regsBlock?regsBlock.y+3:sm.y+40};
      particles.push(new Particle(sfrom,{x:smemBlock.x+smemBlock.w/2,y:smemBlock.y+smemBlock.h/2},'#51cf66','ST.S',1.5,function(){
        bubble(smemBlock.x+smemBlock.w/2,smemBlock.y,'~20 cycles','#51cf66',{life:1.4,sub:'fast SRAM hit'});
      }));
      if (currentArch==='hopper'&&layout.sms.length>1) {
        var other=(si+1)%layout.sms.length;
        var otherDsmem=null, myDsmem=null;
        for(var od=0;od<layout.sms[other].sub.length;od++){if(layout.sms[other].sub[od].type==='dsmem')otherDsmem=layout.sms[other].sub[od];}
        for(var md=0;md<sm.sub.length;md++){if(sm.sub[md].type==='dsmem')myDsmem=sm.sub[md];}
        if(otherDsmem&&myDsmem){
          setTimeout(function(){
            logEvent('SM'+si+' ‚Üí SM'+other+': DSMEM read','#22d3ee');
            bubble(myDsmem.x+myDsmem.w/2,myDsmem.y,'peer read','#22d3ee',{sub:'cross-SM memory'});
            particles.push(new Particle(
              {x:myDsmem.x+myDsmem.w/2,y:myDsmem.y+myDsmem.h/2},
              {x:otherDsmem.x+otherDsmem.w/2,y:otherDsmem.y+otherDsmem.h/2},
              '#22d3ee','DSMEM',2,function(){
                flash(otherDsmem,'#22d3ee');
                bubble(otherDsmem.x+otherDsmem.w/2,otherDsmem.y,'cluster hit','#22d3ee',{life:1.4,sub:'no bus needed'});
              }
            ));
          },800);
        }
      }
      break;
  }
  updateStats();
}

function toggleAuto() {
  autoMode=!autoMode;
  document.getElementById('btn-auto').classList.toggle('active',autoMode);
}

function resetAll(silent) {
  particles=[]; flashEffects=[]; bubbles=[];
  stats={hits:0,misses:0,inv:0,wb:0}; updateStats();
  for(var ri=0;ri<layout.sms.length;ri++){layout.sms[ri].l1.state='invalid';}
  initCacheState();
  document.getElementById('event-log').innerHTML='';
  stepTimers.forEach(function(t){clearTimeout(t);}); stepTimers=[];
  document.getElementById('explainer-title').innerHTML='<span class="dot" style="background:#6b7094"></span> Click a scenario or wait for auto...';
  document.getElementById('explainer-title').style.color='#6b7094';
  document.getElementById('step-list').innerHTML='';
  var s=document.getElementById('explainer-summary'); s.textContent=''; s.classList.remove('visible');
  autoTimer=0;
  if(!silent) logEvent('Reset ‚Äî all caches invalidated','#6b7094');
}

// ‚îÄ‚îÄ Build instruction reference chips ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function buildInstrChips() {
  var container = document.getElementById('instr-chips');
  if (!container) return;
  container.innerHTML = '';
  var keys = Object.keys(INSTRUCTION_INFO);
  keys.forEach(function(key) {
    var info = INSTRUCTION_INFO[key];
    var chip = document.createElement('span');
    chip.className = 'instr-chip';
    chip.textContent = key;
    chip.style.background = info.color + '18';
    chip.style.color = info.color;
    chip.style.borderColor = info.color + '50';
    chip.addEventListener('mouseenter', function(e) {
      showInstrTooltip(key, e.clientX, e.clientY);
    });
    chip.addEventListener('mousemove', function(e) {
      positionInstrTooltip(e.clientX, e.clientY);
    });
    chip.addEventListener('mouseleave', function() {
      hideInstrTooltip();
    });
    container.appendChild(chip);
  });
}

// ‚îÄ‚îÄ Single entry point ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function startApp() {
  resize();
  // If canvas still has no size (e.g. hidden tab), retry next frame
  if (!W || !H) { requestAnimationFrame(startApp); return; }
  buildLayout();
  initialized = true;
  updateKeyCard();
  updateArchIntro();
  buildInstrChips();
  
  lastTime = performance.now();
  requestAnimationFrame(drawFrame);
}
requestAnimationFrame(startApp);

// ‚îÄ‚îÄ Micro-instruction hover in explainer panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
var explainerEl = document.getElementById('step-list');
explainerEl.addEventListener('mousemove', function(e) {
  var target = e.target.closest('.micro-instr');
  if (target) {
    var key = target.getAttribute('data-instr');
    showInstrTooltip(key, e.clientX, e.clientY);
  } else {
    hideInstrTooltip();
  }
});
explainerEl.addEventListener('mouseleave', function() { hideInstrTooltip(); });
</script>
<!-- Instruction tooltip at body level so fixed positioning works correctly -->
<div id="instr-tooltip">
  <div class="it-name"><div class="it-dot" id="it-dot"></div><span id="it-name"></span></div>
  <div class="it-section">
    <div class="it-label">What it does</div>
    <div class="it-text" id="it-what"></div>
  </div>
  <div class="it-why-box">
    <div class="it-label">Why you need this op</div>
    <div class="it-text" id="it-why"></div>
  </div>
</div>

</body>
</html>
