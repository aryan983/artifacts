<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GPU Cache Coherency ‚Äî Architecture Explorer</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Outfit:wght@300;400;600;700;800&display=swap');
:root {
  --bg: #0a0b0f; --surface: #12141a; --surface2: #1a1d26;
  --border: #2a2d3a; --text: #e0e2ec; --dim: #6b7094;
  --l1: #ff6b6b; --l2: #ffa94d; --smem: #51cf66;
  --global: #339af0; --dram: #845ef7; --coherency: #f06595;
  --new-block: #22d3ee; --changed: #facc15;
}
* { margin:0; padding:0; box-sizing:border-box; }
body { background:var(--bg); color:var(--text); font-family:'Outfit',sans-serif; min-height:100vh; overflow-x:hidden; }
.grain { position:fixed; inset:0; pointer-events:none; z-index:999; opacity:.03;
  background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E"); }

header { text-align:center; padding:20px 16px 10px; }
header h1 { font-size:clamp(1.6rem,3.5vw,2.6rem); font-weight:800; letter-spacing:-1px;
background:linear-gradient(135deg,#ff6b6b,#ffa94d,#51cf66,#339af0,#845ef7);
-webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text; }
header p { color:var(‚Äìdim); font-family:‚ÄòJetBrains Mono‚Äô,monospace; font-size:.75rem; margin-top:4px; letter-spacing:2px; text-transform:uppercase; }

/* ‚îÄ‚îÄ Arch tabs ‚îÄ‚îÄ */
.arch-tabs { display:flex; justify-content:center; gap:0; padding:10px 16px 6px; flex-wrap:wrap; }
.arch-tab {
background:var(‚Äìsurface); border:1px solid var(‚Äìborder); color:var(‚Äìdim);
font-family:‚ÄòJetBrains Mono‚Äô,monospace; font-size:.7rem; padding:8px 14px;
cursor:pointer; transition:all .2s; letter-spacing:.3px; position:relative;
border-right:none;
}
.arch-tab:first-child { border-radius:6px 0 0 6px; }
.arch-tab:last-child { border-radius:0 6px 6px 0; border-right:1px solid var(‚Äìborder); }
.arch-tab:hover { color:var(‚Äìtext); background:var(‚Äìsurface2); }
.arch-tab.active { background:var(‚Äìsurface2); color:#fff; border-color:var(‚Äìaccent-color,var(‚Äìglobal)); }
.arch-tab.active::after { content:‚Äô‚Äô; position:absolute; bottom:-1px; left:10%; right:10%; height:2px; background:var(‚Äìaccent-color,var(‚Äìglobal)); border-radius:1px; }
.arch-tab .tab-gen { display:block; font-size:.55rem; color:var(‚Äìdim); margin-top:2px; font-weight:400; }
.arch-tab.active .tab-gen { color:var(‚Äìaccent-color,var(‚Äìglobal)); }

/* ‚îÄ‚îÄ Diff banner ‚îÄ‚îÄ */
.diff-banner {
max-width:900px; margin:6px auto 0; padding:8px 14px;
background:var(‚Äìsurface); border:1px solid var(‚Äìborder); border-radius:8px;
font-size:.75rem; line-height:1.5; display:none; text-align:center;
}
.diff-banner.visible { display:block; }
.diff-banner .new-tag { color:var(‚Äìnew-block); font-weight:600; }
.diff-banner .changed-tag { color:var(‚Äìchanged); font-weight:600; }
.diff-banner .removed-tag { color:#ff6b6b; font-weight:600; text-decoration:line-through; }

/* ‚îÄ‚îÄ Controls ‚îÄ‚îÄ */
.controls { display:flex; justify-content:center; gap:8px; padding:8px 16px; flex-wrap:wrap; }
.controls button {
background:var(‚Äìsurface2); border:1px solid var(‚Äìborder); color:var(‚Äìtext);
font-family:‚ÄòJetBrains Mono‚Äô,monospace; font-size:.68rem; padding:6px 11px;
border-radius:6px; cursor:pointer; transition:all .2s; letter-spacing:.4px;
}
.controls button:hover { border-color:var(‚Äìcoherency); color:#fff; }
.controls button.active { background:var(‚Äìcoherency); border-color:var(‚Äìcoherency); color:#fff; }
.controls button.reset-btn { background:transparent; border-color:#ff6b6b50; color:#ff6b6b; }
.controls button.reset-btn:hover { background:#ff6b6b20; border-color:#ff6b6b; }

/* ‚îÄ‚îÄ Layout ‚îÄ‚îÄ */
.main-container { display:flex; gap:20px; padding:12px 16px; max-width:1600px; margin:0 auto; align-items:flex-start; }
.viz-area { flex:1; min-width:0; }
canvas { width:100%; height:620px; background:var(‚Äìsurface); border-radius:12px; border:1px solid var(‚Äìborder); display:block; }
@media(max-width:500px){ canvas { height:500px; } }

.info-panel { width:340px; flex-shrink:0; display:flex; flex-direction:column; gap:12px; }
.info-card { background:var(‚Äìsurface); border:1px solid var(‚Äìborder); border-radius:10px; padding:14px; }
.info-card h3 { font-size:.65rem; font-family:‚ÄòJetBrains Mono‚Äô,monospace; text-transform:uppercase; letter-spacing:2px; color:var(‚Äìdim); margin-bottom:10px; }

/* Bottom section (easy explain + perf) */
.bottom-section { max-width:1600px; margin:0 auto; padding:0 16px 30px; }
.bottom-grid { display:grid; grid-template-columns:1fr 1fr; gap:16px; }

@media(min-width:1101px) {
.info-panel { width:340px; }
.perf-bars { height:32px; }
.perf-bar-val { font-size:.58rem; }
.perf-label { min-width:70px; font-size:.75rem; }
}

/* Accordion */
.acc-item { border-bottom:1px solid var(‚Äìborder); }
.acc-item:last-child { border-bottom:none; }
.acc-head { display:flex; align-items:center; gap:8px; padding:8px 0; cursor:pointer; user-select:none; -webkit-user-select:none; }
.acc-head:active { opacity:.7; }
.acc-dot { width:8px; height:8px; border-radius:3px; flex-shrink:0; }
.acc-title { flex:1; font-weight:600; font-size:.8rem; }
.acc-meta { font-family:‚ÄòJetBrains Mono‚Äô,monospace; font-size:.6rem; color:var(‚Äìdim); }
.acc-chev { font-size:.65rem; color:var(‚Äìdim); transition:transform .25s; }
.acc-item.open .acc-chev { transform:rotate(90deg); }
.acc-body { max-height:0; overflow:hidden; transition:max-height .3s,padding .3s; padding:0 0 0 16px; }
.acc-item.open .acc-body { max-height:350px; padding:0 0 8px 16px; }
.acc-body p { font-size:.75rem; line-height:1.5; color:var(‚Äìdim); margin:0; }
.acc-body p strong { color:var(‚Äìtext); }
.acc-badge-new { font-size:.55rem; background:var(‚Äìnew-block); color:#000; padding:1px 5px; border-radius:3px; font-weight:700; margin-left:4px; }
.acc-badge-changed { font-size:.55rem; background:var(‚Äìchanged); color:#000; padding:1px 5px; border-radius:3px; font-weight:700; margin-left:4px; }

/* Stats */
.stats-grid { display:grid; grid-template-columns:1fr 1fr; gap:6px; }
.stat-item { background:var(‚Äìbg); border-radius:6px; padding:8px; text-align:center; }
.stat-value { font-size:1.3rem; font-weight:700; font-family:‚ÄòJetBrains Mono‚Äô,monospace; }
.stat-label { font-size:.6rem; color:var(‚Äìdim); text-transform:uppercase; letter-spacing:1px; margin-top:1px; }

/* State dots */
.state-row { display:flex; align-items:center; gap:8px; margin-bottom:6px; font-size:.8rem; }
.state-dot { width:8px; height:8px; border-radius:50%; flex-shrink:0; }
.state-label { font-weight:600; min-width:70px; }
.state-desc { color:var(‚Äìdim); font-size:.73rem; }

/* Explainer */
.explainer { position:relative; overflow:hidden; min-height:100px; max-height:400px; }
.explainer::before { content:‚Äô‚Äô; position:absolute; top:0; left:0; right:0; height:3px;
background:linear-gradient(90deg,var(‚Äìl1),var(‚Äìl2),var(‚Äìsmem),var(‚Äìglobal),var(‚Äìdram)); border-radius:10px 10px 0 0; opacity:.6; }
.explainer-title { font-weight:700; font-size:.95rem; margin-bottom:8px; display:flex; align-items:center; gap:8px; }
.explainer-title .dot { width:8px; height:8px; border-radius:50%; animation:pulse-dot 1.5s ease-in-out infinite; }
@keyframes pulse-dot { 0%,100%{opacity:.5;transform:scale(1)} 50%{opacity:1;transform:scale(1.3)} }
.step-list { list-style:none; max-height:220px; overflow-y:auto; overscroll-behavior:contain; scrollbar-width:thin; scrollbar-color:var(‚Äìborder) transparent; }
.step-list::-webkit-scrollbar{width:4px} .step-list::-webkit-scrollbar-thumb{background:var(‚Äìborder);border-radius:2px}
.step-list li { display:flex; align-items:flex-start; gap:8px; padding:5px 0; font-size:.78rem; line-height:1.4; opacity:0; transform:translateX(-6px); transition:opacity .4s,transform .4s; }
.step-list li.visible { opacity:1; transform:translateX(0); }
.step-list li.active { opacity:1; transform:translateX(0); }
.step-list li.past { opacity:.4; }
.step-num { font-family:‚ÄòJetBrains Mono‚Äô,monospace; font-size:.65rem; font-weight:600; min-width:18px; height:18px; display:flex; align-items:center; justify-content:center; border-radius:4px; flex-shrink:0; }
.step-text { flex:1; }
.step-text .micro { display:block; font-size:.68rem; color:var(‚Äìdim); font-family:‚ÄòJetBrains Mono‚Äô,monospace; margin-top:1px; }
.explainer-summary { margin-top:8px; padding-top:8px; border-top:1px solid var(‚Äìborder); font-size:.73rem; color:var(‚Äìdim); font-style:italic; opacity:0; transition:opacity .5s; }
.explainer-summary.visible { opacity:1; }

/* Event log */
.event-log { max-height:160px; overflow-y:auto; overscroll-behavior:contain; scrollbar-width:thin; scrollbar-color:var(‚Äìborder) transparent; }
.event-log::-webkit-scrollbar{width:4px} .event-log::-webkit-scrollbar-thumb{background:var(‚Äìborder);border-radius:2px}
.log-entry { font-family:‚ÄòJetBrains Mono‚Äô,monospace; font-size:.65rem; padding:3px 0; border-bottom:1px solid rgba(42,45,58,.5); color:var(‚Äìdim); animation:fadeIn .3s; }
.log-entry .tag { display:inline-block; padding:1px 5px; border-radius:3px; font-size:.6rem; margin-right:3px; }
@keyframes fadeIn { from{opacity:0;transform:translateY(-4px)} to{opacity:1;transform:translateY(0)} }

/* Arch intro card */
.arch-intro {
max-width:900px; margin:6px auto 0; padding:0 16px;
}
.arch-intro-inner {
background:var(‚Äìsurface); border:1px solid var(‚Äìborder); border-radius:10px;
padding:14px 16px; display:flex; gap:14px; align-items:flex-start;
}
.arch-intro-badge {
font-family:‚ÄòJetBrains Mono‚Äô,monospace; font-size:.6rem; font-weight:700;
padding:4px 10px; border-radius:5px; white-space:nowrap; flex-shrink:0; margin-top:2px;
}
.arch-intro-text { font-size:.8rem; line-height:1.55; color:var(‚Äìdim); }
.arch-intro-text strong { color:var(‚Äìtext); }

/* Easy explain */
.easy-card { border-left:3px solid var(‚Äìsmem); }
.easy-card h3 span { color:var(‚Äìsmem); font-size:.6rem; margin-left:6px; font-weight:400; }
.easy-q { padding:8px 0; border-bottom:1px solid var(‚Äìborder); cursor:pointer; user-select:none; -webkit-user-select:none; }
.easy-q:last-child { border-bottom:none; }
.easy-q:active { opacity:.7; }
.easy-head { display:flex; align-items:center; gap:8px; }
.easy-emoji { font-size:1rem; flex-shrink:0; width:22px; text-align:center; }
.easy-title { flex:1; font-weight:600; font-size:.82rem; }
.easy-chev { font-size:.65rem; color:var(‚Äìdim); transition:transform .25s; }
.easy-q.open .easy-chev { transform:rotate(90deg); }
.easy-body { max-height:0; overflow:hidden; transition:max-height .3s,padding .3s; padding:0 0 0 30px; }
.easy-q.open .easy-body { max-height:500px; padding:4px 0 6px 30px; }
.easy-body p { font-size:.78rem; line-height:1.6; color:var(‚Äìdim); margin:0 0 6px; }
.easy-body p strong { color:var(‚Äìtext); }
.easy-body .analogy { font-style:italic; color:var(‚Äìsmem); font-size:.73rem; }

/* Perf comparison */
.perf-card h3 { margin-bottom:12px; }
.perf-row { display:flex; align-items:center; gap:8px; margin-bottom:8px; }
.perf-label { font-size:.7rem; font-family:‚ÄòJetBrains Mono‚Äô,monospace; color:var(‚Äìdim); min-width:65px; flex-shrink:0; }
.perf-bars { flex:1; display:flex; gap:2px; height:28px; align-items:flex-end; }
.perf-bar {
flex:1; border-radius:2px 2px 0 0; position:relative; min-height:2px;
transition:height .4s ease; display:flex; align-items:flex-end; justify-content:center;
}
.perf-bar-val {
font-family:‚ÄòJetBrains Mono‚Äô,monospace; font-size:.5rem; font-weight:600;
position:absolute; top:-12px; width:100%; text-align:center; white-space:nowrap;
}
.perf-bar.active { outline:1px solid #fff3; outline-offset:1px; }
.perf-legend { display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; justify-content:center; }
.perf-legend-item { display:flex; align-items:center; gap:4px; font-size:.6rem; font-family:‚ÄòJetBrains Mono‚Äô,monospace; color:var(‚Äìdim); }
.perf-legend-dot { width:8px; height:8px; border-radius:2px; }

@media(max-width:1100px) {
.main-container { flex-direction:column; }
.info-panel { width:100%; flex-direction:row; flex-wrap:wrap; }
.info-card { flex:1; min-width:260px; }
.bottom-grid { grid-template-columns:1fr; }
}
</style>

</head>
<body>
<div class="grain"></div>

<header>
  <h1>GPU Cache Coherency</h1>
  <p>Architecture Explorer ¬∑ Memory Hierarchy ¬∑ Data Flow</p>
</header>

<div class="arch-tabs" id="arch-tabs">
  <div class="arch-tab active" data-arch="pascal" style="--accent-color:#51cf66" onclick="switchArch('pascal')">
    Pascal<span class="tab-gen">SM 6.1 ¬∑ 2016</span>
  </div>
  <div class="arch-tab" data-arch="volta" style="--accent-color:#339af0" onclick="switchArch('volta')">
    Volta<span class="tab-gen">SM 7.0 ¬∑ 2017</span>
  </div>
  <div class="arch-tab" data-arch="ampere" style="--accent-color:#ffa94d" onclick="switchArch('ampere')">
    Ampere<span class="tab-gen">SM 8.0 ¬∑ 2020</span>
  </div>
  <div class="arch-tab" data-arch="hopper" style="--accent-color:#845ef7" onclick="switchArch('hopper')">
    Hopper<span class="tab-gen">SM 9.0 ¬∑ 2022</span>
  </div>
</div>

<div class="diff-banner" id="diff-banner"></div>

<div class="arch-intro"><div class="arch-intro-inner" id="arch-intro"></div></div>

<div class="controls">
  <button onclick="triggerScenario('read')">SM Read</button>
  <button onclick="triggerScenario('write')">SM Write</button>
  <button onclick="triggerScenario('invalidate')">Invalidate</button>
  <button onclick="triggerScenario('writeback')">Write-Back</button>
  <button onclick="triggerScenario('shared')">Shared Mem</button>
  <button id="btn-auto" class="active" onclick="toggleAuto()">Auto</button>
  <button class="reset-btn" onclick="resetAll()">Reset</button>
</div>

<div class="main-container">
  <div class="viz-area"><canvas id="canvas"></canvas></div>
  <div class="info-panel">

```
<div class="info-card" id="key-card"></div>

<div class="info-card">
  <h3>Cache States (MSI)</h3>
  <div class="state-row"><div class="state-dot" style="background:#51cf66"></div><span class="state-label">Modified</span><span class="state-desc">Dirty, exclusive</span></div>
  <div class="state-row"><div class="state-dot" style="background:#339af0"></div><span class="state-label">Shared</span><span class="state-desc">Clean, multi-reader</span></div>
  <div class="state-row"><div class="state-dot" style="background:#555"></div><span class="state-label">Invalid</span><span class="state-desc">Stale / absent</span></div>
</div>

<div class="info-card">
  <h3>Live Stats</h3>
  <div class="stats-grid">
    <div class="stat-item"><div class="stat-value" id="stat-hits" style="color:var(--smem)">0</div><div class="stat-label">Hits</div></div>
    <div class="stat-item"><div class="stat-value" id="stat-misses" style="color:var(--l1)">0</div><div class="stat-label">Misses</div></div>
    <div class="stat-item"><div class="stat-value" id="stat-inv" style="color:var(--coherency)">0</div><div class="stat-label">Invalidations</div></div>
    <div class="stat-item"><div class="stat-value" id="stat-wb" style="color:var(--l2)">0</div><div class="stat-label">Write-Backs</div></div>
  </div>
</div>

<div class="info-card explainer" id="explainer-card">
  <h3>What's Happening</h3>
  <div id="explainer-title" class="explainer-title" style="color:var(--dim)"><span class="dot" style="background:var(--dim)"></span>Click a scenario or wait for auto...</div>
  <ol class="step-list" id="step-list"></ol>
  <div class="explainer-summary" id="explainer-summary"></div>
</div>

<div class="info-card">
  <h3>Event Log</h3>
  <div class="event-log" id="event-log"></div>
</div>
```

  </div>
</div>

<!-- BELOW-FOLD: Easy Explain + Perf (full width on desktop) -->

<div class="bottom-section">
  <div class="bottom-grid">

```
<!-- EASY EXPLAIN -->
<div class="info-card easy-card">
  <h3>Easy Explain <span>for beginners</span></h3>

  <div class="easy-q" onclick="this.classList.toggle('open')">
    <div class="easy-head"><span class="easy-emoji">üè†</span><span class="easy-title">What is a cache?</span><span class="easy-chev">‚ñ∏</span></div>
    <div class="easy-body">
      <p>A cache is a <strong>small, fast storage</strong> that keeps copies of frequently used data close to where it's needed. The GPU's main memory (HBM/DRAM) is huge but slow. The caches (L1, L2) are small but fast.</p>
      <p class="analogy">Analogy: Your desk (cache) vs the library (main memory). You keep the books you're reading on your desk so you don't have to walk to the library every time.</p>
    </div>
  </div>

  <div class="easy-q" onclick="this.classList.toggle('open')">
    <div class="easy-head"><span class="easy-emoji">ü§ù</span><span class="easy-title">What is cache coherency?</span><span class="easy-chev">‚ñ∏</span></div>
    <div class="easy-body">
      <p>When <strong>multiple processors</strong> (SMs) each have their own cache, they might hold different copies of the same data. If one SM writes to its copy, the others become <strong>stale</strong>. Cache coherency is the system that keeps everyone's copies consistent.</p>
      <p class="analogy">Analogy: 5 people editing copies of the same document. If Alice changes page 3, everyone else needs to know their page 3 is outdated ‚Äî that's invalidation.</p>
    </div>
  </div>

  <div class="easy-q" onclick="this.classList.toggle('open')">
    <div class="easy-head"><span class="easy-emoji">üì¶</span><span class="easy-title">What is an SM?</span><span class="easy-chev">‚ñ∏</span></div>
    <div class="easy-body">
      <p>A <strong>Streaming Multiprocessor</strong> is the GPU's core compute unit ‚Äî like a mini-processor. A GPU has many SMs (28 to 132+). Each SM runs thousands of threads in parallel using "warps" (groups of 32 threads). Each SM has its own private L1 cache and shared memory.</p>
      <p class="analogy">Analogy: Each SM is like a team at a company. Each team has its own whiteboard (shared memory) and desk space (L1 cache), but they all share the same filing cabinet (L2) and warehouse (HBM).</p>
    </div>
  </div>

  <div class="easy-q" onclick="this.classList.toggle('open')">
    <div class="easy-head"><span class="easy-emoji">üî∫</span><span class="easy-title">Why is there a hierarchy?</span><span class="easy-chev">‚ñ∏</span></div>
    <div class="easy-body">
      <p>There's a fundamental tradeoff: <strong>fast memory is small, big memory is slow</strong>. So GPUs stack multiple levels:</p>
      <p><strong>Registers</strong> (~1 cycle) ‚Üí <strong>Shared Mem</strong> (~20 cycles) ‚Üí <strong>L1</strong> (~28 cycles) ‚Üí <strong>L2</strong> (~200 cycles) ‚Üí <strong>HBM</strong> (~400+ cycles)</p>
      <p>Each level is bigger but slower. The whole point of caching is to keep hot data in the fast levels so you rarely need to go to the slow ones.</p>
    </div>
  </div>

  <div class="easy-q" onclick="this.classList.toggle('open')">
    <div class="easy-head"><span class="easy-emoji">‚ö°</span><span class="easy-title">Shared memory vs L1 ‚Äî what's the difference?</span><span class="easy-chev">‚ñ∏</span></div>
    <div class="easy-body">
      <p><strong>L1 cache</strong> is automatic ‚Äî the hardware decides what to cache. You don't control it. It needs coherency protocols because multiple SMs might cache the same address.</p>
      <p><strong>Shared memory</strong> is manual ‚Äî the programmer explicitly loads data into it. It's private to one SM, so there's no coherency problem. It's faster and predictable, but requires more programmer effort.</p>
      <p class="analogy">Analogy: L1 is like auto-complete ‚Äî helpful but sometimes wrong. Shared memory is like copy-pasting exactly what you need ‚Äî more work but reliable.</p>
    </div>
  </div>

  <div class="easy-q" onclick="this.classList.toggle('open')">
    <div class="easy-head"><span class="easy-emoji">üö´</span><span class="easy-title">What does "invalidate" mean?</span><span class="easy-chev">‚ñ∏</span></div>
    <div class="easy-body">
      <p>When one SM writes to a memory address, any other SMs that cached that address now have an <strong>outdated copy</strong>. "Invalidation" is a message that says "your copy is no longer valid ‚Äî throw it away." The next time they need that data, they'll have to fetch the fresh version from L2.</p>
    </div>
  </div>

  <div class="easy-q" onclick="this.classList.toggle('open')">
    <div class="easy-head"><span class="easy-emoji">üîÑ</span><span class="easy-title">What does "write-evict" mean?</span><span class="easy-chev">‚ñ∏</span></div>
    <div class="easy-body">
      <p>When an SM writes data, instead of keeping the dirty copy in L1 (which would need complex coherency), it <strong>drops the L1 copy entirely</strong> and writes straight to L2. The L1 line is "evicted" on write. This is simpler and cheaper than the CPU approach (write-back) but means more L2 traffic.</p>
      <p class="analogy">Analogy: Instead of updating your desk copy and telling everyone yours changed, you just throw away your desk copy and update the master in the filing cabinet directly.</p>
    </div>
  </div>
</div>

<!-- PERFORMANCE COMPARISON -->
<div class="info-card perf-card">
  <h3>Performance Across Architectures</h3>
  <div id="perf-chart"></div>
  <div class="perf-legend">
    <div class="perf-legend-item"><div class="perf-legend-dot" style="background:#51cf66"></div>Pascal</div>
    <div class="perf-legend-item"><div class="perf-legend-dot" style="background:#339af0"></div>Volta</div>
    <div class="perf-legend-item"><div class="perf-legend-dot" style="background:#ffa94d"></div>Ampere</div>
    <div class="perf-legend-item"><div class="perf-legend-dot" style="background:#845ef7"></div>Hopper</div>
  </div>
</div>
```

  </div>
</div>

<script>
// ‚îÄ‚îÄ‚îÄ Canvas setup ‚îÄ‚îÄ‚îÄ
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H, dpr;
let initialized = false;
function resize() {
  dpr = window.devicePixelRatio || 1;
  const r = canvas.getBoundingClientRect();
  W = r.width; H = r.height;
  canvas.width = W * dpr; canvas.height = H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  if (initialized) buildLayout();
}
resize();
window.addEventListener('resize', resize);

function rrect(x, y, w, h, r) {
  r = Math.min(r, w/2, h/2);
  ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y);
  ctx.arcTo(x+w,y,x+w,y+r,r); ctx.lineTo(x+w,y+h-r);
  ctx.arcTo(x+w,y+h,x+w-r,y+h,r); ctx.lineTo(x+r,y+h);
  ctx.arcTo(x,y+h,x,y+h-r,r); ctx.lineTo(x,y+r);
  ctx.arcTo(x,y,x+r,y,r); ctx.closePath();
}

// ‚îÄ‚îÄ‚îÄ Architecture definitions ‚îÄ‚îÄ‚îÄ
const ARCHS = {
  pascal: {
    name: 'Pascal', gen: 'SM 6.1', year: 2016, color: '#51cf66', example: 'GTX 1080 Ti',
    smLabel: 'SM',
    intro: 'The last generation before unified L1. Pascal keeps things simple ‚Äî L1 is read-only for global memory, so there\'s zero coherency overhead at L1. Writes go straight to L2. Great for understanding the baseline before things got complex.',
    perf: { smCount: 28, l1Size: 24, smemSize: 96, l2Size: 4096, bw: 484, flops: 11.3, memType: 'GDDR5X', vram: 11, tdp: 250, l1Latency: 28, l2Latency: 200, dramLatency: 400 },
    blocks: {
      l1: { label: 'L1 (24KB)', desc: 'Read-only texture/data cache. NOT coherent with global stores ‚Äî writes bypass L1 entirely. Separate from shared memory.', state: true },
      texCache: { label: 'TEX$', desc: 'Separate texture cache, read-only, fed by texture units. ~24KB.', isNew: false },
      sharedMem: { label: 'SMEM (48‚Äì96KB)', desc: 'Separate physical SRAM from L1. Configurable 48K/16K or 32K/32K split with L1 (but they are distinct caches).', state: false },
      l2: { label: 'L2 Cache (3‚Äì4MB)', desc: 'Unified, coherent. Point of coherence for all SMs. All global writes go directly here (write-through from SM).', size: '3‚Äì4MB' },
      coherencyBus: { label: 'Crossbar', desc: 'Simple crossbar ‚Äî minimal coherency traffic since L1 is read-only for global loads. No invalidation needed.' },
      globalMem: { label: 'Global Memory', desc: 'GDDR5/GDDR5X memory interface. 4‚Äì8 memory controllers.' },
      hbm: { label: 'GDDR5X', desc: 'High-speed GDDR, not HBM. ~480 GB/s on 1080 Ti.' },
    },
    writePolicy: 'Write-through (L1 is read-only for globals)',
    coherency: 'None at L1 ‚Äî L2 is sole coherence point',
    keyChange: null,
  },
  volta: {
    name: 'Volta', gen: 'SM 7.0', year: 2017, color: '#339af0', example: 'V100',
    smLabel: 'SM',
    intro: 'The big unification. Volta merged L1 and texture cache into a single 128KB SRAM that\'s also shared with SMEM. L1 now caches global writes too, which means coherency actually matters ‚Äî enter write-evict and invalidation. The jump to HBM2 massively increased bandwidth.',
    perf: { smCount: 80, l1Size: 128, smemSize: 96, l2Size: 6144, bw: 900, flops: 15.7, memType: 'HBM2', vram: 32, tdp: 300, l1Latency: 28, l2Latency: 193, dramLatency: 370 },
    blocks: {
      l1: { label: 'L1 + TEX (unified, 128KB)', desc: 'L1 and texture cache merged into single unified cache. Shares physical SRAM with shared memory ‚Äî configurable split. Now handles global loads AND atomics.', state: true, changed: true },
      texCache: null,
      sharedMem: { label: 'SMEM (up to 96KB)', desc: 'Shares the 128KB SRAM pool with L1. Configurable: 32/64/96KB SMEM with remainder as L1. Software-managed, no coherency needed.', changed: true },
      l2: { label: 'L2 Cache (6MB)', desc: 'Larger L2. Still the point of coherence. L1 uses write-evict policy ‚Äî dirty lines are evicted (not written back) so L2 always has latest.', size: '6MB', changed: true },
      coherencyBus: { label: 'Coherency Bus', desc: 'Now carries invalidation messages since L1 caches global data. Write-evict policy: SM writes evict L1 line and write to L2, then invalidate other L1 copies.' },
      globalMem: { label: 'Global Memory', desc: 'HBM2 memory interface. 4 stacks, 8 channels each.' },
      hbm: { label: 'HBM2', desc: '900 GB/s bandwidth. Stacked DRAM via silicon interposer.', changed: true },
    },
    writePolicy: 'Write-evict (dirty L1 line dropped, write goes to L2)',
    coherency: 'L1 invalidation via bus, L2 is coherence point',
    keyChange: 'L1 + TEX unified, shared SRAM pool with SMEM, HBM2',
  },
  ampere: {
    name: 'Ampere', gen: 'SM 8.0', year: 2020, color: '#ffa94d', example: 'A100',
    smLabel: 'SM',
    intro: 'Ampere\'s headline features are the 10x larger L2 (40MB!) with software-controlled persistence, and async copy (cp.async) that moves data from global to shared memory without burning registers or warp scheduler cycles. This enabled the software-pipelined GEMM patterns that power modern transformer training.',
    perf: { smCount: 108, l1Size: 192, smemSize: 164, l2Size: 40960, bw: 2039, flops: 19.5, memType: 'HBM2e', vram: 80, tdp: 400, l1Latency: 33, l2Latency: 200, dramLatency: 400 },
    blocks: {
      l1: { label: 'L1 + TEX (192KB)', desc: 'Larger unified L1/TEX cache. Same write-evict policy as Volta but with more capacity and better hit rates.', state: true, changed: true },
      texCache: null,
      sharedMem: { label: 'SMEM (up to 164KB)', desc: 'Larger SMEM allocation possible from the 192KB pool. New: async copy (cp.async) can load from global‚ÜíSMEM bypassing register file.', changed: true },
      asyncCopy: { label: 'ASYNC COPY', desc: 'cp.async instruction: DMA-like transfer from global memory directly into shared memory, bypassing registers. Overlaps compute with data movement. Game-changer for GEMM pipelines.', isNew: true },
      l2: { label: 'L2 Cache (40MB)', desc: 'Massive L2 increase. New: L2 persistence controls ‚Äî can pin data in L2 slices to avoid eviction. Set via cudaAccessPolicyWindow.', size: '40MB', changed: true },
      l2Persist: { label: 'L2 PERSIST', desc: 'Software-controlled L2 data persistence. Pin frequently accessed data in L2 to prevent eviction. Configurable per-stream via access policy windows.', isNew: true },
      coherencyBus: { label: 'Coherency Bus', desc: 'Same write-evict L1 coherency as Volta. Async copy adds a new data path that bypasses the normal load pipeline.' },
      globalMem: { label: 'Global Memory', desc: 'HBM2e interface. 5 stacks, 10 512-bit channels.' },
      hbm: { label: 'HBM2e', desc: '2 TB/s bandwidth. 80GB capacity on A100.', changed: true },
    },
    writePolicy: 'Write-evict (same as Volta)',
    coherency: 'L1 write-evict + invalidation, L2 persistence controls',
    keyChange: 'Async copy (cp.async), 10√ó larger L2 with persistence',
  },
  hopper: {
    name: 'Hopper', gen: 'SM 9.0', year: 2022, color: '#845ef7', example: 'H100',
    smLabel: 'SM',
    intro: 'Hopper introduces two radical changes: the Tensor Memory Accelerator (TMA) ‚Äî a hardware DMA engine that handles complex tensor addressing without touching warp schedulers ‚Äî and Distributed Shared Memory (DSMEM), where SMs in a cluster can directly read each other\'s shared memory. This fundamentally changes how data moves through the hierarchy.',
    perf: { smCount: 132, l1Size: 256, smemSize: 228, l2Size: 51200, bw: 3352, flops: 66.9, memType: 'HBM3', vram: 80, tdp: 700, l1Latency: 33, l2Latency: 200, dramLatency: 380 },
    blocks: {
      l1: { label: 'L1 + TEX (256KB)', desc: 'Even larger unified cache. Now supports TMA (Tensor Memory Accelerator) loads that bypass warp schedulers entirely.', state: true, changed: true },
      texCache: null,
      sharedMem: { label: 'SMEM (up to 228KB)', desc: 'Largest SMEM ever. New: Distributed Shared Memory (DSMEM) ‚Äî threads can directly read/write other SMs\' shared memory within a cluster, no global memory round-trip.', changed: true },
      dsmem: { label: 'DSMEM', desc: 'Distributed Shared Memory. SMs within a Thread Block Cluster (up to 16 SMs) can directly access each other\'s shared memory. Enables cross-SM communication at SMEM latency (~20 cycles) instead of global memory latency (~400 cycles).', isNew: true },
      tma: { label: 'TMA', desc: 'Tensor Memory Accelerator. Hardware DMA unit that handles bulk data transfers (global‚Üîshared) with tensor-aware addressing. Frees warp schedulers from address generation. Supports 1D‚Äì5D tensor copies.', isNew: true },
      asyncCopy: { label: 'ASYNC COPY', desc: 'Enhanced from Ampere with TMA integration. Bulk async operations with barrier-based synchronization.' },
      l2: { label: 'L2 Cache (50MB)', desc: 'Larger still, with improved persistence controls and better partitioning for multi-tenant workloads.', size: '50MB', changed: true },
      l2Persist: { label: 'L2 PERSIST', desc: 'Refined from Ampere with better granularity and multi-process support.' },
      coherencyBus: { label: 'Cluster Bus', desc: 'New cluster-level interconnect for DSMEM. SMs in a cluster share a fast bus for distributed shared memory. Global coherency still via L2.', changed: true },
      globalMem: { label: 'Global Memory', desc: 'HBM3 interface. Higher bandwidth per pin.' },
      hbm: { label: 'HBM3', desc: '3.35 TB/s bandwidth. 80GB capacity.', changed: true },
    },
    writePolicy: 'Write-evict + TMA bulk transfers',
    coherency: 'Cluster-level DSMEM coherency + L2 global coherence',
    keyChange: 'TMA engine, Distributed Shared Memory (DSMEM), HBM3',
  }
};

let currentArch = 'pascal';
let prevArch = null;
let stats = { hits:0, misses:0, inv:0, wb:0 };
let autoMode = true, autoTimer = 0;
let particles = [], flashEffects = [], stepTimers = [];
let layout = {};

// ‚îÄ‚îÄ‚îÄ Diff banner ‚îÄ‚îÄ‚îÄ
function updateDiffBanner() {
  const banner = document.getElementById('diff-banner');
  if (!prevArch || prevArch === currentArch) { banner.classList.remove('visible'); return; }
  const prev = ARCHS[prevArch], curr = ARCHS[currentArch];
  let parts = [];
  // Find new blocks
  for (const [k, v] of Object.entries(curr.blocks)) {
    if (!v) continue;
    const prevBlock = prev.blocks[k];
    if (!prevBlock && v) parts.push(`<span class="new-tag">+ ${v.label}</span>`);
    else if (prevBlock && v.changed) parts.push(`<span class="changed-tag">‚Üë ${v.label}</span>`);
  }
  // Find removed blocks
  for (const [k, v] of Object.entries(prev.blocks)) {
    if (!v) continue;
    if (!curr.blocks[k] || curr.blocks[k] === null) parts.push(`<span class="removed-tag">${v.label}</span>`);
  }
  if (curr.keyChange) parts.push(`<br><span style="color:var(--dim)">Key: ${curr.keyChange}</span>`);
  if (parts.length) {
    banner.innerHTML = `<strong style="color:${curr.color}">${prev.name} ‚Üí ${curr.name}:</strong> ` + parts.join(' ¬∑ ');
    banner.classList.add('visible');
  } else { banner.classList.remove('visible'); }
}

// ‚îÄ‚îÄ‚îÄ Key card (dynamic per arch) ‚îÄ‚îÄ‚îÄ
function updateKeyCard() {
  const arch = ARCHS[currentArch];
  const prev = prevArch ? ARCHS[prevArch] : null;
  let html = `<h3>Diagram Key ‚Äî ${arch.name} <span style="color:${arch.color};font-weight:600">${arch.example}</span></h3>`;

  const items = [
    { key: 'l1', color: 'var(--l1)', meta: 'per-SM' },
    { key: 'texCache', color: '#e599f7', meta: 'per-SM' },
    { key: 'sharedMem', color: 'var(--smem)', meta: 'per-SM' },
    { key: 'dsmem', color: 'var(--new-block)', meta: 'cluster' },
    { key: 'tma', color: 'var(--new-block)', meta: 'per-SM' },
    { key: 'asyncCopy', color: 'var(--new-block)', meta: 'engine' },
    { key: 'coherencyBus', color: 'var(--coherency)', meta: 'fabric' },
    { key: 'l2', color: 'var(--l2)', meta: 'unified' },
    { key: 'l2Persist', color: 'var(--l2)', meta: 'L2 ctrl' },
    { key: 'globalMem', color: 'var(--global)', meta: 'interface' },
    { key: 'hbm', color: 'var(--dram)', meta: 'off-chip' },
  ];

  for (const item of items) {
    const block = arch.blocks[item.key];
    if (!block) continue;
    const prevBlock = prev ? prev.blocks[item.key] : null;
    let badge = '';
    if (block.isNew) badge = '<span class="acc-badge-new">NEW</span>';
    else if (block.changed && prev) badge = '<span class="acc-badge-changed">CHANGED</span>';

    html += `<div class="acc-item" onclick="this.classList.toggle('open')">
      <div class="acc-head">
        <div class="acc-dot" style="background:${item.color}"></div>
        <span class="acc-title">${block.label}${badge}</span>
        <span class="acc-meta">${item.meta}</span>
        <span class="acc-chev">‚ñ∏</span>
      </div>
      <div class="acc-body"><p>${block.desc}</p></div>
    </div>`;
  }

  // Arch summary
  html += `<div style="margin-top:10px;padding-top:8px;border-top:1px solid var(--border);font-size:.72rem;color:var(--dim)">
    <strong style="color:var(--text)">Write policy:</strong> ${arch.writePolicy}<br>
    <strong style="color:var(--text)">Coherency:</strong> ${arch.coherency}
  </div>`;

  document.getElementById('key-card').innerHTML = html;
}

// ‚îÄ‚îÄ‚îÄ Architecture switching ‚îÄ‚îÄ‚îÄ
function switchArch(arch) {
  if (arch === currentArch) return;
  prevArch = currentArch;
  currentArch = arch;
  document.querySelectorAll('.arch-tab').forEach(function(t) { t.classList.toggle('active', t.dataset.arch === arch); });
  resetAll(true);
  buildLayout();
  updateDiffBanner();
  updateKeyCard();
  updateArchIntro();
  updatePerfChart();
  logEvent('Switched to ' + ARCHS[arch].name + ' (' + ARCHS[arch].gen + ')', ARCHS[arch].color);
}

// ‚îÄ‚îÄ‚îÄ Arch intro ‚îÄ‚îÄ‚îÄ
function updateArchIntro() {
  var arch = ARCHS[currentArch];
  var el = document.getElementById('arch-intro');
  el.innerHTML = '<div class="arch-intro-badge" style="background:' + arch.color + '20;color:' + arch.color + '">' +
    arch.name + ' &middot; ' + arch.example + '</div>' +
    '<div class="arch-intro-text">' + arch.intro + '</div>';
}

// ‚îÄ‚îÄ‚îÄ Performance chart ‚îÄ‚îÄ‚îÄ
function updatePerfChart() {
  var metrics = [
    { key: 'l1Size', label: 'L1/SM', unit: 'KB', maxVal: 256 },
    { key: 'smemSize', label: 'SMEM', unit: 'KB', maxVal: 228 },
    { key: 'l2Size', label: 'L2', unit: 'MB', divBy: 1024, maxVal: 50 },
    { key: 'bw', label: 'BW', unit: 'GB/s', maxVal: 3352 },
    { key: 'smCount', label: 'SMs', unit: '', maxVal: 132 },
    { key: 'flops', label: 'TFLOPS', unit: '', maxVal: 67 },
    { key: 'vram', label: 'VRAM', unit: 'GB', maxVal: 80 }
  ];
  var archKeys = ['pascal', 'volta', 'ampere', 'hopper'];
  var colors = { pascal: '#51cf66', volta: '#339af0', ampere: '#ffa94d', hopper: '#845ef7' };
  var html = '';

  for (var m = 0; m < metrics.length; m++) {
    var met = metrics[m];
    html += '<div class="perf-row"><span class="perf-label">' + met.label + '</span><div class="perf-bars">';
    for (var a = 0; a < archKeys.length; a++) {
      var ak = archKeys[a];
      var raw = ARCHS[ak].perf[met.key];
      var display = met.divBy ? Math.round(raw / met.divBy) : (raw % 1 === 0 ? raw : raw.toFixed(1));
      var effectiveMax = met.divBy ? met.maxVal * met.divBy : met.maxVal;
      var pct = Math.max(8, (raw / effectiveMax) * 100);
      var isActive = ak === currentArch;
      html += '<div class="perf-bar' + (isActive ? ' active' : '') + '" style="height:' + pct +
        '%;background:' + colors[ak] + (isActive ? '' : '50') + '">' +
        '<span class="perf-bar-val" style="color:' + colors[ak] + (isActive ? '' : '70') + '">' +
        display + (met.unit || '') + '</span></div>';
    }
    html += '</div></div>';
  }
  document.getElementById('perf-chart').innerHTML = html;
}

// ‚îÄ‚îÄ‚îÄ Layout builder (per architecture) ‚îÄ‚îÄ‚îÄ
function buildLayout() {
  const cx = W / 2;
  const mob = W < 500;
  const arch = ARCHS[currentArch];
  const smCount = mob ? 2 : (currentArch === 'hopper' ? 4 : (currentArch === 'pascal' ? 3 : 4));
  const margin = mob ? 12 : 30;
  const usable = W - margin * 2;
  const smGap = mob ? 12 : 20;
  const smW = Math.min(110, (usable - (smCount - 1) * smGap) / smCount);

  // SM height varies by arch (more sub-blocks = taller)
  let smSubBlocks = 2; // l1 + smem always
  if (arch.blocks.texCache) smSubBlocks++;
  if (arch.blocks.tma) smSubBlocks++;
  if (arch.blocks.dsmem) smSubBlocks++;
  if (arch.blocks.asyncCopy && arch.blocks.asyncCopy.isNew) smSubBlocks++;
  const smH = mob ? (80 + smSubBlocks * 18) : (90 + smSubBlocks * 22);

  const totalSmW = smCount * smW + (smCount - 1) * smGap;
  const smStartX = cx - totalSmW / 2;
  const smY = mob ? 16 : 30;

  layout.sms = [];
  for (let i = 0; i < smCount; i++) {
    const x = smStartX + i * (smW + smGap);
    let subY = smY + (mob ? 32 : 38);
    const subH = mob ? 18 : 22;
    const subPad = mob ? 4 : 5;
    const sub = [];

    // Register file indicator
    sub.push({ type: 'regs', x: x + 6, y: subY, w: smW - 12, h: 6 });
    subY += 10;

    // Texture cache (Pascal only)
    if (arch.blocks.texCache) {
      sub.push({ type: 'texCache', x: x + 6, y: subY, w: smW - 12, h: subH, label: 'TEX$' });
      subY += subH + subPad;
    }

    // L1
    sub.push({ type: 'l1', x: x + 6, y: subY, w: smW - 12, h: subH, label: arch.blocks.l1.label.split('(')[0].trim(), state: 'invalid' });
    const l1Ref = sub[sub.length - 1];
    subY += subH + subPad;

    // SMEM
    sub.push({ type: 'smem', x: x + 6, y: subY, w: smW - 12, h: subH, label: 'SMEM' });
    subY += subH + subPad;

    // TMA (Hopper)
    if (arch.blocks.tma) {
      sub.push({ type: 'tma', x: x + 6, y: subY, w: smW - 12, h: subH, label: 'TMA' });
      subY += subH + subPad;
    }

    // DSMEM indicator (Hopper)
    if (arch.blocks.dsmem) {
      sub.push({ type: 'dsmem', x: x + 6, y: subY, w: smW - 12, h: subH, label: 'DSMEM' });
      subY += subH + subPad;
    }

    // Async copy indicator (Ampere+)
    if (arch.blocks.asyncCopy && (currentArch === 'ampere' || currentArch === 'hopper')) {
      sub.push({ type: 'async', x: x + 6, y: subY, w: smW - 12, h: 14, label: 'cp.async' });
      subY += 14 + subPad;
    }

    const actualH = Math.max(smH, subY - smY + 8);
    layout.sms.push({
      x, y: smY, w: smW, h: actualH,
      label: `${arch.smLabel} ${i}`,
      sub, l1: l1Ref,
    });
  }

  const maxSmBottom = Math.max(...layout.sms.map(s => s.y + s.h));

  // Cluster bracket (Hopper)
  if (currentArch === 'hopper' && smCount > 1) {
    layout.cluster = { x1: smStartX - 6, x2: smStartX + totalSmW + 6, y1: smY - 8, y2: maxSmBottom + 8 };
  } else { layout.cluster = null; }

  const busY = maxSmBottom + (mob ? 30 : 40);
  layout.bus = { y: busY, x1: smStartX - 15, x2: smStartX + totalSmW + 15,
    label: currentArch === 'hopper' ? 'CLUSTER BUS + COHERENCY' : (currentArch === 'pascal' ? 'CROSSBAR' : 'COHERENCY BUS') };

  const l2W = Math.min(totalSmW * 0.85, usable * 0.78);
  const l2Y = busY + (mob ? 35 : 45);
  const l2H = mob ? 42 : 52;
  layout.l2 = { x: cx - l2W/2, y: l2Y, w: l2W, h: l2H };

  // L2 persist bar (Ampere+)
  layout.l2Persist = (currentArch === 'ampere' || currentArch === 'hopper')
    ? { x: cx - l2W/2 + 6, y: l2Y + l2H - 12, w: l2W - 12, h: 8 } : null;

  const cbY = l2Y + l2H + (mob ? 22 : 30);
  layout.crossbar = { y: cbY, x1: cx - l2W/2 - 8, x2: cx + l2W/2 + 8 };

  const gmW = Math.min(totalSmW * 0.85, usable * 0.82);
  const gmY = cbY + (mob ? 28 : 38);
  const gmH = mob ? 42 : 52;
  layout.globalMem = { x: cx - gmW/2, y: gmY, w: gmW, h: gmH };

  const mcCount = mob ? 2 : (currentArch === 'pascal' ? 3 : 4);
  const mcW = mob ? 36 : 44;
  const mcGap = (gmW - mcCount * mcW) / (mcCount + 1);
  layout.mcs = [];
  for (let i = 0; i < mcCount; i++) {
    layout.mcs.push({ x: layout.globalMem.x + mcGap + i * (mcW + mcGap), y: gmY + 12, w: mcW, h: 14 });
  }

  const hbmY = gmY + gmH + (mob ? 16 : 22);
  const hbmW = gmW * 0.88;
  layout.hbm = { x: cx - hbmW/2, y: hbmY, w: hbmW, h: mob ? 34 : 42, label: arch.blocks.hbm.label };
}

// ‚îÄ‚îÄ‚îÄ Drawing ‚îÄ‚îÄ‚îÄ
function drawFrame(time) {
  const dt = Math.min((time - lastTime) / 1000, 0.05);
  lastTime = time;
  ctx.clearRect(0, 0, W, H);
  const arch = ARCHS[currentArch];
  const mob = W < 500;
  const fs = mob ? 0.82 : 1;

  // Cluster bracket (Hopper)
  if (layout.cluster) {
    const c = layout.cluster;
    ctx.setLineDash([4, 4]);
    rrect(c.x1, c.y1, c.x2 - c.x1, c.y2 - c.y1, 10);
    ctx.strokeStyle = arch.color + '40';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.font = `600 ${8*fs}px "JetBrains Mono"`;
    ctx.fillStyle = arch.color + '90';
    ctx.textAlign = 'center';
    ctx.fillText('THREAD BLOCK CLUSTER', (c.x1+c.x2)/2, c.y1 - 2);
  }

  // SMs
  layout.sms.forEach((sm, idx) => {
    rrect(sm.x, sm.y, sm.w, sm.h, 7);
    ctx.fillStyle = '#0f1118'; ctx.fill();
    ctx.strokeStyle = '#2a2d3a'; ctx.lineWidth = 1; ctx.stroke();

    ctx.font = `700 ${10*fs}px "Outfit"`;
    ctx.fillStyle = '#e0e2ec'; ctx.textAlign = 'center';
    ctx.fillText(sm.label, sm.x + sm.w/2, sm.y + 14*fs);

    ctx.font = `400 ${7*fs}px "JetBrains Mono"`;
    ctx.fillStyle = '#6b7094';
    ctx.fillText('Warps ‚ñ∏‚ñ∏‚ñ∏', sm.x + sm.w/2, sm.y + 24*fs);

    sm.sub.forEach(b => {
      if (b.type === 'regs') {
        const barC = Math.floor((b.w) / 10);
        for (let j = 0; j < barC; j++) {
          ctx.fillStyle = `hsl(220,30%,${18 + Math.sin(Date.now()/800+j+idx)*3}%)`;
          ctx.fillRect(b.x + j * (b.w/barC), b.y, b.w/barC - 1.5, b.h);
        }
        return;
      }

      rrect(b.x, b.y, b.w, b.h, 3);
      const colors = {
        l1: { bg: '#ff6b6b10', border: '#ff6b6b', modified: '#51cf66', shared: '#339af0', invalid: '#555' },
        texCache: { bg: '#e599f710', border: '#e599f750' },
        smem: { bg: '#51cf6608', border: '#51cf6650' },
        tma: { bg: '#22d3ee10', border: '#22d3ee60' },
        dsmem: { bg: '#22d3ee10', border: '#22d3ee60' },
        async: { bg: '#22d3ee08', border: '#22d3ee40' },
      };
      const c = colors[b.type] || colors.smem;

      if (b.type === 'l1' && b.state) {
        const stateColor = c[b.state] || c.invalid;
        ctx.fillStyle = stateColor + '18'; ctx.fill();
        ctx.strokeStyle = stateColor; ctx.lineWidth = 1.2; ctx.stroke();
        ctx.font = `600 ${7.5*fs}px "JetBrains Mono"`;
        ctx.fillStyle = stateColor;
        ctx.textAlign = 'center';
        ctx.fillText(`${b.label} [${b.state.charAt(0).toUpperCase()}]`, b.x + b.w/2, b.y + b.h/2 + 3);
      } else {
        ctx.fillStyle = c.bg; ctx.fill();
        ctx.strokeStyle = c.border; ctx.lineWidth = 1; ctx.stroke();
        const labelColor = b.type === 'tma' || b.type === 'dsmem' || b.type === 'async' ? '#22d3ee' :
          b.type === 'texCache' ? '#e599f7' : '#51cf66';
        ctx.font = `600 ${(b.type === 'async' ? 6.5 : 7)*fs}px "JetBrains Mono"`;
        ctx.fillStyle = labelColor;
        ctx.textAlign = 'center';
        ctx.fillText(b.label, b.x + b.w/2, b.y + b.h/2 + 3);
      }
    });
  });

  // Connection lines SM ‚Üí bus
  layout.sms.forEach(sm => {
    ctx.beginPath();
    ctx.moveTo(sm.x + sm.w/2, sm.y + sm.h);
    ctx.lineTo(sm.x + sm.w/2, layout.bus.y);
    ctx.strokeStyle = '#2a2d3a'; ctx.lineWidth = 1; ctx.stroke();
  });

  // DSMEM cross-links (Hopper)
  if (currentArch === 'hopper' && layout.sms.length > 1) {
    const pulse = Math.sin(Date.now()/500) * 0.3 + 0.5;
    for (let i = 0; i < layout.sms.length - 1; i++) {
      const a = layout.sms[i], b = layout.sms[i+1];
      const dsA = a.sub.find(s => s.type === 'dsmem');
      const dsB = b.sub.find(s => s.type === 'dsmem');
      if (dsA && dsB) {
        ctx.beginPath();
        ctx.moveTo(dsA.x + dsA.w, dsA.y + dsA.h/2);
        ctx.lineTo(dsB.x, dsB.y + dsB.h/2);
        ctx.strokeStyle = `rgba(34,211,238,${pulse * 0.5})`;
        ctx.lineWidth = 1.5; ctx.setLineDash([3,3]); ctx.stroke(); ctx.setLineDash([]);
      }
    }
  }

  // Bus
  const bus = layout.bus;
  const busPulse = Math.sin(Date.now()/400) * 0.3 + 0.5;
  ctx.setLineDash([5, 3]);
  ctx.beginPath(); ctx.moveTo(bus.x1, bus.y); ctx.lineTo(bus.x2, bus.y);
  ctx.strokeStyle = '#f0659540'; ctx.lineWidth = 2; ctx.stroke();
  ctx.setLineDash([]);
  ctx.beginPath(); ctx.moveTo(bus.x1, bus.y); ctx.lineTo(bus.x2, bus.y);
  ctx.strokeStyle = `rgba(240,101,149,${busPulse * 0.12})`; ctx.lineWidth = 7; ctx.stroke();
  ctx.font = `500 ${7.5*fs}px "JetBrains Mono"`;
  ctx.fillStyle = '#f06595'; ctx.textAlign = 'center';
  ctx.fillText(bus.label, (bus.x1+bus.x2)/2, bus.y - 8);

  // Bus ‚Üí L2 line
  ctx.beginPath(); ctx.moveTo(W/2, bus.y); ctx.lineTo(W/2, layout.l2.y);
  ctx.strokeStyle = '#2a2d3a'; ctx.lineWidth = 1.5; ctx.stroke();

  // L2
  const l2 = layout.l2;
  rrect(l2.x, l2.y, l2.w, l2.h, 7);
  ctx.fillStyle = '#1a1408'; ctx.fill();
  ctx.strokeStyle = '#ffa94d50'; ctx.lineWidth = 1.5; ctx.stroke();
  ctx.font = `700 ${11*fs}px "Outfit"`;
  ctx.fillStyle = '#ffa94d'; ctx.textAlign = 'center';
  ctx.fillText(arch.blocks.l2.label, l2.x + l2.w/2, l2.y + 18*fs);

  const slices = mob ? 8 : 12;
  const slW = (l2.w - 20) / slices;
  for (let i = 0; i < slices; i++) {
    ctx.fillStyle = `hsl(32,40%,${15 + Math.sin(Date.now()/600+i*.5)*5}%)`;
    ctx.fillRect(l2.x + 10 + i*slW, l2.y + 24*fs, slW - 2, 10*fs);
  }

  // L2 persistence bar
  if (layout.l2Persist) {
    const p = layout.l2Persist;
    rrect(p.x, p.y, p.w, p.h, 2);
    const grad = ctx.createLinearGradient(p.x, 0, p.x + p.w, 0);
    grad.addColorStop(0, '#ffa94d30'); grad.addColorStop(0.6, '#ffa94d15'); grad.addColorStop(1, '#ffa94d05');
    ctx.fillStyle = grad; ctx.fill();
    ctx.strokeStyle = '#ffa94d30'; ctx.lineWidth = .5; ctx.stroke();
    ctx.font = `500 ${5.5*fs}px "JetBrains Mono"`;
    ctx.fillStyle = '#ffa94d80'; ctx.textAlign = 'center';
    ctx.fillText('PERSIST WINDOW', p.x + p.w/2, p.y + p.h/2 + 2);
  }

  // L2 ‚Üí crossbar
  ctx.beginPath(); ctx.moveTo(W/2, l2.y + l2.h); ctx.lineTo(W/2, layout.crossbar.y);
  ctx.strokeStyle = '#2a2d3a'; ctx.lineWidth = 1.5; ctx.stroke();

  // Crossbar
  const cb = layout.crossbar;
  ctx.setLineDash([3,3]);
  ctx.beginPath(); ctx.moveTo(cb.x1, cb.y); ctx.lineTo(cb.x2, cb.y);
  ctx.strokeStyle = '#339af030'; ctx.lineWidth = 1.5; ctx.stroke();
  ctx.setLineDash([]);
  ctx.font = `500 ${7*fs}px "JetBrains Mono"`;
  ctx.fillStyle = '#339af0'; ctx.textAlign = 'center';
  ctx.fillText('MEMORY CROSSBAR / NoC', (cb.x1+cb.x2)/2, cb.y - 6);

  // Crossbar ‚Üí Global
  ctx.beginPath(); ctx.moveTo(W/2, cb.y); ctx.lineTo(W/2, layout.globalMem.y);
  ctx.strokeStyle = '#2a2d3a'; ctx.lineWidth = 1.5; ctx.stroke();

  // Global mem
  const gm = layout.globalMem;
  rrect(gm.x, gm.y, gm.w, gm.h, 7);
  ctx.fillStyle = '#0d1320'; ctx.fill();
  ctx.strokeStyle = '#339af040'; ctx.lineWidth = 1.5; ctx.stroke();
  ctx.font = `700 ${10*fs}px "Outfit"`;
  ctx.fillStyle = '#339af0'; ctx.textAlign = 'center';
  ctx.fillText('Global Memory Interface', gm.x + gm.w/2, gm.y + 16*fs);
  layout.mcs.forEach((mc, i) => {
    ctx.fillStyle = `hsl(210,50%,${14+Math.sin(Date.now()/500+i)*3}%)`;
    ctx.fillRect(mc.x, mc.y, mc.w, mc.h);
    ctx.font = `500 ${6*fs}px "JetBrains Mono"`;
    ctx.fillStyle = '#339af070'; ctx.textAlign = 'center';
    ctx.fillText(`MC${i}`, mc.x + mc.w/2, mc.y + mc.h/2 + 2);
  });
  ctx.font = `400 ${6*fs}px "JetBrains Mono"`;
  ctx.fillStyle = '#6b7094';
  ctx.fillText(`MC ‚Üí ${arch.blocks.hbm.label}`, gm.x + gm.w/2, gm.y + gm.h - 5);

  // Global ‚Üí HBM
  ctx.beginPath(); ctx.moveTo(W/2, gm.y + gm.h); ctx.lineTo(W/2, layout.hbm.y);
  ctx.strokeStyle = '#2a2d3a'; ctx.lineWidth = 1.5; ctx.stroke();

  // HBM
  const hbm = layout.hbm;
  rrect(hbm.x, hbm.y, hbm.w, hbm.h, 7);
  ctx.fillStyle = '#0d0a18'; ctx.fill();
  ctx.strokeStyle = '#845ef730'; ctx.lineWidth = 1.5; ctx.stroke();
  ctx.font = `700 ${11*fs}px "Outfit"`;
  ctx.fillStyle = '#845ef7'; ctx.textAlign = 'center';
  ctx.fillText(hbm.label, hbm.x + hbm.w/2, hbm.y + 16*fs);
  const stacks = mob ? 4 : 6;
  const stW = (hbm.w - 30) / stacks;
  for (let i = 0; i < stacks; i++) {
    for (let l = 0; l < 3; l++) {
      ctx.fillStyle = `hsl(260,40%,${12+l*3+Math.sin(Date.now()/700+i+l)*2}%)`;
      ctx.fillRect(hbm.x + 15 + i*stW, hbm.y + 22*fs + l*3.5, stW - 4, 3);
    }
  }

  // Flash effects
  flashEffects = flashEffects.filter(f => {
    f.t += 0.02;
    if (f.t >= f.dur) return false;
    rrect(f.x-2, f.y-2, f.w+4, f.h+4, 5);
    ctx.strokeStyle = f.c + Math.round((1-f.t/f.dur)*0.3*255).toString(16).padStart(2,'0');
    ctx.lineWidth = 2; ctx.stroke();
    return true;
  });

  // Particles
  particles.forEach(p => { p.update(dt); p.draw(ctx); });
  particles = particles.filter(p => p.alive);

  // Auto
  if (autoMode) {
    autoTimer += dt;
    if (autoTimer > 2.8) {
      autoTimer = 0;
      const ops = ['read','write','invalidate','writeback','shared'];
      triggerScenario(ops[Math.floor(Math.random()*ops.length)]);
    }
  }

  requestAnimationFrame(drawFrame);
}
let lastTime = 0;
requestAnimationFrame(drawFrame);

// ‚îÄ‚îÄ‚îÄ Particle ‚îÄ‚îÄ‚îÄ
class Particle {
  constructor(from, to, color, label, speed, onDone) {
    this.from = {...from}; this.to = {...to}; this.color = color; this.label = label||'';
    this.t = 0; this.speed = speed || 2; this.alive = true; this.onDone = onDone;
    this.dist = Math.hypot(to.x-from.x, to.y-from.y); this.trail = [];
  }
  update(dt) {
    this.t += (this.speed * dt * 60) / Math.max(this.dist, 1);
    if (this.t >= 1) { this.t = 1; this.alive = false; if (this.onDone) this.onDone(); }
    const cx = this.from.x + (this.to.x-this.from.x)*this.t;
    const cy = this.from.y + (this.to.y-this.from.y)*this.t;
    this.trail.push({x:cx,y:cy}); if (this.trail.length > 16) this.trail.shift();
  }
  draw(ctx) {
    for (let i=0;i<this.trail.length;i++) {
      const p=this.trail[i], a=(1-i/this.trail.length)*0.5, r=2.5-i/this.trail.length*1.5;
      ctx.beginPath(); ctx.arc(p.x,p.y,Math.max(r,.5),0,Math.PI*2);
      ctx.fillStyle=this.color+Math.round(a*255).toString(16).padStart(2,'0'); ctx.fill();
    }
    const cx=this.from.x+(this.to.x-this.from.x)*this.t;
    const cy=this.from.y+(this.to.y-this.from.y)*this.t;
    ctx.beginPath(); ctx.arc(cx,cy,4,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill();
    ctx.beginPath(); ctx.arc(cx,cy,7,0,Math.PI*2); ctx.fillStyle=this.color+'28'; ctx.fill();
    if (this.label) {
      ctx.font='500 8px "JetBrains Mono"'; ctx.fillStyle=this.color; ctx.textAlign='center';
      ctx.fillText(this.label, cx, cy-10);
    }
  }
}

// ‚îÄ‚îÄ‚îÄ Helper positions ‚îÄ‚îÄ‚îÄ
function l1Pos(i) { const l1=layout.sms[i].l1; return {x:l1.x+l1.w/2, y:l1.y+l1.h/2}; }
function smBot(i) { const s=layout.sms[i]; return {x:s.x+s.w/2, y:s.y+s.h}; }
function busP(i) { const s=layout.sms[i]; return {x:s.x+s.w/2, y:layout.bus.y}; }
function l2Top() { return {x:layout.l2.x+layout.l2.w/2, y:layout.l2.y}; }
function l2Bot() { return {x:layout.l2.x+layout.l2.w/2, y:layout.l2.y+layout.l2.h}; }
function cbP() { return {x:W/2, y:layout.crossbar.y}; }
function gmTop() { return {x:layout.globalMem.x+layout.globalMem.w/2, y:layout.globalMem.y}; }
function gmBot() { return {x:layout.globalMem.x+layout.globalMem.w/2, y:layout.globalMem.y+layout.globalMem.h}; }
function hbmTop() { return {x:layout.hbm.x+layout.hbm.w/2, y:layout.hbm.y}; }
function flash(b, c) { flashEffects.push({x:b.x,y:b.y,w:b.w,h:b.h,c,t:0,dur:.5}); }

// ‚îÄ‚îÄ‚îÄ Explanations (arch-aware) ‚îÄ‚îÄ‚îÄ
function getExplanation(type) {
  const arch = currentArch;
  const e = {
    read: {
      title: 'L1 Read Miss ‚Üí L2 Fetch',
      color: '#ff6b6b',
      steps: [
        {text:'<strong>Warp issues load</strong> ‚Äî global memory read dispatched.', micro:'LD.E Rx, [addr]', delay:0},
        {text:`<strong>L1 tag lookup: MISS</strong> ‚Äî ${arch==='pascal'?'L1 is read-only cache, miss on cold line':'line not present in unified L1'}.`, micro:'Tag compare ‚Üí miss', delay:700},
        {text:'<strong>Request to L2</strong> ‚Äî read request travels down to the L2 slice.', micro:'RdReq ‚Üí Bus ‚Üí L2', delay:1500},
        {text:'<strong>L2 hit</strong> ‚Äî data read from L2 SRAM array.', micro:`L2 ${ARCHS[arch].blocks.l2.size} slice lookup`, delay:2500},
        {text:'<strong>Data returns</strong> ‚Äî cache line fills L1.', micro:'DATA ‚Üí SM L1 fill', delay:3300},
        {text:`<strong>L1 ‚Üí Shared</strong> ‚Äî ${arch==='pascal'?'line cached read-only (writes bypass L1)':'line cached, can be invalidated by other SM writes'}.`, micro:'State: Invalid ‚Üí Shared', delay:4000},
      ],
      summary: arch==='pascal'
        ? 'Pascal L1 is read-only for globals ‚Äî writes bypass L1 entirely and go to L2. No write coherency needed at L1.'
        : arch==='hopper'
        ? 'Hopper can use TMA for bulk loads, bypassing the warp scheduler entirely. But individual loads still follow this path.'
        : 'Standard read miss path. Coalescing (combining adjacent thread addresses) is critical for bandwidth.'
    },
    write: {
      title: arch==='pascal' ? 'SM Write ‚Üí Direct to L2' : 'SM Write ‚Üí Invalidate Others',
      color: '#51cf66',
      steps: arch === 'pascal' ? [
        {text:'<strong>Warp issues store</strong> ‚Äî global memory write.', micro:'ST.E [addr], Rx', delay:0},
        {text:'<strong>L1 bypassed</strong> ‚Äî Pascal L1 is read-only for global stores. Write goes directly to L2.', micro:'Write-through: skip L1', delay:500},
        {text:'<strong>L2 absorbs write</strong> ‚Äî data written to L2 slice. This is the single coherent copy.', micro:'L2 SRAM write', delay:1200},
        {text:'<strong>No invalidation needed</strong> ‚Äî since L1 only caches reads, there are no dirty L1 copies to worry about.', micro:'No INV broadcast', delay:1800},
      ] : [
        {text:'<strong>Warp issues store</strong> ‚Äî global memory write.', micro:'ST.E [addr], Rx', delay:0},
        {text:`<strong>L1 ‚Üí Modified</strong> ‚Äî write-evict policy: ${arch==='hopper'?'line written and evicted to L2 via cluster bus':'dirty line evicted, write goes to L2'}.`, micro:'Write-evict: L1 drop + L2 write', delay:500},
        {text:'<strong>Invalidation broadcast</strong> ‚Äî other SMs with this line get INV.', micro:'INV ‚Üí all SMs via bus', delay:1200},
        {text:'<strong>Remote L1s invalidated</strong> ‚Äî stale copies dropped.', micro:'Other SMs: * ‚Üí Invalid', delay:2000},
        {text:'<strong>Coherency restored</strong> ‚Äî L2 has latest copy.', micro:'Single-writer invariant', delay:2800},
      ],
      summary: arch==='pascal'
        ? 'Pascal\'s simplicity: L1 is read-only, so writes go straight to L2. No invalidation traffic. Clean but limits L1 usefulness for write-heavy kernels.'
        : 'Write-evict: the SM drops its L1 line and writes to L2. Simpler than CPU write-back but generates more L2 traffic.'
    },
    invalidate: {
      title: 'Broadcast Invalidation',
      color: '#f06595',
      steps: [
        {text:'<strong>Coherency event</strong> ‚Äî write or DMA requires invalidation.', micro:arch==='pascal'?'Less common (L1 is read-only)':'SM write or host DMA', delay:0},
        {text:'<strong>Bus broadcasts INV</strong> ‚Äî message fans out to all SMs.', micro:`INV(addr) ‚Üí ${currentArch==='hopper'?'cluster SMs':'all SMs'}`, delay:600},
        {text:'<strong>L1 tags probed</strong> ‚Äî each SM checks for the address.', micro:'Parallel tag lookup', delay:1200},
        {text:'<strong>All copies dropped</strong> ‚Äî next access will miss.', micro:'All: * ‚Üí Invalid', delay:2200},
      ],
      summary: currentArch==='hopper'
        ? 'Hopper scopes invalidation to the cluster level where possible, reducing broadcast cost. Cross-cluster coherency still goes through L2.'
        : 'Broadcast invalidation scales linearly with SM count ‚Äî a key reason GPU coherency is "relaxed" compared to CPUs.'
    },
    writeback: {
      title: 'Write-Back ‚Üí L2 ‚Üí ' + ARCHS[currentArch].blocks.hbm.label,
      color: '#ffa94d',
      steps: [
        {text:'<strong>L1 eviction</strong> ‚Äî dirty line needs to leave L1.', micro:arch==='pascal'?'Less common (L1 read-only)':'Capacity eviction or flush', delay:0},
        {text:'<strong>Data ‚Üí L2</strong> ‚Äî cache line travels to L2 slice.', micro:'WB+DATA ‚Üí L2 slice', delay:800},
        {text:`<strong>L2 absorbs</strong> ‚Äî ${(arch==='ampere'||arch==='hopper')?'persistence window may protect from eviction':'line written to L2 SRAM'}.`, micro:'L2 write', delay:1800},
        {text:'<strong>L2 eviction</strong> ‚Äî if full, victim line evicted to DRAM.', micro:'LRU victim ‚Üí NoC ‚Üí MC', delay:3000},
        {text:`<strong>${ARCHS[arch].blocks.hbm.label} write</strong> ‚Äî MC issues DRAM write.`, micro:'MC ‚Üí bank write', delay:4000},
        {text:`<strong>Stored in ${ARCHS[arch].blocks.hbm.label}</strong> ‚Äî data persisted.`, micro:'~400+ cycles total', delay:4800},
      ],
      summary: (arch==='ampere'||arch==='hopper')
        ? 'L2 persistence (cudaAccessPolicyWindow) can prevent hot data from being evicted, short-circuiting this cascade for frequently reused lines.'
        : 'Full eviction cascade: L1‚ÜíL2‚ÜíMC‚ÜíDRAM. The memory controllers pipeline and batch writes for bus utilization.'
    },
    shared: {
      title: currentArch==='hopper' ? 'Shared Mem + DSMEM' : 'Shared Memory Access',
      color: '#51cf66',
      steps: currentArch === 'hopper' ? [
        {text:'<strong>Thread accesses __shared__</strong> ‚Äî on-chip SRAM scratchpad.', micro:'LDS Rx, [smem_addr]', delay:0},
        {text:'<strong>Direct SRAM access</strong> ‚Äî no tags, no coherency. 32 banks.', micro:'~20 cycles', delay:500},
        {text:'<strong>DSMEM option</strong> ‚Äî can also access other SMs\' shared memory within the cluster.', micro:'dst_sm.smem[addr] ‚Äî cross-SM', delay:1200},
        {text:'<strong>Cluster-local</strong> ‚Äî DSMEM at SMEM latency, no global memory round-trip.', micro:'~20 cycles cross-SM', delay:1800},
      ] : (currentArch === 'ampere') ? [
        {text:'<strong>Thread accesses __shared__</strong> ‚Äî on-chip SRAM.', micro:'LDS Rx, [smem_addr]', delay:0},
        {text:'<strong>Direct SRAM access</strong> ‚Äî no coherency. 32 banks.', micro:'~20 cycles', delay:500},
        {text:'<strong>cp.async available</strong> ‚Äî can load global‚ÜíSMEM bypassing registers.', micro:'cp.async: global ‚Üí SMEM direct', delay:1200},
        {text:'<strong>Overlap compute + load</strong> ‚Äî async copy runs while warps compute.', micro:'Double-buffering pattern', delay:1800},
      ] : [
        {text:'<strong>Thread accesses __shared__</strong> ‚Äî on-chip SRAM.', micro:'LDS Rx, [smem_addr]', delay:0},
        {text:'<strong>Direct SRAM access</strong> ‚Äî no tags, no coherency.', micro:'~20 cycles, 32 banks', delay:500},
        {text:'<strong>Bank conflict check</strong> ‚Äî same-bank different-address serializes.', micro:'Best: 1 cycle. Worst: 32-way', delay:1100},
        {text:'<strong>SM-local only</strong> ‚Äî invisible to other SMs. No bus traffic.', micro:'Scope: CTA local', delay:1600},
      ],
      summary: currentArch==='hopper'
        ? 'Hopper\'s DSMEM is a game-changer: threads can directly access other SMs\' shared memory within a cluster, enabling new communication patterns without global memory.'
        : currentArch==='ampere'
        ? 'Ampere\'s cp.async enables software-pipelined GEMM: load next tile while computing current tile, hiding global memory latency.'
        : 'Shared memory sidesteps coherency entirely by being SM-private. The programmer\'s most powerful tool for data reuse.'
    }
  };
  return e[type];
}

// ‚îÄ‚îÄ‚îÄ Explainer ‚îÄ‚îÄ‚îÄ
function showExplanation(type) {
  const exp = getExplanation(type);
  if (!exp) return;
  stepTimers.forEach(t => clearTimeout(t)); stepTimers = [];
  const titleEl = document.getElementById('explainer-title');
  titleEl.innerHTML = `<span class="dot" style="background:${exp.color}"></span> ${exp.title}`;
  titleEl.style.color = exp.color;
  const listEl = document.getElementById('step-list'); listEl.innerHTML = '';
  const sumEl = document.getElementById('explainer-summary'); sumEl.textContent = ''; sumEl.classList.remove('visible');

  exp.steps.forEach((s, i) => {
    const li = document.createElement('li');
    li.innerHTML = `<span class="step-num" style="background:${exp.color}20;color:${exp.color}">${i+1}</span>
      <span class="step-text">${s.text}<span class="micro">${s.micro}</span></span>`;
    listEl.appendChild(li);
    stepTimers.push(setTimeout(() => {
      listEl.querySelectorAll('li.active').forEach(el => { el.classList.remove('active'); el.classList.add('past'); });
      li.classList.add('visible', 'active');
    }, s.delay));
  });

  stepTimers.push(setTimeout(() => {
    sumEl.textContent = exp.summary; sumEl.classList.add('visible');
    listEl.querySelectorAll('li.active').forEach(el => { el.classList.remove('active'); el.classList.add('past'); });
  }, exp.steps[exp.steps.length-1].delay + 1000));
}

// ‚îÄ‚îÄ‚îÄ Scenarios ‚îÄ‚îÄ‚îÄ
function logEvent(msg, color) {
  const log = document.getElementById('event-log');
  const e = document.createElement('div'); e.className = 'log-entry';
  e.innerHTML = `<span class="tag" style="background:${color}30;color:${color}">${new Date().toLocaleTimeString().slice(0,8)}</span> ${msg}`;
  log.prepend(e); if (log.children.length > 40) log.lastChild.remove();
}

function updateStats() {
  document.getElementById('stat-hits').textContent = stats.hits;
  document.getElementById('stat-misses').textContent = stats.misses;
  document.getElementById('stat-inv').textContent = stats.inv;
  document.getElementById('stat-wb').textContent = stats.wb;
}

function triggerScenario(type) {
  const si = Math.floor(Math.random() * layout.sms.length);
  showExplanation(type);
  const sm = layout.sms[si];

  switch (type) {
    case 'read': {
      sm.l1.state = 'invalid'; stats.misses++;
      logEvent(`SM${si}: L1 read miss ‚Üí L2`, '#ff6b6b');
      particles.push(new Particle(l1Pos(si), busP(si), '#ff6b6b', 'RdReq', 2, () => {
        particles.push(new Particle(busP(si), l2Top(), '#ff6b6b', 'RdReq', 2.5, () => {
          stats.hits++; logEvent('L2: Hit ‚Üí data returning', '#ffa94d');
          particles.push(new Particle(l2Top(), busP(si), '#ffa94d', 'DATA', 2, () => {
            particles.push(new Particle(busP(si), l1Pos(si), '#ffa94d', 'DATA', 2, () => {
              sm.l1.state = 'shared'; flash(sm.l1, '#339af0');
              logEvent(`SM${si}: L1 ‚Üí Shared`, '#339af0');
            }));
          }));
        }));
      }));
      break;
    }
    case 'write': {
      if (currentArch === 'pascal') {
        // Write-through: bypass L1, go to L2
        logEvent(`SM${si}: Write ‚Üí L2 (L1 bypassed)`, '#51cf66');
        stats.hits++;
        particles.push(new Particle(l1Pos(si), busP(si), '#51cf66', 'WR', 2, () => {
          particles.push(new Particle(busP(si), l2Top(), '#51cf66', 'WR', 2.5, () => {
            flash(layout.l2, '#ffa94d');
            logEvent('L2: Write absorbed', '#ffa94d');
          }));
        }));
      } else {
        sm.l1.state = 'modified'; stats.hits++;
        logEvent(`SM${si}: Write ‚Üí Modified + invalidate`, '#51cf66');
        flash(sm.l1, '#51cf66');
        layout.sms.forEach((o, i) => {
          if (i !== si && o.l1.state !== 'invalid') {
            setTimeout(() => {
              particles.push(new Particle(busP(si), busP(i), '#f06595', 'INV', 3, () => {
                o.l1.state = 'invalid'; stats.inv++;
                flash(o.l1, '#f06595');
                logEvent(`SM${i}: Invalidated`, '#f06595');
                updateStats();
              }));
            }, i * 150);
          }
        });
      }
      break;
    }
    case 'invalidate': {
      stats.inv++;
      logEvent('Broadcast INV', '#f06595');
      layout.sms.forEach((s, i) => {
        setTimeout(() => {
          const from = {x:(layout.bus.x1+layout.bus.x2)/2, y:layout.bus.y};
          particles.push(new Particle(from, busP(i), '#f06595', 'INV', 3, () => {
            particles.push(new Particle(busP(i), l1Pos(i), '#f06595', 'INV', 2, () => {
              s.l1.state = 'invalid'; flash(s.l1, '#f06595');
            }));
          }));
        }, i * 180);
      });
      break;
    }
    case 'writeback': {
      sm.l1.state = 'modified'; stats.wb++;
      logEvent(`SM${si}: Write-back ‚Üí L2`, '#ffa94d');
      particles.push(new Particle(l1Pos(si), busP(si), '#ffa94d', 'WB', 2, () => {
        particles.push(new Particle(busP(si), l2Top(), '#ffa94d', 'WB', 2.5, () => {
          flash(layout.l2, '#ffa94d'); sm.l1.state = 'shared';
          logEvent('L2: Write-back received', '#ffa94d');
          setTimeout(() => {
            particles.push(new Particle(l2Bot(), cbP(), '#339af0', 'EVICT', 2, () => {
              particles.push(new Particle(cbP(), gmTop(), '#339af0', 'WR', 2, () => {
                flash(layout.globalMem, '#339af0');
                particles.push(new Particle(gmBot(), hbmTop(), '#845ef7', 'STORE', 1.5, () => {
                  flash(layout.hbm, '#845ef7');
                  logEvent(`${ARCHS[currentArch].blocks.hbm.label}: Stored`, '#845ef7');
                }));
              }));
            }));
          }, 500);
        }));
      }));
      break;
    }
    case 'shared': {
      const smemBlock = sm.sub.find(b => b.type === 'smem');
      if (!smemBlock) break;
      logEvent(`SM${si}: SMEM access`, '#51cf66');
      flash(smemBlock, '#51cf66'); stats.hits++;
      const from = {x:sm.x+sm.w/2, y:sm.sub.find(b=>b.type==='regs').y+3};
      particles.push(new Particle(from, {x:smemBlock.x+smemBlock.w/2,y:smemBlock.y+smemBlock.h/2}, '#51cf66', 'ST.S', 1.5));

      // DSMEM cross-SM access (Hopper)
      if (currentArch === 'hopper' && layout.sms.length > 1) {
        const other = (si + 1) % layout.sms.length;
        const otherSmem = layout.sms[other].sub.find(b => b.type === 'dsmem');
        const myDsmem = sm.sub.find(b => b.type === 'dsmem');
        if (otherSmem && myDsmem) {
          setTimeout(() => {
            logEvent(`SM${si} ‚Üí SM${other}: DSMEM read`, '#22d3ee');
            particles.push(new Particle(
              {x:myDsmem.x+myDsmem.w/2, y:myDsmem.y+myDsmem.h/2},
              {x:otherSmem.x+otherSmem.w/2, y:otherSmem.y+otherSmem.h/2},
              '#22d3ee', 'DSMEM', 2, () => { flash(otherSmem, '#22d3ee'); }
            ));
          }, 800);
        }
      }
      break;
    }
  }
  updateStats();
}

function toggleAuto() {
  autoMode = !autoMode;
  document.getElementById('btn-auto').classList.toggle('active', autoMode);
}

function resetAll(silent) {
  particles = []; flashEffects = [];
  stats = {hits:0, misses:0, inv:0, wb:0}; updateStats();
  layout.sms.forEach(sm => { sm.l1.state = 'invalid'; });
  document.getElementById('event-log').innerHTML = '';
  stepTimers.forEach(t => clearTimeout(t)); stepTimers = [];
  document.getElementById('explainer-title').innerHTML = '<span class="dot" style="background:#6b7094"></span> Click a scenario or wait for auto...';
  document.getElementById('explainer-title').style.color = '#6b7094';
  document.getElementById('step-list').innerHTML = '';
  const s = document.getElementById('explainer-summary'); s.textContent = ''; s.classList.remove('visible');
  autoTimer = 0;
  if (!silent) logEvent('Reset ‚Äî all caches invalidated', '#6b7094');
}

// Init
buildLayout();
initialized = true;
updateKeyCard();
updateArchIntro();
updatePerfChart();
</script>

</body>
</html>
